<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blogs/images/girl_180_0.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blogs/images/girl_32_0.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blogs/images/girl_16_0.png">
  <link rel="mask-icon" href="/blogs/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blogs/css/main.css">


<link rel="stylesheet" href="/blogs/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"tyson-wu.github.io","root":"/blogs/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="If you want, Just do it!">
<meta property="og:type" content="website">
<meta property="og:title" content="TysonWu&#39;s Blog">
<meta property="og:url" content="https://tyson-wu.github.io/blogs/index.html">
<meta property="og:site_name" content="TysonWu&#39;s Blog">
<meta property="og:description" content="If you want, Just do it!">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Tyson Wu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://tyson-wu.github.io/blogs/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>TysonWu's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blogs/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">TysonWu's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">AiCooXiao</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blogs/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blogs/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blogs/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blogs/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blogs/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Surface_Shader_Basics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/01/Ronja_Surface_Shader_Basics/" class="post-title-link" itemprop="url">Surface Shader Basics</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-01 13:01:00 / 修改时间：22:00:42" itemprop="dateCreated datePublished" datetime="2021-07-01T13:01:00+08:00">2021-07-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/005-simple-surface/">Surface Shader Basics</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>在Unity中，我们可以创建一个空的着色器脚本，然后手动一行一行的去实现整个脚本。当然这种方式比较费时，毕竟着色器有一套固定的流程，因此可以将一部分代码复用，例如光照模型。如果能够直接配置一些参数就能自动生成相关代码，你一定会喜欢吧。Unity就是这么会投其所好，它实现了一种名叫表面着色器的东东，刚好能够满足咱懒人的需求。懒-是推动科技发展的第一生产力，至理名言啊！</p>
<p>那什么是表面作色器呢？在进入正题之前，我建议你先了解最简单的无光照的着色器，如果你不清楚，可以参考我上一个<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Basic_Shader/">教程</a>。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/005/Result.png"></p>
<h2 id="Conversion-to-simple-Surface-Shader"><a href="#Conversion-to-simple-Surface-Shader" class="headerlink" title="Conversion to simple Surface Shader"></a>Conversion to simple Surface Shader</h2><p>相比于前面介绍的着色器实现方法，表面着色器的实现就显得更加简洁，原先需要处理的很多内容都可以剔除，因为Unity会自动帮我们生成相关代码。以上一个教程的着色器脚本为例，如果我们要用表面着色器来实现，那么前面提到的什么顶点着色器都可以不要了。与之相对应的宏命令也可以删除，两者之间的插值数据也可以不要了。甚至是<code>UnityCG.cginc</code>文件也可以不要，还有<code>MainTex_ST</code>等等。这些代码最终都会由Unity自动生成。一顿大刀阔斧，来看看我们的成果吧：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/005_surface&quot;</span> &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		CGPROGRAM</span><br><span class="line"></span><br><span class="line">		sampler2D _MainTex;</span><br><span class="line">		fixed4 _Color;</span><br><span class="line"></span><br><span class="line">		<span class="function">fixed4 <span class="title">frag</span> <span class="params">(v2f i)</span> : SV_TARGET </span>&#123;</span><br><span class="line">			fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">			col *= _Color;</span><br><span class="line">			<span class="keyword">return</span> col;</span><br><span class="line">		&#125;</span><br><span class="line">		ENDCG</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack <span class="string">&quot;Standard&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简洁的令人发指！等等，先别急着感叹，还有事没做完。上面的着色器脚本并不能执行，因为表面着色器有自己的一些要求。</p>
<p>首先，我们需要添加一个新的数据类型作为片段着色器的输入。这个数据类型将会包含所有与片段着色相关的必要数据。当然，我们这个简单的不能再简单的着色器只需要传递UV坐标。UV坐标还是二维向量。但是，这里的UV变量命名有特殊的规则。因为UV坐标是用来纹理采样的，上一章讲过UV变换，每一个纹理都有自己的缩放、偏移参数，所以必须将变换后的UV和对应的纹理相关联。这里采用命名规则来实现，首先UV变量必须以<code>uv</code>开头，然后后面跟随纹理变量的名称。这样，在后面自动生成代码的时候，程序就知道谁和谁配对了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">	float2 uv_MainTex;<span class="comment">//此时配对的纹理是 _MainTex</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来我们要对之前的片段着色其进行修改，使其编程表面着色器。为了区分两者，先把函数名改为<code>surf</code>。然后表面着色器函数是没有返回值的，所以函数返回类型改为<code>void</code>。</p>
<p>然后再拓展出两个参数。第一个参数正是我们刚刚定义好的<code>Input</code>结构，通过这个参数，表面着色器可以获取所有相关的必要参数；第二个参数是一个叫做<code>SurfaceOutputStandard</code>的结构体，从字面意思可以看出，这就是表面着色器的最终输出数据。当然，在函数结束之前，必须计算好、并赋值所有需要外传的参数。除了<code>SurfaceOutputStandard</code>结构外，Unity还定义了其他类似的结构，它们之间的区别在于适用于不同的光照模型。而这些结构中的成员变量就包含了后续光照处理所必须的数据，这些数据的具体含义将在后面介绍。</p>
<p>然后是删除<code>SV_Target</code>语义标识符，因为我们的<code>surf</code>函数的返回类型是<code>void</code>。</p>
<p>最后是把<code>return</code>语句删除。然后将计算所得的数据通过<code>SurfaceOutputStandard</code>传递出去。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">	fixed4 col = tex2D(_MainTex, i.uv_MainTex);</span><br><span class="line">	col *= _Color;</span><br><span class="line">	o.Albedo = col.rgb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一步，我们需要引入光照模型，同时将写好的表面着色器函数与表面着色器相关联，这个和顶点着色器类似，都是通过<code>#pragma</code>来实现。因为我们这里的<code>surf</code>的输出结构是<code>SurfaceOutputStandard</code>，意味着我们使用标准的光照模型。所以在其后我们还得加上<code>Standard</code>来说明所用的光照模型，最后的<code>fullforwordshadows</code>是告诉Unity使用前向阴影。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/005_surface&quot;</span> &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		CGPROGRAM</span><br><span class="line"></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">pragma</span> surface surf Standard fullforwardshadows</span></span><br><span class="line"></span><br><span class="line">		sampler2D _MainTex;</span><br><span class="line">		fixed4 _Color;</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">			float2 uv_MainTex;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">			fixed4 col = tex2D(_MainTex, i.uv_MainTex);</span><br><span class="line">			col *= _Color;</span><br><span class="line">			o.Albedo = col.rgb;</span><br><span class="line">		&#125;</span><br><span class="line">		ENDCG</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/005/SimpleAlbedo.png"></p>
<h2 id="Standard-Lighting-Properties"><a href="#Standard-Lighting-Properties" class="headerlink" title="Standard Lighting Properties"></a>Standard Lighting Properties</h2><p>在<code>SurfaceOutputStandard</code>结构中包含很多材质相关的属性参数，具体如下：</p>
<ul>
<li>Albedo : 表示材质表面的颜色。而材质最终呈现的颜色受光照的影响，因为材质本身只能决定对吸收哪些波段的光。</li>
<li>Normal : 表示材质表面法向向量。法向向量一般和顶点坐标一起，存储在模型数据中，这时候法向向量所在的坐标系是切向空间。什么是切向空间呢？可以简单的理解为沿着模型表面的坐标系。而法向是指垂直与模型表面的方向。法向向量一般要变换到世界坐标系再参与计算。</li>
<li>Emission ：表示材质的自发光特性。一般的的模型渲染依赖于外部光源，如果关闭外部光源，那么模型表现为黑色。而具备自发光材质的模型即便没有外部光源也能显示出原本的颜色。一般场景中的灯具、或者熔岩会使用自发光属性。</li>
<li>Metallic ：表示材质的金属特性。现实中，金属材料和非金属材料的光学特性不一样，例如即便黑色的金属也能在阳光下反射光芒，但是黑色的非金属就表现的黯淡无光。</li>
<li>Smoothness : 表示材质的光滑度。光滑程度主要决定漫反射、和镜面反射之间的权重分布。玻璃的光滑度非常高，所以可以用来做镜子，而一般木材非常粗糙。</li>
<li>Occlusion ：表示环境遮罩特性。举个例子，平坦的桌面上，光线能够达到每个角落。而崎岖不平的背包上，那些深深的褶皱显得格外阴暗。这些因为表面相互遮挡而产生的阴影就是我们这里的环境遮罩效果。</li>
<li>Alpha : 表示材质的透明度。从字面可以很好理解，有些材质是透明的，如玻璃，有些不是，如木头。</li>
</ul>
<p>上面提到的这些参数前三个是向量，后四个是标量。这些参数有些可以直接暴露在材质面板，方便美术编辑材质效果。</p>
<h2 id="Implement-a-few-Lighting-Properties"><a href="#Implement-a-few-Lighting-Properties" class="headerlink" title="Implement a few Lighting Properties"></a>Implement a few Lighting Properties</h2><p>接下来我们把<code>emission</code>、<code>metallic</code>、<code>smoothness</code>三个参数为例，将其作为材质的可调参数。当然你也可以根据实际需求做调整。</p>
<p>首先，我们定义两个公共变量：光滑度和金属度。它们的类型我选择<code>half</code>。一般来说除了坐标采用<code>float</code>，其他的都选<code>half</code>类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">half _Smoothness;</span><br><span class="line">half _Metallic;</span><br></pre></td></tr></table></figure>

<p>然后将这些公共变量添加到<code>Properties</code>块中，将其暴露在材质面板上。但是材质面板并不知道所显示的变量的类型，所以还需要在其名称后增加类型说明，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Properties &#123;</span><br><span class="line">	_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">	_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">	_Smoothness (<span class="string">&quot;Smoothness&quot;</span>, <span class="keyword">float</span>) = <span class="number">0</span></span><br><span class="line">	_Metallic (<span class="string">&quot;Metalness&quot;</span>, <span class="keyword">float</span>) = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>surf</code>函数中，我们可以直接将这些公共变量传递给<code>SurfaceOutputStandard</code>结构体，这样在后续的光照计算中，就可以使用这些参数了，同时我们修改材质面板上的值，便能立即改变材质的表现效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">	fixed4 col = tex2D(_MainTex, i.uv_MainTex);</span><br><span class="line">	col *= _Color;</span><br><span class="line">	o.Albedo = col.rgb;</span><br><span class="line">	o.Metallic = _Metallic;</span><br><span class="line">	o.Smoothness = _Smoothness;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前为止，表面着色器已经基本完成了。但是还有些需要完善的地方，因为我们在材质面板上修改参数时，很容易设置到非法值，最终导致材质显示异常。我们可以在<code>Properties</code>做些小修改，将<code>float</code>修改为<code>Range(0,1)</code>就可以将这些参数限定在一个有效范围内。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Properties &#123;</span><br><span class="line">	_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">	_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">	_Smoothness (<span class="string">&quot;Smoothness&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">	_Metallic (<span class="string">&quot;Metalness&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/005/Inspector.png"></p>
<p>接下来我们添加自发光颜色。同样的我们也需要在公共变量、和<code>Properties</code>中加入<code>_Emission</code>的定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">_Emission (<span class="string">&quot;Emission&quot;</span>, Color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">half3 _Emission;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">o.Emission = _Emission;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/005/Emissive.png"></p>
<p>为了避免自发光材质过度曝光，我们只能将自发光颜色限定在<code>[0-1]</code>之间。当然，如果我们将自发光颜色定义为HDR类型的话，就可以不用担心过曝的问题了。如果我们使用纹理来将材质各个部位的自发光特性差别化，那么可以产生很炫的效果。例如怪兽的眼睛放光的效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[HDR] _Emission (<span class="string">&quot;Emission&quot;</span>, Color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/005/HdrInspector.png"></p>
<h2 id="Minor-Improvements"><a href="#Minor-Improvements" class="headerlink" title="Minor Improvements"></a>Minor Improvements</h2><p>最后，让我们做一些小改动，让我们的材质看起来更自然。首先，我们在着色器脚本最后面加上<code>fallback shader</code>，这样我们可以复用其他着色器中的代码。这里我将标准着色器作为我们的<code>fallback shader</code>，然后复用其中的阴影渲染部分<code>shadow pass</code>的代码，这样就可以让我们的材质也表现出阴影效果。我们使用<code>fullfowardshadows</code>参数进而获得很好的阴影效果。另外我们也可以指定当前着色器的目标平台，例如设置<code>target</code>为3.0。其中<code>target</code>的值越高，表示可以使用的特性越多，但是支持的硬件平台会越少。这里<code>target</code>为3.0，已经可以使用大多数的高级特性了，所以能够实现更好的光照效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/005_surface&quot;</span> &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">		_Smoothness (<span class="string">&quot;Smoothness&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">		_Metallic (<span class="string">&quot;Metalness&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">		[HDR] _Emission (<span class="string">&quot;Emission&quot;</span>, color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		CGPROGRAM</span><br><span class="line"></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">pragma</span> surface surf Standard fullforwardshadows</span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">pragma</span> target 3.0</span></span><br><span class="line"></span><br><span class="line">		sampler2D _MainTex;</span><br><span class="line">		fixed4 _Color;</span><br><span class="line"></span><br><span class="line">		half _Smoothness;</span><br><span class="line">		half _Metallic;</span><br><span class="line">		half3 _Emission;</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">			float2 uv_MainTex;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">			fixed4 col = tex2D(_MainTex, i.uv_MainTex);</span><br><span class="line">			col *= _Color;</span><br><span class="line">			o.Albedo = col.rgb;</span><br><span class="line">			o.Metallic = _Metallic;</span><br><span class="line">			o.Smoothness = _Smoothness;</span><br><span class="line">			o.Emission = _Emission;</span><br><span class="line">		&#125;</span><br><span class="line">		ENDCG</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack <span class="string">&quot;Standard&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/005/Result.png"></p>
<p>希望本章的介绍能让你有所收获！</p>
<p>你可以在一下链接找到源码：<a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/005_Surface_Basics/simple_surface.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/005_Surface_Basics/simple_surface.shader</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Basic_Shader/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/01/Ronja_Basic_Shader/" class="post-title-link" itemprop="url">Basic Shader</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-01 12:01:00 / 修改时间：22:00:42" itemprop="dateCreated datePublished" datetime="2021-07-01T12:01:00+08:00">2021-07-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/004-basic/">Basic Shader</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>在前面三个教程中，我介绍了着色器工作的基本原理、与结构。接下来我进一步介绍如何修改其中的内容。</p>
<p>在此之前，我并没有介绍着色器的执行代码部分。因为作为入门介绍，我们需要从结构框架入手，而不应该拘泥于细节。在大致了解着色器的实现流程后，接下来让我们来发现更有趣的细节。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/004/Result.png"></p>
<h2 id="What-we-have-so-far"><a href="#What-we-have-so-far" class="headerlink" title="What we have so far"></a>What we have so far</h2><p>下面的着色器脚本，如果你觉得有前三章没有阐述到位的地方，都可以告诉我。我必将事事有会响！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/001-004_Basic_Unlit&quot;</span>&#123;</span><br><span class="line">	<span class="comment">//这些值将会显示在材质面板上</span></span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		<span class="comment">//当前的标签设置表示的是：不透明渲染，和其他不透明物体处以同一渲染队列</span></span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="comment">//这里包括一些工具函数、以及内置变量</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//定义顶点、片段着色函数</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//材质所用的纹理、以及缩放偏移量</span></span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//材质的颜色，具体一点是：当纹理为白色图片时，材质的颜色</span></span><br><span class="line">			fixed4 _Color;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//模型网格、UI等输入数据，基本代表了模型内在属性</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//当经过顶点着色器处理后，处理的数据经过栅格化插值，然后传入片段着色器</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//顶点着色器函数，主要执行坐标的空间变换</span></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				<span class="comment">//将模型各顶点坐标，转换到裁剪空间</span></span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				<span class="comment">//基于图片的缩放偏移参数，对UV进行变换</span></span><br><span class="line">				o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//片段作色器，主要是计算像素点的颜色</span></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">			    <span class="comment">//基于UV坐标，进行纹理采样</span></span><br><span class="line">				fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">				<span class="comment">//将纹理颜色和材质颜色相乘</span></span><br><span class="line">				col *= _Color;</span><br><span class="line">				<span class="comment">//返回最终的像素点颜色</span></span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Fallback <span class="string">&quot;VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Setting-up-the-shader-stages"><a href="#Setting-up-the-shader-stages" class="headerlink" title="Setting up the shader stages"></a>Setting up the shader stages</h2><p>之前提到的顶点着色器、片段着色器，在着色器脚本中实际上就是<code>HLSL</code>函数。只不过，这些函数对应这渲染管线中的特定阶段。为了将这些函数关联到指定阶段，我们可以使用<code>#pragma</code>关键字来说明。前面经常谈到的顶点着色器、和片段着色器是非常重要的两个阶段。因为顶点着色器负责将模型数据转换到裁剪空间，然后经由栅格化处理，进入到片段着色器，最终有片段着色器计算出像素颜色，并写入渲染对象。可以说这两个着色器代表了渲染的基本流程。其中关联函数的操作如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义顶点、片段着色函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点着色器函数，主要执行坐标的空间变换</span></span><br><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//片段作色器，主要是计算像素点的颜色</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Vertex-stage"><a href="#Vertex-stage" class="headerlink" title="Vertex stage"></a>Vertex stage</h2><p>在实现顶点着色器函数之前，我满需要定义好插值数据类型，前面提到过，这类数据是在顶点着色器中计算好，然后传递给片段着色器的。</p>
<p>顶点着色器的主要功能就是执行空间变换，将顶点数据从模型坐标系转换到裁剪坐标系。空间转换可以借助矩阵乘法来实现。但是，很多时候我们并不需要知道乘法的具体实现，因为Unity为我们提供了很多矩阵变换相关的函数。我们可以使用宏命令来引入Unity预先编写好的工具函数。例如<code>#include UnityCG.cginc</code>。其中<code>UnityObjectToClipPos</code>便是实现模型坐标系到裁剪坐标系的工具函数。而<code>UnityCG.cginc</code>文件中处了定义了很多常用的工具函数外，还定义了很多宏操作。宏操作的使用方法和函数的使用类似。例如，用于UV转换的宏<code>TRANSFORM_TEX</code>，使用顶点UV，以及纹理变量为参数，最终得到转换后的UV坐标。</p>
<p>编写好的顶点着色器函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶点着色器函数，主要执行坐标的空间变换</span></span><br><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    <span class="comment">//将模型各顶点坐标，转换到裁剪空间</span></span><br><span class="line">    o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    <span class="comment">//基于图片的缩放偏移参数，对UV进行变换</span></span><br><span class="line">    o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Fragment-stage"><a href="#Fragment-stage" class="headerlink" title="Fragment stage"></a>Fragment stage</h2><p>在片段着色器中，我们使用由顶点着色器传来的插值数据、以及公共的纹理数据等，来进一步计算每个像素点的颜色。当然，我们可以直接返回白色，如<code>return float4(1,1,1,1);</code>。但是更实际的情况是，我们结合前面提到的数据，通过一些简单、或复杂的计算，来得到比较自然的颜色值。</p>
<p>我们把使用纹理数据的过程叫做纹理采样。因为纹理数据是一整张包含无数像素点的图片，而我们的片段着色器计算的是一个单独像素的颜色。因此我们只需要纹理中的一个像素值。采样的方法也很简单，直接使用<code>tex2D</code>函数就可以，当然还有其他一些复杂一点的采样函数。这里我们以<code>tex2D</code>为例，需要两个参数，第一个是纹理变量，第二个是UV坐标。下面我们除了使用采样后的像素颜色，同时也叠加了公共变量<code>_Color</code>的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段作色器，主要是计算像素点的颜色</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//基于UV坐标，进行纹理采样</span></span><br><span class="line">    fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">    <span class="comment">//将纹理颜色和材质颜色相乘</span></span><br><span class="line">    col *= _Color;</span><br><span class="line">    <span class="comment">//返回最终的像素点颜色</span></span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把上面的各个步骤组合起来，恭喜你，创建了属于你自己的着色器脚本。</p>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/001-004_basic_unlit/basic_unlit.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/001-004_basic_unlit/basic_unlit.shader</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/001-004_Basic_Unlit&quot;</span>&#123;</span><br><span class="line">	<span class="comment">//这些值将会显示在材质面板上</span></span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		<span class="comment">//当前的标签设置表示的是：不透明渲染，和其他不透明物体处以同一渲染队列</span></span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="comment">//这里包括一些工具函数、以及内置变量</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//定义顶点、片段着色函数</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//材质所用的纹理、以及缩放偏移量</span></span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//材质的颜色，具体一点是：当纹理为白色图片时，材质的颜色</span></span><br><span class="line">			fixed4 _Color;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//模型网格、UI等输入数据，基本代表了模型内在属性</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//当经过顶点着色器处理后，处理的数据经过栅格化插值，然后传入片段着色器</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//顶点着色器函数，主要执行坐标的空间变换</span></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				<span class="comment">//将模型各顶点坐标，转换到裁剪空间</span></span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				<span class="comment">//基于图片的缩放偏移参数，对UV进行变换</span></span><br><span class="line">				o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//片段作色器，主要是计算像素点的颜色</span></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">			    <span class="comment">//基于UV坐标，进行纹理采样</span></span><br><span class="line">				fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">				<span class="comment">//将纹理颜色和材质颜色相乘</span></span><br><span class="line">				col *= _Color;</span><br><span class="line">				<span class="comment">//返回最终的像素点颜色</span></span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Fallback <span class="string">&quot;VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Variables/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/01/Ronja_Variables/" class="post-title-link" itemprop="url">Variables</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-01 11:01:00 / 修改时间：22:00:42" itemprop="dateCreated datePublished" datetime="2021-07-01T11:01:00+08:00">2021-07-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/003-variables/">Variables</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>在了解<code>Shaderlab</code>语言的基本结构，以及着色器各个阶段的功能划分，接下来，让我们来学习一下着色器中所用到的变量，以及如何在代码中使用它们。在着色器中，变量可以分为材质变量、模型网格变量、以及各个着色阶段数值传递的中间变量。</p>
<h2 id="Object-Data"><a href="#Object-Data" class="headerlink" title="Object Data"></a>Object Data</h2><p>模型数据。在介绍渲染过程的时候，我所提到的模型数据，实际上就是模型上面的网格数据。从底层角度来看，这些数据定义了模型的几何形状，决定了模型最终显示的形状。不过为了方便描述，我们直接将其归纳为模型数据、或者网格数据。通常情况下，模型数据包含模型中各个顶点的位置、以及三角面片序列。当然有些模型数据还包含的顶点法向、UV、颜色等数据。除了三角面片序列，其他的数据都是逐(个)顶点数据，也就是说顶点法向、UV、颜色、和顶点位置一一对应，具有相同的个数。因为顶点的位置数据是基于模型坐标系，所以，无论模型位置、朝向如何，都不会影响模型数据。所以对于同一种模型，我们可以使用同一个模型数据，然后通过对模型的缩放来实现一定的差异化。</p>
<p>在Unity着色器中， 模型数据首先是传递给顶点着色器，而模型数据通常也是以自定义数据类型表示，Unity也预先帮我们定义了一些类型，例如<code>struct appdata</code>。当然我们也可以按需自定义，类型的名字可以任意，只要不要和已有的重名就行。当然，因为着色器在执行的过程中有一套固定的流程，包括在各个节点使用什么样的数据。而我们定义的类型并不能传达这些信息，因此，需要在自定义类型的成员变量后面加上语义标识。如下所示,通过<code>POSITION</code>来表示我们的<code>vertex</code>是顶点坐标。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">  float4 vertex : POSITION;<span class="comment">//顶点坐标</span></span><br><span class="line">  float2 uv : TEXCOORD0;<span class="comment">//UV坐标</span></span><br><span class="line">&#125;;<span class="comment">//别忘了加分号</span></span><br></pre></td></tr></table></figure>

<p>关于其他定义的语义标识符，可以参考以下链接：<br><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/SL-VertexProgramInputs.html">https://docs.unity3d.com/Manual/SL-VertexProgramInputs.html</a></p>
<h2 id="Interpolators"><a href="#Interpolators" class="headerlink" title="Interpolators"></a>Interpolators</h2><p>插值数据。当顶点着色器将模型数据从模型空间转换到裁剪空间时，顶点着色阶段的任务就已经结束了。这时候需要将处理好的数据传递給下一个阶段，通常情况下是片段着色阶段。但是顶点着色器输出的结果是基于顶点的，但是片段着色器是基于像素点的，例如渲染一个三角形，顶点作色器只处理三个顶点，但是这个三角形投影到屏幕上就不止三个点了，一般会有更多的像素点构成。所以从顶点着色器到片段作色器，前后输出和输入参数个数不对对等，所以需要通过插值的方式来生成其他可能的像素点数据。</p>
<p>这里的插值过程又叫做栅格化处理，因为我们的屏幕是由一格一格的光栅构成，所以有此得名。栅格化处理是由硬件完成的，虽然这一步也属于整个渲染管线的一步，但是我们却不能对其进行修改。所以我们也需要通过语义标识符来告诉硬件，各个数据的用途。例如<code>SV_POSITION</code>就表示投影变换后的顶点坐标，后面也是根据它来进行插值操作，最终得到屏幕像素点。当然还有其他可选的语义标识符可以使用，例如顶点颜色、UV等，用法基本类似。</p>
<p>在习惯上人们通常会将插值数据命名为<code>v2f</code>，也就是<code>vertex to fragment</code>的缩写，表示是从顶点到像素片段的中间变量。具体例子如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该数据是从顶点着色器，经过栅格化处理，传入到片段着色器中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">  float4 position : SV_POSITION;</span><br><span class="line">  float2 uv : TEXCOORD0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Output-color"><a href="#Output-color" class="headerlink" title="Output color"></a>Output color</h2><p>最终输出的颜色值。片段着色器主要用于计算像素点的颜色，通常计算的颜色值由4维向量表示，分别对应红、绿、蓝、透明四个通道。这里也有一个语义标识符来表示输出的颜色<code>SV_Target</code>。</p>
<h2 id="Uniform-data"><a href="#Uniform-data" class="headerlink" title="Uniform data"></a>Uniform data</h2><p>公共数据。因为GPU的渲染过程是一个并行过程，模型数据传入后，在顶点着色器中，顶点之间属于并列关系，同一时间有多个顶点同时执行顶点着色器的逻辑。可以想象成一个军队，每个士兵拿着自己的武器在战场上做着同样的事情。但是这些数据有一些共性，它们同属于一个模型、引用同一张纹理贴图、受同一个光照影响。但是我们不可能为每一个顶点配置一份相同的数据。因此把这些数据抽象出来，形成一个公共部分，所有顶点都可以共享这些数据。在片段着色器中也类似，每个像素也都可以对同一张纹理进行采样。公共数据有很多，除了前面提到的，还有各种空间矩阵、以及一些自定义需求引入的数据。庆幸的是，大部分公共数据Unity都已经为我们定义好了，并且在程序执行时，会对其自动赋值。只有少数我们自己定义的公共数据需要我们初始化。</p>
<p>定义公共数据也很简单，直接向当前着色器代码中定义变量，不过这些变量必须定义在函数体外部。如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//材质所用的纹理、以及缩放偏移量</span></span><br><span class="line">sampler2D _MainTex;</span><br><span class="line">float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line"><span class="comment">//材质的颜色，具体一点是：当纹理为白色图片时，材质的颜色</span></span><br><span class="line">fixed4 _Color;</span><br></pre></td></tr></table></figure>

<p>只要定义了这些公共变量，那么就可以在<code>C#</code>程序中使用<code>Material.Set[Type]</code>接口来对其进行赋值。很多使用我们希望直接在材质面板上设置这些量，这时候只需要将需要暴露在材质面板的变量，在<code>Properties</code>块中重新声明一下，格式为<code>_Variable(&quot;材质面板上显示的名称&quot;, Type) = DefaultValue</code>。材质面板的显示也可以自定义，功能复杂点的需要重写编辑器脚本，简单点的也可以直接在着色器脚本中实现，只需要在<code>Properties</code>块中的变量前增加相应的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/MaterialPropertyDrawer.html">显示设置</a>。一般的来说，<code>Properties</code>块中的变量和公共变量是一对一的关系，但是纹理比较特殊，因为纹理数据比较复杂，除了纹理本身的数据外，还有纹理的缩放、偏移等参数。这时候公共变量中的纹理除了要声明纹理本身外，还要声明这些缩放、偏移参数。和纹理相关的参数的命名有一个规则，必须是纹理名称加相关参数的缩写符。如这里的缩放、偏移参数的缩写符就是<code>_ST</code>，<code>S</code>表示缩放，<code>T</code>表示偏移。例如下面例子中的<code>Properteis</code>块就和上面的公共变量相对应。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Properties&#123;</span><br><span class="line">  _Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">  _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spaces"><a href="#Spaces" class="headerlink" title="Spaces?"></a>Spaces?</h2><p>在着色器中，我们提到位置坐标，就一定会涉及模型、世界、观察、屏幕、裁剪坐标系。这时候，我们说的坐标，必须联系使用场景，来判断当前坐标是处以哪个坐标系。抛开坐标系谈坐标就是无根之木、无水之源。</p>
<p>模型空间坐标系，是以模型为中心，以模型自身为参考的坐标系。<code>(0,0,0)</code>在模型坐标系中表示的是模型的原点。如果我们旋转模型，那么模型坐标系也会跟着旋转，换句话说，我们对模型的空间操作，实际上是对模型坐标系的空间操作。我们的模型文件中存储的顶点坐标实际上就是模型空间坐标系的。在渲染时，传入顶点着色器的顶点坐标也是模型空间坐标系上的坐标。</p>
<p>世界空间坐标系，是一个绝对空间坐标系，有一个固定的参考点，不会因为某个局部影响而改变。世界空间坐标系也是所有模型的空间纽带。现实中我们描述我们的位置，大概率使用的就是世界坐标系。</p>
<p>观察坐标系是以摄像机为参考的坐标系。裁剪坐标系是在观察坐标系的基础上，经过投影变换后的坐标系。如果我们使用的是透视投影，那么模型在摄像机上的投影将会产生近大远小的效果。屏幕坐标系是在裁剪坐标系的基础上，进一步除处理得到的，其中需要经过栅格化处理、视口变换等，这一系列操作就是方便后面的渲染。而在片段着色器上处理的便是屏幕坐标系下的数据，因此我们很多时候可以忽略掉观察坐标系、和裁剪坐标系，同时，Unity也提供了很多工具函数来处理坐标系变换。</p>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p>所有的教程都有配套源码，可以在教程结尾找到相关链接。因为目前我只是做了一些简单的分析介绍，所有源码在上面已经出现过了，这里直接简单的整理一下。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/001-004_basic_unlit/basic_unlit.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/001-004_basic_unlit/basic_unlit.shader</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/001-004_Basic_Unlit&quot;</span>&#123;</span><br><span class="line">	<span class="comment">//这些值将会显示在材质面板上</span></span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		<span class="comment">//当前的标签设置表示的是：不透明渲染，和其他不透明物体处以同一渲染队列</span></span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="comment">//这里包括一些工具函数、以及内置变量</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//定义顶点、片段着色函数</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//材质所用的纹理、以及缩放偏移量</span></span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//材质的颜色，具体一点是：当纹理为白色图片时，材质的颜色</span></span><br><span class="line">			fixed4 _Color;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//模型网格、UI等输入数据，基本代表了模型内在属性</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//当经过顶点着色器处理后，处理的数据经过栅格化插值，然后传入片段着色器</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//顶点着色器函数，主要执行坐标的空间变换</span></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				<span class="comment">//将模型各顶点坐标，转换到裁剪空间</span></span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				<span class="comment">//基于图片的缩放偏移参数，对UV进行变换</span></span><br><span class="line">				o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//片段作色器，主要是计算像素点的颜色</span></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">			    <span class="comment">//基于UV坐标，进行纹理采样</span></span><br><span class="line">				fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">				<span class="comment">//将纹理颜色和材质颜色相乘</span></span><br><span class="line">				col *= _Color;</span><br><span class="line">				<span class="comment">//返回最终的像素点颜色</span></span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Fallback <span class="string">&quot;VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/06/29/Ronja_HLSL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/06/29/Ronja_HLSL/" class="post-title-link" itemprop="url">HLSL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-29 11:01:00" itemprop="dateCreated datePublished" datetime="2021-06-29T11:01:00+08:00">2021-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-01 22:00:42" itemprop="dateModified" datetime="2021-07-01T22:00:42+08:00">2021-07-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/002-hlsl/">HLSL</a></p>
<h2 id="HLSL？"><a href="#HLSL？" class="headerlink" title="HLSL？"></a>HLSL？</h2><p>HLSL是Unity着色器中所使用的一种语言，可以通过HLSL来实现渲染逻辑。HLSL语言是微软设计的、面向D3D的GPU编程语言。严格的说，网络上现有的大多数Unity着色器脚本是通过CG语言编写的，CG是C for Graphics的简写，也就是为图形编辑而设计的C语言。但是CG语法和HLSL有很多共性，同时CG语言在2012年便不再维护，而我们很容易把两者混淆，不过这并不影响我们进一步的学习。理论上，Unity也支持GLSL语言，GLSL是为OpenGL设计的编程语言，也是类C的编程语言。由于HLSL的例子在网络上随处可见，同时Unity会根据平台不同，自动会将着色器脚本翻译为对应的语言，所以我们不必纠结使用哪种语言。为了方便，这里建议直接使用HLSL语言。</p>
<p>因为着色器编程难度较大，所以建议初学者在系统学习过基本的编程，再考虑学习着色器编程。因为着色器脚本是在GPU中运行的，而一般的编辑软件是在CPU中运行，所以在着色器编程过程中，很难进行异常分析。因此这也导致我们开发过程中有很多限制，另外，和普通的软件开发相比，我们需要从不同的角度来思考问题。如果你已经具备了基本的编程素养，知道什么是数据类型、类、函数、循环、条件语句等，也大概知道CPU和GPU的区别、串行与并行的区别，那么欢迎你阅读下面的内容。</p>
<h2 id="Builting-Types"><a href="#Builting-Types" class="headerlink" title="Builting Types"></a>Builting Types</h2><p>首先，我们需要知道在着色器编写过程中，有哪些可以使用的内置数据类型。</p>
<h3 id="Scalar-Values"><a href="#Scalar-Values" class="headerlink" title="Scalar Values"></a>Scalar Values</h3><p>标量。在Unity的hlsl语言中，小数的类型有<code>fixed</code>、<code>half</code>、以及<code>float</code>，整形的类型有<code>int</code>、<code>uint</code>。需要指出的是，在最新的URP渲染管线中，小数的类型只支持<code>half</code>、和<code>float</code>。</p>
<p>在移动端的GPU中，<code>fixed</code>的数据范围为<code>[-2, 2]</code>，其精度为<code>1/256</code>。而<code>half</code>和<code>float</code>分别是16位和32位的浮点数。在PC端的GPU中，这三类都是32位浮点数。所以在后面的内容中，你将会看到我基本上都是使用<code>float</code>来表示小数，当然，后面有工具可以对此进行优化。</p>
<p>整形，也就是我们所知的整数，其中<code>int</code>可以是正数也可以是负数，而<code>uint</code>只能是正数，这两者之间合理的选择，也能达到细微的优化作用。</p>
<p>另外，还支持<code>bool</code>类型，布尔类型数据用于表示是与否的两种状态。如果我们强行将布尔和数值进行加减乘除运算时，那么实际的布尔值的是就变成1、而否就变成0参与计算。</p>
<h3 id="Vector-Values"><a href="#Vector-Values" class="headerlink" title="Vector Values"></a>Vector Values</h3><p>向量。向量在空间上表示的是一个方向，由各个维度的投影分量构成。上提到的标量，从广义上来说是一维向量。向量在HLSL中的表示很简单，只要在上面对应标量的后面加上维度。例如上面的<code>fixed</code>、<code>half</code>、<code>float</code>的四维向量分别是<code>fixed4</code>、<code>half4</code>、<code>float4</code>。向量的使用很常见，例如记录纹理坐标、颜色、位置等信息。</p>
<p>当然，我们也可以访问向量中特定维度的分量。以4维向量v为例，向量数据是一个长度为4的数组，起始索引为0。也就是说v[0]实际上就是访问的第一个维度的值。另外，向量在着色器中主要用于表示空间、和颜色。所以为了方便，可以直接通过维度名称来索引，例如获取x轴的分量可以表示为v.x，获取红色通道的值可以表示为v.r。这些维度、通道的数据就是存储在前面所说的数组中，其顺序为xyzw、和rgba。换句话说，v[0]、v.x、v.r访问的是同一个值。</p>
<p>另外，在实际使用中，我们可能经常遇到需要从一个向量中选取部分值，来重新构成一个新的向量。因此HLSL在语言设计时就引入了这种通过维度、或通道混合的方式来实现向量重构。举个例子：</p>
<ul>
<li>v.xy  ： 选取原向量中的前两个维度，构成一个新的二维向量；</li>
<li>v.zyx ： 选取原向量中的前三个维度，并且调换顺序，构成一个新的三维向量；</li>
<li>v.xxxx:  选取原向量中的第一个维度，构成一个四维向量，新构成的四维向量的各个维度的值都等于原向量中的第一个维度的值；</li>
</ul>
<h3 id="Matrix-Values"><a href="#Matrix-Values" class="headerlink" title="Matrix Values"></a>Matrix Values</h3><p>矩阵。如果说前面的向量是在标量的基础上，朝着一个方向扩展。那么矩阵就是朝着两个方向扩展，分别是横向r、和纵向c。因此矩阵的数据结构是一个二维数组，与标量对应的表示有<code>fixedrxc</code>、<code>halfrxc</code>、<code>floatrxc</code>，其中的r和c表示的是行数和列数。例如<code>float4x4</code>、<code>half3x2</code>、<code>bool2x4</code>。和向量类型，矩阵也可以使用二维数组的方式进行访问，例如<code>matrix[3][2]</code>，访问的是矩阵中第3行、第2列的元素，注意，这里的行号和列号都是从0开始的。除了二维数组的访问方式，还可以使用元素名称进行访问，例如_m32是第3行、第2列的名称。还可以使用名称混合的方式，实现向量重构。例如matrix._m03_m13_m23，是选取矩阵最后一列的前三个元素构成一个三维向量。如果我们采用二维数组的访问方式，但是只传入一个索引号，那么这个索引号表示的是行号，得到的是该行的向量。例如matrix[0]表示的是获取第0行的向量。</p>
<p>矩阵处理非常繁琐，庆幸的是我们很少会需要去单独处理其中的元素，因此可以直接调用现有的辅助函数来实现矩阵运算。</p>
<h3 id="Textures"><a href="#Textures" class="headerlink" title="Textures"></a>Textures</h3><p>HLSL同时也定义了纹理类型。纹理类型比较特殊，这里不做过多讲述，只需要知道，我们可以通过<code>tex2D(texture, coordinate)</code>来对纹理进行采样。当然，在后面的内容我们会了解跟多，I Promise!</p>
<h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p>在数学计算方面，HLSL提供基本的操作方法，例如<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>，可以执行基本的数值计算，而<code>&lt;</code>、<code>&gt;</code>、<code>==</code>、<code>!=</code>、<code>!</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>&amp;&amp;</code>、<code>||</code>可以用于条件比较。除此之外，HLSL还集成了像<code>abs</code>、<code>dot</code>、<code>lerp</code>、<code>pow</code>、<code>min</code>、<code>atan2</code>等常用函数，详情可参考<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-intrinsic-functions">这里</a>。</p>
<p>同时，HLSL也提供一些快捷操作符，例如<code>+=</code>、<code>*=</code>、<code>-=</code>、<code>/=</code>，这些在将操作符左右两边的数据除了后，复值给左边的数据。还有<code>++</code>、<code>--</code>可以用于自增、自减一个单位。</p>
<p>需要注意的是，标量和向量的乘法，是标量乘以向量中的每一个元素，然后生成一个同维度的向量。例如<code>float2(2,7) * 3 == float2(6, 21)</code>。</p>
<p>而矩阵与向量的乘积相对复杂点，在矩阵分析中有介绍，不过直观的理解就是矩阵表示空间坐标系之间的关系，而向量表示空间坐标系中的点、或方向，两者乘积的结果表示向量从一个空间变换到另一个空间。在应用过程中，我们并不太关系该操作的具体实现。初学者可以基于这种直观理解，然后参考模仿现有的应用案例，或者直接从中复制过来，久而久之就知道怎么用了。矩阵向量的乘积使用的函数是<code>mul</code>，具体可以参考<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-mul">这里</a>。</p>
<h2 id="Custom-Types"><a href="#Custom-Types" class="headerlink" title="Custom Types"></a>Custom Types</h2><p>除了内置类型，我们还可以添加一些自定义类型。自定义类型的语法和类C语言的结构体很像，但是需要注意的是，必须在自定义类型后面加上分号<code>;</code>。如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">typeName</span>&#123;</span></span><br><span class="line">  <span class="keyword">float</span> variable;</span><br><span class="line">  float2 otherVariable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>理论上来说，我们也可以使用<code>class</code>关键字、继承、成员函数、甚至是接口类型。但是，目前为止，我只看到使用<code>struct</code>的情况，所以我们依照祖传习惯就好。如果你想做第一个吃螃蟹的人，那么你可以试着将<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/overviews-direct3d-11-hlsl-dynamic-linking-class">这些</a>类C的语法应用上去，能不能正常使用，就全看天意了:-&gt;!</p>
<p>和向量类似，如果我们想访问自定义结构中的成员变量，同样是采用<code>.</code>连接符。例如，instance.variable，或者可以访问成员的成员，如，instance.otherVariable.x。</p>
<h2 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h2><p>变量。在HLSL中，所有的数据都是值类型，这意味着所有操作，都是直接作用在变量上，而不是变量的引用。同时，我们也不需要使用<code>new</code>之类的关键字来创建变量。</p>
<p>当我们希望创建一个向量时，只需要把向量类型当做普通函数调用就可以。例如创建四维向量<code>float4()</code>、<code>float4(1,1,1,1)</code>。在这种情况下，创建向量的所有参数的维度总和，必须等于目标向量的维度。例如创建一个四维向量，可以传入四个标量，也可以传入两个二维向量，还可以传入两个标量加一个二维向量，或者直接传入一个四维向量。如下，以上面的自定义结构为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeName instance;</span><br><span class="line">instance.variable = <span class="number">3.14</span>;</span><br><span class="line">instance.otherVariable = float2(<span class="number">3</span>, <span class="number">1.4</span>);</span><br></pre></td></tr></table></figure>

<p>另外，变量可以声明在函数内、和函数外。如果定义在函数内，那么能在函数内可以使用，并且使用的位置必须在定义之后。如果定义在函数外面，那么所有的函数都可以使用这个变量，不受顺序的影响，但是习惯上我们会将变量统一定义在函数之前。</p>
<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><p>在HLSL中，大多是函数都是全局函数。这意味着它们不属于任何数据结构，并且我们可以在任何位置调用它们。这些函数可以传入一个或多个参数，还可以返回计算结果。如果你不希望函数返回任何值，那么你可以在前面声明为<code>viod</code>。如下是一个函数范例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">returnType <span class="title">functionName</span><span class="params">(argType arg1, otherArgType arg2)</span></span>&#123;</span><br><span class="line">  <span class="comment">//在这里实现函数功能逻辑</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们调用函数的时候，只需要写下函数名，以及后面跟的括号。如果函数接受传参的话，直接将所需参数以逗号分隔，依次写在括号内。这里的函数支持重载，函数和其参数共同构成了该函数的唯一标识，所以我们可以定义多个同名、但不同参的函数体。在调用时，程序会自动根据传入参数来判断所调用的函数。</p>
<h2 id="Control-Flow"><a href="#Control-Flow" class="headerlink" title="Control Flow"></a>Control Flow</h2><p>对于大多是着色器，我们只需要一行接一行的执行相关逻辑，就可以实现我们想要的功能。但是有些复杂点的需求，我们可能需要重复执行某些命令，或者需要丢弃某些命令，这就涉及到代码执行路径选择的问题。在程序上这叫分支语句、或者叫条件语句，还有循环语句。很多人认为，使用分支语句会影响着色器的执行效率，尤其是移动端，所以应该使用<code>step</code>来代替分支语句。这中说法显然不对，因为在<code>step</code>这类函数中本身就是基于分支语句实现的。而且使用<code>step</code>这些函数会使我们程序在逻辑上变得复杂，不利于阅读。当然，上面关于执行效率的说法并不是完全没有依据，假如我们使用分支语句，刚好GPU会执行所有路径，然后丢弃其中一条路径的计算结果，这时候确实存着资源浪费。但是这并不能通过其他技术来避免，毕竟有些逻辑本身就存在分支，所以不要下意识的排斥使用条件语句，而应该多考虑代码的整体结构，是否美观、是否易于阅读。</p>
<h3 id="if-statements"><a href="#if-statements" class="headerlink" title="if statements"></a>if statements</h3><p>如下所示的<code>if</code>语句，如果条件为<code>true</code>，那么执行上半部分的逻辑，否则，执行下半部分的逻辑。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">  <span class="comment">//条件为true，执行这里</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//条件为false，执行这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的<code>else&#123;...&#125;</code>部分是可选的。花括号中的逻辑相当于一个整体。如果我们不使用花括号，那么上面的条件语句只会将其后的一行逻辑代码当成它的分支。上面的<code>condition</code>值可以是<code>bool</code>、或<code>int</code>，也可以是一条语句，但是这条语句的结果必须是前面两者之一。另外，<code>!</code>可以用于逻辑取反，假设我们希望条件为<code>false</code>时执行<code>if</code>后的分支，那么只需要在条件之前加<code>!</code>。</p>
<h3 id="Loops"><a href="#Loops" class="headerlink" title="Loops"></a>Loops</h3><p>除了分支语句，还有另外一种常见的控制流-循环语句。<code>While</code>循环是最简单的循环语句，如果条件为<code>ture</code>时，它将会一直循环下去，直到条件为<code>false</code>为止。如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)&#123;</span><br><span class="line">  <span class="comment">//执行循环逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一点要记住，在<code>while</code>循环语句中，必须要有某一段可执行代码来将条件置为<code>false</code>，如果没有这种代码，那么该循环将会一直执行下去，这是非常严重的问题。</p>
<p>另一种循环叫做<code>for</code>循环，在<code>for</code>循环中可以假如控制循环次数的变量。如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(beforeLoopLogic; condition; inLoopLogic)&#123;</span><br><span class="line">  <span class="comment">//执行循环逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>for</code>循环下循环次数控制方便面，显得更加简单明了。比如从0开始到最大次数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(uint index=<span class="number">0</span>;index&lt;maxValue;index++)&#123;</span><br><span class="line">  <span class="comment">//执行循环逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，我们也可以使<code>while</code>循环来实现同样的功能，但是看起来就没有<code>for</code>循环那么整洁了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uint index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(index &lt; maxValue)&#123;</span><br><span class="line">  <span class="comment">//执行循环逻辑</span></span><br><span class="line"></span><br><span class="line">  index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的循环语句中都支持<code>break</code>和<code>continue</code>关键字。其中<code>break</code>用于中断循环语句，直接跳出循环。而<code>continue</code>是跳过本次循环，但是会继续执行后续的循环。</p>
<p>好了，本篇终结！希望你能喜欢我的教程。如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/06/25/Ronja_Basic_Transparency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/06/25/Ronja_Basic_Transparency/" class="post-title-link" itemprop="url">Basic Transparency</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-25 11:01:00" itemprop="dateCreated datePublished" datetime="2021-06-25T11:01:00+08:00">2021-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-01 22:00:42" itemprop="dateModified" datetime="2021-07-01T22:00:42+08:00">2021-07-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/006-simple-transparency/">Basic Transparency</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>对于不透明物体的渲染，是直接将计算所得到的像素颜色覆盖掉原有的颜色值。而透明物体的渲染方法恰恰相反，是保留原有颜色值，然后两者通过混合后，达到一种看是半透明的效果。为了阐明关键思想，这里以最简单的不受光材质为例。</p>
<p>如果你还不知道如果编写着色器，这里建议你先阅读我之前的<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Basic_Shader/">教程</a><br><img src="https://www.ronja-tutorials.com/assets/images/posts/006/SemitransparentCube.png"></p>
<p>为了达到正确的渲染效果，首先我们需要告诉Unity：我们打算渲染一个透明物体。因此，我们可以将<code>SubShader</code>块中的<code>Tags</code>块的渲染类型改为<code>Transparent</code>，以及将其中的渲染队列改为<code>Transparent</code>。渲染队列的设置是为了保证我们的半透明物体一定是在不透明物体之后渲染。如果不这么设置，根据上面说到的不透明渲染的方法，很可能有不透明物体直接覆盖在半透明物体区域，即便我们的半透明物体在不透明物体的前方。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Transparent&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们要定义混合模式，前面提到需要将半透明的像素颜色和已经渲染的像素颜色相混合，就是通过这个混合模式来决定的。混合模式的定义由两个关键字构成，第一个和半透明颜色相乘，第二个和已有的颜色相乘，然后两者相加。</p>
<p>当我们渲染不透明物体时，我们将第一个参数设为1，第二个参数设为0，这样新的颜色值便会完全替换掉原先的颜色值。而在透明材质中，我们通常使用新颜色的透明通道作为第一个参数，而第二个参数为1减该透明通道值，这样我们就可以调整其透明通道来实现不同程度的透明效果。</p>
<p>混合模式可以定义在<code>SubShader</code>块中，也可以定义在<code>Pass</code>块中，位置的不同决定其作用域的大小。但是必须定义在<code>hlsl</code>代码以外，因为这属于<code>Shaderlab</code>拓展的特性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blend SrcAlpha OneMinusSrcAlpha</span><br></pre></td></tr></table></figure>

<p>你可以从下面网址找到更全面的混合模式设置介绍：<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/SL-Blend.html">https://docs.unity3d.com/Manual/SL-Blend.html</a></p>
<p>为了突出重点，精简逻辑，这里举两个小例子：</p>
<ul>
<li>当我们的片段着色器返回的透明通道值为<code>0.5</code>，那么根据前面设置的混合模式，将会将新的颜色值得一半和旧的颜色值得一一半进行混合。如果新颜色是白色，旧颜色是黑色，那么混合后的将是灰色；</li>
<li>当我们的片段着色器返回的透明通道值为<code>0.9</code>，那么混合后，新颜色将占有90%的比例，而旧颜色只占有%10；</li>
</ul>
<p>因此，在前面不透明着色器脚本的基础上，做以上调整，该着色器就成功变成一个半透明着色器。因为公共变量<code>_Color</code>参与了片段着色器中的颜色计算，所以我们在材质面板修改其透明度，将会影响最终的混合效果。如下：<br><img src="https://www.ronja-tutorials.com/assets/images/posts/006/AdjustTint.gif"></p>
<p>另一个需要修改的地方是关闭透明着色器的深度写入功能。一般来说，当模型被渲染到画面上是，其距离摄像机的深度信息会被记录到一张深度纹理是上。然后后面渲染的模型只需要与这张深度图相比较，就可以正确判断其相互之间的遮挡关系，其中被遮挡的部分将不会渲染到画面上。但是这并不适用于半透明物体，因为即便被遮挡也会被渲染。所以我们只能从其渲染队列方面考虑，将半透明物体限定在不透明物体之后渲染，并且半透明物体之间的渲染排序是由远及近。深度值写入的设置如下，和混合模式设置一样，都可以定义在<code>SubShader</code>或<code>Pass</code>块中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">ZWrite Off</span><br></pre></td></tr></table></figure>

<p>如果我们的纹理贴图也存在半透明通道，那么最终渲染出来的效果将是各个部位的透明程度有差异。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/006/TextureTransparentCube.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/006_Basic_Transparency&quot;</span>&#123;</span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Transparent&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">		ZWrite off</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">			fixed4 _Color;</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">				fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">				col *= _Color;</span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以在一下链接找到源码：<a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/006_Transparency/transparent.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/006_Transparency/transparent.shader</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/06/25/Ronja_Structure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/06/25/Ronja_Structure/" class="post-title-link" itemprop="url">Structure of Shader</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-25 11:01:00" itemprop="dateCreated datePublished" datetime="2021-06-25T11:01:00+08:00">2021-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-01 22:00:42" itemprop="dateModified" datetime="2021-07-01T22:00:42+08:00">2021-07-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/001-structure/">Structure</a></p>
<h2 id="Shader-Structure"><a href="#Shader-Structure" class="headerlink" title="Shader Structure"></a>Shader Structure</h2><p>着色器编程难度较大，在学习初期阶段，我们首先需要学习它的基本结构，以便于后面灵活的修改、应用它们。</p>
<p>现代着色器采用的是可变渲染管线，其中顶点着色器、和片段着色器是其基本组成。除此之外，还有可选部分，几何着色器、曲面细分着色器，但是它们的应用场景比较少。顶点着色器的作用是将模型网格，通过矩阵变换，投影到屏幕(实际是投影到裁剪空间)。同时，顶点着色器的一个非常有用的操作是，执行顶点动画。当顶点坐标变换到屏幕空间后，其所构成的三角面片将被栅格化。为了保证三角面片能够正确显示，从顶点着色器到片段着色器的过程中，需要对顶点进行插值，从而得到三角面片中各个片段的位置、颜色值等。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/001/pipeline.png"></p>
<p>上面简单介绍了着色器的基本流程。接下来我将阐述如何编写着色器、这些“空间坐标系”的具体含义、不同着色器之间的数据传递。但是，我相信了解其基本流程，有助于我们对着色器不同阶段之间的关系有一个直观的理解。因为，在大多数着色器语言中，基本采用了这种基本流程。即便是那些更为高级的、可以通过节点拼接的着色器语言，最终也是将其翻译为这种基本流程。</p>
<h2 id="ShaderLab"><a href="#ShaderLab" class="headerlink" title="ShaderLab"></a>ShaderLab</h2><p>在Unity中，着色器实际上就是一个以<code>.shader</code>结尾的文本文件。我们可以在资源面板下，依次选择<code>Create &gt; Shader &gt;</code>中的着色器模板，当然模板中的内容可能并不是我们想要的，不过没关系，下面我将介绍如何自定义着色器。为了易于上手，这里我以模板着色器<code>Create &gt; Shader &gt; Unlit</code>为参考，编写我们自己的着色器。当然这里我写的和<code>Unlit</code>之间最大的区别在于，我们这个是不会处理雾效，同时又增加了一个颜色属性，这样可以从整体对模型颜色进行调整。接下来我也会一步一步的讲解其实现逻辑。本教程目标是着色器小白，所以你如果有哪里不理解的地方，可以告诉我，促使我对其进行调整，以便于后续学习者能够更加顺畅。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/001-004_Basic_Unlit&quot;</span>&#123;</span><br><span class="line">	<span class="comment">//这些值将会显示在材质面板上</span></span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		<span class="comment">//当前的标签设置表示的是：不透明渲染，和其他不透明物体处以同一渲染队列</span></span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="comment">//这里包括一些工具函数、以及内置变量</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//定义顶点、片段着色函数</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//材质所用的纹理、以及缩放偏移量</span></span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//材质的颜色，具体一点是：当纹理为白色图片时，材质的颜色</span></span><br><span class="line">			fixed4 _Color;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//模型网格、UI等输入数据，基本代表了模型内在属性</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//当经过顶点着色器处理后，处理的数据经过栅格化插值，然后传入片段着色器</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//顶点着色器函数，主要执行坐标的空间变换</span></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				<span class="comment">//将模型各顶点坐标，转换到裁剪空间</span></span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				<span class="comment">//基于图片的缩放偏移参数，对UV进行变换</span></span><br><span class="line">				o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//片段作色器，主要是计算像素点的颜色</span></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">			    <span class="comment">//基于UV坐标，进行纹理采样</span></span><br><span class="line">				fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">				<span class="comment">//将纹理颜色和材质颜色相乘</span></span><br><span class="line">				col *= _Color;</span><br><span class="line">				<span class="comment">//返回最终的像素点颜色</span></span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Fallback <span class="string">&quot;VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Whats-ShaderLab"><a href="#Whats-ShaderLab" class="headerlink" title="Whats ShaderLab?"></a>Whats ShaderLab?</h2><p><code>Shaderlab</code>是Unity内置的着色器语言，其中定义了绝大多数渲染模型所需的数据。但是着色器执行渲染逻辑的部分，实际上是采用<code>hlsl</code>、<code>glsl</code>、<code>CG</code>这三种着色语言中的一种。这里<code>hlsl</code>是微软开发的底层着色器语言，<code>glsl</code>是英伟达开发的底层着色器语言，<code>CG</code>是更为高级的作色器语言。而这些执行部分在<code>Shaderlab</code>中占有一个独立的区域。具体一点，<code>Shaderlab</code>是在执行<code>hlsl</code>、<code>glsl</code>、<code>CG</code>的基础上，扩展了一些属于自身的语法，其中包括<code>Properties</code>属性块，用来关联外部输入参数。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/002/LanguageAreas.png"></p>
<p>从上图可以看到，实际<code>ShaderLab</code>扩展的仅占着色器很小区域。其中一部分原因是：<code>Shaderlab</code>不是可执行语言，而是一种抽象的描述性语言，定义了着色器有哪些输入参数、需要执行哪些渲染操作。而Unity便会识别这些描述性语言，然后将其翻译为GPU可执行的作色器语言，同时关联渲染所需的数据。对于一些简单的渲染需求，参考上图的例子，然后对<code>CG</code>部分进行简单的调整就行了。</p>
<h2 id="Shader-SubShader-Pass"><a href="#Shader-SubShader-Pass" class="headerlink" title="Shader/SubShader/Pass"></a>Shader/SubShader/Pass</h2><p>在上图中，你可能也发现了，其中有很多个<code>&#123;&#125;</code>花括号，将程序分为很多个块。下面我们来看看，这些块到底是干嘛的。</p>
<p>首先，最外层的<code>Shader</code>块，代表了整个作色器。在我们创建材质球后，需要在材质球面板上选择所需的着色器，从而得到我们所需的材质球。那些在材质面板上的着色器名称，实际上就是紧跟在<code>Shader</code>块后面的字符串。在这个字符串中，我们可以使用<code>/</code>反斜杠来对着色器进行有效的组织分类，这很像我们文件目录的组织形式。在本教程中，我将所有的着色器划分到<code>Tutorial</code>这个大类中，其中还会细分出一些小类。当然，这些分类可以根据需要随意改动，只要达到有效组织的目的就行。<br>可以看到，所谓的着色器，实际上也就是一连串描述的文本文件。需要注意的是，一个文本文件，只能定义一个着色器。但是，一个着色器却可以复用另一个着色器的功能。例如，在<code>Shader</code>块中，也就是最外层花括号中，我们可以定义<code>fallback shader</code>，当Unity将其翻译为更底层的着色器代码时，会将<code>fallback shader</code>中的<code>SubShader</code>块复制过来。</p>
<p>在<code>Shader</code>块中，可以定义多个<code>SubShader</code>块。在模型渲染时，只会从中选择一个<code>SubShader</code>来执行，而具体选择哪个，依赖于实际运行的平台。可惜的是，关于如何定义<code>SubShader</code>的说明文档极其匮乏，根据我多年的经验，在很多情况下，一个<code>Shader</code>块中只定义一个<code>SubShader</code>能满足基本需求，减少很多不必要的麻烦。凡事皆有特例，当我们想实现阴影效果时，需要在当前<code>SubShader</code>块中实现相应的<code>ShadowPass</code>，每次都实现一遍很麻烦。因为阴影着色流程基本固定，所以Unity提供的现成的便可以使用，这时候，我们可以使用包含阴影着色逻辑的<code>fallback shader</code>，当渲染时，从该<code>SubShader</code>中未找到可以使用的<code>ShadowPadd</code>时，便会从<code>fallback shader</code>中去查找。大多数情况下，我们使用<code>VertexLit</code>着色器，来作为我们的<code>fallback shader</code>，因为<code>VertexLit</code>中的逻辑简单、性能消耗低、基本上能够兼容所有的显卡，也可能是大家相互Copy，从而形成<code>VertexLit</code>流行的假象:-)。另外，在<code>SubShader</code>块中，我们可以定义<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/SL-SubShaderTags.html">Subshader tags</a>；还可以定义多个<code>Pass</code>，例如前面说的<code>Shadow pass</code>；以及属性，在<code>SubShader</code>块中定义的属性是由所有<code>Pass</code>共享的。</p>
<p>一个<code>Pass</code>包含一套完整的渲染流程，从底层着色语言的角度来看，一个<code>Pass</code>才是实际上的着色器，它将模型数据转换为五彩斑斓的画面。在内置渲染管线中，如果我们在<code>SubShader</code>块中定义了多个<code>Pass</code>，当该<code>SubShader</code>被平台选定时，其中的<code>Pass</code>将会被一个接着一个的执行(而最新的URP渲染管线，目前仅支持单个光照<code>Pass</code>)。对于具有多个<code>Pass</code>的<code>SubShader</code>，我们可以将其公共属性等数据定义在<code>SubShader</code>中，而<code>Pass</code>中定义一些独有的数据或逻辑。</p>
<h2 id="Properties-and-Tags"><a href="#Properties-and-Tags" class="headerlink" title="Properties and Tags"></a>Properties and Tags</h2><p>你们可能注意到，在上图中还有两个块<code>Properties</code>、<code>Tags</code>未被提及，那我们继续吧。</p>
<p>在很多编程语言中有字典的概念，顾名思义，就是类似汉语字典一样，可以通过拼音、笔画等关键信息进行快速检索。这里的<code>Tags</code>就可以类比到字典，在<code>Tags</code>中可以定义多个关键字，以及关键字所对应的值，它们公共构成了着色器的配置参数。其中关键字表示了参数的类型，值表示了参数的实际设置。在<code>SubShader</code>中，可以通过<code>Tags</code>定义着色器的材质表现、渲染顺序、以及其他操作；而<code>Pass</code>中的<code>Tags</code>主要定义了光照模式。详细的说明可以参考<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/SL-SubShaderTags.html">SubShader Tags</a>和<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/SL-PassTags.html">Pass Tags</a>。</p>
<p><code>Properties</code>属性块，主要用来定义材质面板中的属性显示。通过材质面板来调整材质参数具有一定的局限性，因为整个调整是以材质球为单位，也就是说，如果多个模型使用同一个材质球，那么就无法做到材质差异化。这时候需要创建多个材质球，分别对应于不同的模型。在接下来得教程中我也会详细讨论<code>Properties</code>的使用。</p>
<p>下面我们对<code>Shaderlab</code>的基本结构进行一个总结：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Category/Name&quot;</span>&#123;</span><br><span class="line">	Properties&#123;</span><br><span class="line">		<span class="comment">//用于材质面板显示、与配置的属性</span></span><br><span class="line">	&#125;</span><br><span class="line">	Subshader&#123;</span><br><span class="line">		Tags&#123;</span><br><span class="line">			<span class="comment">//一些公共配置，涉及渲染类型、渲染顺序等设置</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//公共设置、属性、方法可以写在Subshader中</span></span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			Tags&#123;</span><br><span class="line">				<span class="comment">//主要是光照模式的配置</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//单个Pass的设置， 例如剔除、模板等</span></span><br><span class="line"></span><br><span class="line">			CGPROGRAM</span><br><span class="line">			<span class="comment">//实际执行的渲染程序、以及所用到的属性参数</span></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p>所有的教程都有配套源码，可以在教程结尾找到相关链接。因为目前我只是做了一些简单的分析介绍，所有源码在上面已经出现过了，这里直接简单的整理一下。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/001-004_basic_unlit/basic_unlit.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/001-004_basic_unlit/basic_unlit.shader</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/001-004_Basic_Unlit&quot;</span>&#123;</span><br><span class="line">	<span class="comment">//这些值将会显示在材质面板上</span></span><br><span class="line">	Properties&#123;</span><br><span class="line"><span class="comment">//	_Color (&quot;Tint&quot;, Color) = (0, 0, 0, 1)</span></span><br><span class="line"><span class="comment">//	_MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		<span class="comment">//当前的标签设置表示的是：不透明渲染，和其他不透明物体处以同一渲染队列</span></span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//		//这里包括一些工具函数、以及内置变量</span></span><br><span class="line"><span class="comment">//		#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//		//定义顶点、片段着色函数</span></span><br><span class="line"><span class="comment">//		#pragma vertex vert</span></span><br><span class="line"><span class="comment">//		#pragma fragment frag</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//		//材质所用的纹理、以及缩放偏移量</span></span><br><span class="line"><span class="comment">//		sampler2D _MainTex;</span></span><br><span class="line"><span class="comment">//		float4 _MainTex_ST;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//		//材质的颜色，具体一点是：当纹理为白色图片时，材质的颜色</span></span><br><span class="line"><span class="comment">//		fixed4 _Color;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//		//模型网格、UI等输入数据，基本代表了模型内在属性</span></span><br><span class="line"><span class="comment">//		struct appdata&#123;</span></span><br><span class="line"><span class="comment">//			float4 vertex : POSITION;</span></span><br><span class="line"><span class="comment">//			float2 uv : TEXCOORD0;</span></span><br><span class="line"><span class="comment">//		&#125;;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//		//当经过顶点着色器处理后，处理的数据经过栅格化插值，然后传入片段着色器</span></span><br><span class="line"><span class="comment">//		struct v2f&#123;</span></span><br><span class="line"><span class="comment">//			float4 position : SV_POSITION;</span></span><br><span class="line"><span class="comment">//			float2 uv : TEXCOORD0;</span></span><br><span class="line"><span class="comment">//		&#125;;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//		//顶点着色器函数，主要执行坐标的空间变换</span></span><br><span class="line"><span class="comment">//		v2f vert(appdata v)&#123;</span></span><br><span class="line"><span class="comment">//			v2f o;</span></span><br><span class="line"><span class="comment">//			//将模型各顶点坐标，转换到裁剪空间</span></span><br><span class="line"><span class="comment">//			o.position = UnityObjectToClipPos(v.vertex);</span></span><br><span class="line"><span class="comment">//			//基于图片的缩放偏移参数，对UV进行变换</span></span><br><span class="line"><span class="comment">//			o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span></span><br><span class="line"><span class="comment">//			return o;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//		//片段作色器，主要是计算像素点的颜色</span></span><br><span class="line"><span class="comment">//		fixed4 frag(v2f i) : SV_TARGET&#123;</span></span><br><span class="line"><span class="comment">//			//基于UV坐标，进行纹理采样</span></span><br><span class="line"><span class="comment">//			fixed4 col = tex2D(_MainTex, i.uv);</span></span><br><span class="line"><span class="comment">//			//将纹理颜色和材质颜色相乘</span></span><br><span class="line"><span class="comment">//			col *= _Color;</span></span><br><span class="line"><span class="comment">//			//返回最终的像素点颜色</span></span><br><span class="line"><span class="comment">//			return col;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Fallback <span class="string">&quot;VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/06/23/GOAP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/06/23/GOAP/" class="post-title-link" itemprop="url">GOAP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-23 15:01:00" itemprop="dateCreated datePublished" datetime="2021-06-23T15:01:00+08:00">2021-06-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-01 22:00:42" itemprop="dateModified" datetime="2021-07-01T22:00:42+08:00">2021-07-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/AI/" itemprop="url" rel="index"><span itemprop="name">AI</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/AI/GOAP/" itemprop="url" rel="index"><span itemprop="name">GOAP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>GOAP是以目标为导向的行为规划。其思路是对行为进行拆分，同时描述每个行为发生的前置条件，以及相应会产生的结果。然后将条件、结果、目标统一视为状态集合，那么只需要关心这三类状态集之间的关系，然后进行有效的拼接组合，其相应的行为之间的关系也就明了了。</p>
<h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>首先，整个世界就是一个状态集，每个行为可以对部分状态产生影响，正向或反向。而有些行为可能需满足特定状态下才坑能发生。<br>那么，以什么样的顺序执行哪些行为，才能达到相应的状态，实现特定的目标呢？</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>上面的问题表明，我们需要求出一组有序的行为组合。而行为之所以有序，是因为行为之间有一定的相互依赖关系，例如只有伐木、做家具、卖家具，这三者是前后依赖关系。伐木可以得到木材，得到木材就是伐木的结果；做家具需要木材，得到木材就是做家具的条件；做家具得到家具，家具就是做家具的结果；买家具需要有家具，所以有家具是卖家具的条件。<br>假设我想卖家具，此时卖家具是我的目标，然后我从这三个行为里面查找，发现第三个行为刚好满足我的目标，但是从卖家具这个行为来看，我们首先得有家具，如果刚好有，那么完美。如果没有，那么有家具就是我们的新目标，然后根据这个新目标，我们查找到第二个行为刚好可以满足。至此我们得到做家具、卖家具这条行为组合，但是还没完，我们还需要判断做家具的条件是否满足，如果不满足，则需要继续查找它的上一个行为。<br>上面这个卖家具的问题简单的阐述了GOAP的一个从目标出发的、不断迭代的一个逆向查找解决方案的思路。但是，在实际应用中，遇到的问题可能会更复杂，状态会更多，同时状态之间的关联也不是一对一的。这时候我们就需要把握GOAP的一些关键信息，将其抽取出来。</p>
<h2 id="泛化"><a href="#泛化" class="headerlink" title="泛化"></a>泛化</h2><p>为了将问题泛化，我们假设目标可以划分为多个状态的组合，而每个行为会对部分状态产生影响。这时候如何应用目标导向的思路呢？<br>首先我们也是找到最接近目标的行为。然后判断这个行为的条件是否满足，如果不满足，则将其条件也纳入目标中，形成一个新的目标。同时，对于该行为已经达成的状态，则从新目标中剔除。然后继续查找最接近新目标的行为，依此类推，不断迭代，直到新目标中的状态为空时。<br>这里提到最接近目标的行为。什么事最接近目标的行为呢？<br>以我想打扫卫生为例，环境状态为：我是否饥饿、地是否干净、桌子是否干净、是否有水、是否有生活垃圾；而我可以执行的行为有：吃饭、扫地、抹桌子、把水倒掉、把生活垃圾倒在地上。那么我的目标就是：地干净、桌子干净。<br>1、该行为的结果一定会对目标的状态集产生影响，即便不能立即达成目标，也能完成部分状态。如果没有这种正向的影响，说明这个行为和目标无关。如这里的吃饭；<br>2、该行为的结果不能对目标的状态集产生消极的影响。如把垃圾倒在地上，很明显倒完之后还得清理，所以对于打扫卫生来说并不是最接近目标的一步。<br>3、在执行该行为后，不能立即达到当前目标，也就是该行为的结果不能覆盖目标状态，这时候该行为的条件不能和目标状态相冲突。例如扫地和抹桌子都只能完成部分清理，假设我们选抹桌子为最后的行为，其条件为空，和目标状态冲突。如果说抹桌子的条件是地必须是脏的，这时候和目标状态地是干净的相冲突，在抹完桌子后肯定还得扫地，所以抹桌子不可以作为左后行为。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>假设世界有一系列状态组成，同时有一系列可选行为，这些行为分别有各自的状态前置条件、以及执行后能产生的状态影响。<br>那么我们需要达成某一目标时，首先分离出目标中的状态集。然后基于这个状态集，查找最近行为，在查找到最近行为后，将最近行为所达成的状态从目标状态集中剔除，然后将最近行为中未达成的前置条件纳入到新的目标状态集中。然后基于新的目标状态集进行新一轮的最近行为筛选，依此类推，直到新的目标状态为空时，说明我们筛选出的行为组合和目标状态已经形成了一个闭环。而我们的行为组合是从最后一个开始，倒序筛查的，所以需要进行颠倒才能得到正常的行为执行顺序。<br>而最近行为的标准，需要满足：</p>
<ul>
<li>能都达成部分目标</li>
<li>其行为结果和目标没有冲突，不会对已经达成的目标产生破坏</li>
<li>其前置条件和目标没有冲突，如果有冲突，其行为结果能够修复这种冲突</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/06/21/Compute_Shader/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/06/21/Compute_Shader/" class="post-title-link" itemprop="url">Compute Shader</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-21 15:01:00" itemprop="dateCreated datePublished" datetime="2021-06-21T15:01:00+08:00">2021-06-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-01 22:00:42" itemprop="dateModified" datetime="2021-07-01T22:00:42+08:00">2021-07-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/050-compute-shader/">Compute Shader</a></p>
<p>至此，我们已经学会了如何使用固定管线来渲染纹理，但是目前的显卡能做的远远不止这些。除了使用固定管线，我们还可以使用compute shader来实现。</p>
<p>你可能会问，为什么要用compute shader，目前的cpu其实已经很强大了，即便遇到大量的处理数据，我们也可以使用多线程来处理。是的，对于一些非图形任务，我们并不需要使用GPU。如果强行使用GPU来处理，很可能会产生各种未知错误，另外也无法使用常用的异常分析手段。优化就更麻烦了，因为需要考虑CPU与GPU之间的数据传输，而GPU并行处理也和CPU编程思路不一样。作为初学者，我们是否需要使用compute shader，首先要明白为什么要用compute shader，使用后是否能够达到比现有方法更好的效果。</p>
<p>如果你觉得你需要使用compute shader，那么继续读下去。在Unity中，你可以使用<code>SystemInfo.supportsComputeShaders</code>方法来查看你的GPU是否支持compute shader。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/050/result.gif"></p>
<h2 id="Basic-Compute-Shader"><a href="#Basic-Compute-Shader" class="headerlink" title="Basic Compute Shader"></a>Basic Compute Shader</h2><p>我们可以通过选中<code>Create&gt;Shader&gt;Compute Shader</code>来创建compute shader。默认创建的compute shader执行向图片中写入数据的操作。但是在本节，我将演示一个更简单的例子——写入一组坐标。</p>
<p>在compute shader中，我们可以向<code>RWStructuredBuffer</code>中写入一组数据，而<code>StructuredBuffer</code>是只读数据。在它们后面补充数据单元类型，类型包括<code>vector</code>或者<code>struct</code>。在本节中，我们使用<code>float3</code>。</p>
<p>我们把用于计算的方法块叫做<code>kernel</code>。我们必须在方法块前面添加<code>numthreads</code>标志符，同时方法块有一个输入参数，因为方法块是针对每一个元素进行并行计算的，所以需要一个索引值来表明当前方法块所对应的元素。在这里，我们定义x轴64线程，y、z轴都是1线程。只要支持compute shader的显卡，基本可以处理这种线程设置。因为整个线程设置是一维的，所以我们处理的数据也是一维的，而在并行处理中，我们只需要考虑单个元素的处理过程。因为我们的线程设置是基于三个维度，所以我们输入参数也是三个维度，参数中的值对应相应维度的线程。因为我们这里的数据都集中在x轴上，所以我们的参数也只需要考虑x轴的索引。和普通的Shader一样，我们需要为输入参数添加标志符，方便程序识别参数的语意，这里我们参数的标志符是<code>SV_DispatchThreadID</code>。</p>
<p>为了区分compute shader中的普通方法块和核方法块，我们需要使用<code>pragma</code>标识符，语法为<code>#pragma kernel &lt;functionname&gt;</code>。当然，在一个compute shader中可以拥有多个核函数。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定一个核函数，我们可以拥有多个核函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> kernel Spheres</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">RWStructuredBuffer&lt;float3&gt; Result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[numthreads(<span class="number">64</span>, <span class="number">1</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Spheres</span><span class="params">(uint3 id : SV_DispatchThreadID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// compute shader 代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，让我们输出坐标<code>(id, 0, 0)</code>到<code>Result</code>中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[numthreads(<span class="number">64</span>, <span class="number">1</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Spheres</span><span class="params">(uint3 id : SV_DispathcThreadID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Result[id.x] = float3(id.x, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Executing-Compute-Shaders"><a href="#Executing-Compute-Shaders" class="headerlink" title="Executing Compute Shaders"></a>Executing Compute Shaders</h2><p>和普通的Shader不同的是，compute shader并不是通过材质绑定的方式来执行，而是通过<code>C#</code>脚本来实现调用。</p>
<p>我们可以创建一个GameObject，并且在它上面创建一个<code>C#</code>脚本，在脚本上创建一个<code>ComputeShader</code>变量来引用前面创建的compute shader。同时我们创建一个整形变量，用来存储核函数的签名，这个签名是核函数在GPU中的索引ID。首先在<code>Start</code>函数中我们调用<code>FindKernel(&lt;kernelname&gt;)</code>来获取核函数的签名。在得到核函数签名后，我们可以使用该签名来获取该核函数的线程设置，也就是在compute shader中的<code>[numthreads(64, 1, 1)]</code>。我们只提取x轴的线程数，其他两个维度可以用<code>_</code>来表示忽略。</p>
<p>另外，我们在<code>C#</code>脚本中创建一个长度变量，用来指定compute shader中buffer的长度。知道buffer的长度，以及buffer中存储的数据类型<code>float3</code>，我们可以向GPU申请一块存储空间——<code>ComputeBuffer</code>。这个空间将会用来存储计算结果，也就是compute shader中的<code>Result</code>。创建<code>ComputeBuffer</code>需要两个参数，第一参数是元素的个数，第二个参数是元素的大小。我们的元素是<code>float3</code>，也就是大小为3个<code>float</code>。另外，我们需要在CPU中申请一块和<code>ComputeBuffer</code>同样大小的数组空间，以便于将计算后的结果转移到CPU，方便后续计算使用。在计算结束后，我们可以通过<code>ComputeBuffer.Dispose</code>方法来释放GPU申请的缓存空间。</p>
<p>当一切设置好后，我们可以在<code>Update</code>中使用compute shader。首先，我们需要将我们在GPU创建的<code>ComputeBuffer</code>和compute shader中的buffer相关联。在调用compute shader之前，我们还需要计算整个核函数需要执行多少遍，这个叫做线程组。因为核函数单次批处理的数量有限，所以需要分为多组，分批次处理。例如这里我们单次x轴处理量为64，而总的需要处理的数量为buffer长度，那么线程组的个数为后者处以前者。然后通过<code>dispatch</code>方法来启用核函数，最终计算结果通过<code>GetData</code>函数传回到CPU中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicComputeSpheres</span> :</span> MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> SphereAmount = <span class="number">17</span>;</span><br><span class="line">    <span class="keyword">public</span> ComputeShader Shader;</span><br><span class="line"></span><br><span class="line">    ComputeBuffer resultBuffer;</span><br><span class="line">    <span class="keyword">int</span> kernel;</span><br><span class="line">    uint threadGroupSize;</span><br><span class="line">    Vector3[] output;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 获取核函数签名</span></span><br><span class="line">        kernel = Shader.FindKernel(<span class="string">&quot;Spheres&quot;</span>);</span><br><span class="line">		<span class="comment">// 获取核函数线程设置</span></span><br><span class="line">        Shader.GetKernelThreadGroupSizes(kernel, out threadGroupSize, out _, out _);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//buffer on the gpu in the ram</span></span><br><span class="line">        resultBuffer = <span class="keyword">new</span> ComputeBuffer(SphereAmount, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * <span class="number">3</span>);</span><br><span class="line">        output = <span class="keyword">new</span> Vector3[SphereAmount];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="comment">//绑定数据</span></span><br><span class="line">        Shader.SetBuffer(kernel, <span class="string">&quot;Result&quot;</span>, resultBuffer);</span><br><span class="line">        <span class="keyword">int</span> threadGroups = (<span class="keyword">int</span>) ((SphereAmount + (threadGroupSize - <span class="number">1</span>)) / threadGroupSize);</span><br><span class="line">        Shader.Dispatch(kernel, threadGroups, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        resultBuffer.GetData(output);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnDestroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        resultBuffer.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们有了计算结果，但是并不能直观的去观察这些结果。有很多种方法可以直接在GPU中处理并显示这些结果，但是这并不是本文的重点。所以我选择使用生成一系列模型空间分布，来展示最终生成的结果。<br>在<code>Update</code>中直接将计算的坐标赋值给游戏物体空间坐标。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in start method</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//spheres we use for visualisation</span></span><br><span class="line">instances = <span class="keyword">new</span> Transform[SphereAmount];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SphereAmount; i++)</span><br><span class="line">&#123;</span><br><span class="line">    instances[i] = Instantiate(Prefab, transform).transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//in update method</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; instances.Length; i++)</span><br><span class="line">    instances[i].localPosition = output[i];</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/050/Row.png"></p>
<h2 id="A-tiny-bit-more-complex-Compute-Shader"><a href="#A-tiny-bit-more-complex-Compute-Shader" class="headerlink" title="A tiny bit more complex Compute Shader"></a>A tiny bit more complex Compute Shader</h2><p>为了达到一个更好的视觉效果，请继续阅读，别担心这里涉及到的也只是基本的hlsl语法。</p>
<p>在compute shader中我加入了<a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/024-white-noise/">randomness</a>教程中关于噪声的函数，同时加入时间变量。在核函数中，我基于输入参数来构造一个长度为[0.1-1]的随机向量。然后采用叉乘的方法计算出与这些随机向量垂直的向量。然后使用时间变量的平方，加上一个比较大的奇数，得到一个关于时间的<code>sin</code>值和<code>cos</code>，最后将这两个值和两个随机向量相乘，并求和。在这个基础上乘以20，使得记过看起来更明显。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Each #kernel tells which function to compile; you can have many kernels</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> kernel Spheres</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Random.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//variables</span></span><br><span class="line">RWStructuredBuffer&lt;float3&gt; Result;</span><br><span class="line">uniform <span class="keyword">float</span> Time;</span><br><span class="line"></span><br><span class="line">[numthreads(<span class="number">64</span>,<span class="number">1</span>,<span class="number">1</span>)]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Spheres</span> <span class="params">(uint3 id : SV_DispatchThreadID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//generate 2 orthogonal vectors</span></span><br><span class="line">    float3 baseDir = normalize(rand1dTo3d(id.x) - <span class="number">0.5</span>) * (rand1dTo1d(id.x)*<span class="number">0.9</span>+<span class="number">0.1</span>);</span><br><span class="line">    float3 orthogonal = normalize(cross(baseDir, rand1dTo3d(id.x + <span class="number">7.1393</span>) - <span class="number">0.5</span>)) * (rand1dTo1d(id.x+<span class="number">3.7443</span>)*<span class="number">0.9</span>+<span class="number">0.1</span>);</span><br><span class="line">    <span class="comment">//scale the time and give it a random offset</span></span><br><span class="line">    <span class="keyword">float</span> scaledTime = Time * <span class="number">2</span> + rand1dTo1d(id.x) * <span class="number">712.131234</span>;</span><br><span class="line">    <span class="comment">//calculate a vector based on vectors</span></span><br><span class="line">    float3 dir = baseDir * <span class="built_in">sin</span>(scaledTime) + orthogonal * <span class="built_in">cos</span>(scaledTime);</span><br><span class="line">    Result[id.x] = dir * <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，我们很需要在<code>C#</code>脚本中向compute shader中传入时间变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shader.SetFloat(<span class="string">&quot;Time&quot;</span>, Time.time);</span><br></pre></td></tr></table></figure>

<p>然后使用自发光材质，以及泛光后处理技术，最后呈现出下面绚烂的效果。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/050/result.gif"></p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/050_Compute_Shader/BasicCompute.compute">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/050_Compute_Shader/BasicCompute.compute</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Each #kernel tells which function to compile; you can have many kernels</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> kernel Spheres</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Random.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//variables</span></span><br><span class="line">RWStructuredBuffer&lt;float3&gt; Result;</span><br><span class="line">uniform <span class="keyword">float</span> Time;</span><br><span class="line"></span><br><span class="line">[numthreads(<span class="number">64</span>,<span class="number">1</span>,<span class="number">1</span>)]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Spheres</span> <span class="params">(uint3 id : SV_DispatchThreadID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//generate 2 orthogonal vectors</span></span><br><span class="line">    float3 baseDir = normalize(rand1dTo3d(id.x) - <span class="number">0.5</span>) * (rand1dTo1d(id.x)*<span class="number">0.9</span>+<span class="number">0.1</span>);</span><br><span class="line">    float3 orthogonal = normalize(cross(baseDir, rand1dTo3d(id.x + <span class="number">7.1393</span>) - <span class="number">0.5</span>)) * (rand1dTo1d(id.x+<span class="number">3.7443</span>)*<span class="number">0.9</span>+<span class="number">0.1</span>);</span><br><span class="line">    <span class="comment">//scale the time and give it a random offset</span></span><br><span class="line">    <span class="keyword">float</span> scaledTime = Time * <span class="number">2</span> + rand1dTo1d(id.x) * <span class="number">712.131234</span>;</span><br><span class="line">    <span class="comment">//calculate a vector based on vectors</span></span><br><span class="line">    float3 dir = baseDir * <span class="built_in">sin</span>(scaledTime) + orthogonal * <span class="built_in">cos</span>(scaledTime);</span><br><span class="line">    Result[id.x] = dir * <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/050_Compute_Shader/BasicComputeSpheres.cs">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/050_Compute_Shader/BasicComputeSpheres.cs</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicComputeSpheres</span> :</span> MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> SphereAmount = <span class="number">17</span>;</span><br><span class="line">    <span class="keyword">public</span> ComputeShader Shader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> GameObject Prefab;</span><br><span class="line"></span><br><span class="line">    ComputeBuffer resultBuffer;</span><br><span class="line">    <span class="keyword">int</span> kernel;</span><br><span class="line">    uint threadGroupSize;</span><br><span class="line">    Vector3[] output;</span><br><span class="line"></span><br><span class="line">    Transform[] instances;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//program we&#x27;re executing</span></span><br><span class="line">        kernel = Shader.FindKernel(<span class="string">&quot;Spheres&quot;</span>);</span><br><span class="line">        Shader.GetKernelThreadGroupSizes(kernel, out threadGroupSize, out _, out _);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//buffer on the gpu in the ram</span></span><br><span class="line">        resultBuffer = <span class="keyword">new</span> ComputeBuffer(SphereAmount, <span class="keyword">sizeof</span>(<span class="keyword">float</span>) * <span class="number">3</span>);</span><br><span class="line">        output = <span class="keyword">new</span> Vector3[SphereAmount];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//spheres we use for visualisation</span></span><br><span class="line">        instances = <span class="keyword">new</span> Transform[SphereAmount];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SphereAmount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            instances[i] = Instantiate(Prefab, transform).transform;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Shader.SetFloat(<span class="string">&quot;Time&quot;</span>, Time.time);</span><br><span class="line">        Shader.SetBuffer(kernel, <span class="string">&quot;Result&quot;</span>, resultBuffer);</span><br><span class="line">        <span class="keyword">int</span> threadGroups = (<span class="keyword">int</span>) ((SphereAmount + (threadGroupSize - <span class="number">1</span>)) / threadGroupSize);</span><br><span class="line">        Shader.Dispatch(kernel, threadGroups, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        resultBuffer.GetData(output);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; instances.Length; i++)</span><br><span class="line">            instances[i].localPosition = output[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnDestroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        resultBuffer.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>希望你能喜欢这个教程 :-)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/06/19/Func2Solve/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/06/19/Func2Solve/" class="post-title-link" itemprop="url">二次函数解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-19 15:01:00" itemprop="dateCreated datePublished" datetime="2021-06-19T15:01:00+08:00">2021-06-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-01 22:00:42" itemprop="dateModified" datetime="2021-07-01T22:00:42+08:00">2021-07-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Math/" itemprop="url" rel="index"><span itemprop="name">Math</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Math/Function/" itemprop="url" rel="index"><span itemprop="name">Function</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如下如所示，已知A、B两点坐标，以及二次函数顶点的y坐标，求解二次函数的方程式：<br><img src="/blogs/images/src/func.jpg"></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先，假设二次函数方程为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a * x * x + b * x + c &#x3D; y   ------------- 1 </span><br></pre></td></tr></table></figure>
<p>同时假设，A、B、P三个点的坐标分别为<code>(x1, y1)</code>、<code>(x2, y2)</code>、<code>(x3, y3)</code>，其中<code>x3</code>未知。<br>因为A、B、P三个点都在函数曲线上，所以三个点都满足方程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a * x1 * x1 + b * x1 + c &#x3D; y1   ------------- 2</span><br><span class="line">a * x2 * x2 + b * x2 + c &#x3D; y2   ------------- 3</span><br><span class="line">a * x3 * x3 + b * x3 + c &#x3D; y3   ------------- 4</span><br></pre></td></tr></table></figure>
<p>将上面的式子2减去式3得到<code>式子5</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a * (x1 * x1 - x2 * x2)+ b * (x1 – x2) &#x3D; y1 – y2   ------------- 5</span><br></pre></td></tr></table></figure>
<p><code>式子5</code>中消去参数c，只有a、b两个参数。将b用a表示，得：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b &#x3D; ((y1 – y2) – a * (x1 * x1 – x2 * x2))&#x2F;(x1 – x2) </span><br><span class="line"> &#x3D; (y1 – y2)&#x2F;(x1 – x2) – a * (x1 * x1 – x2 * x2)&#x2F;(x1 – x2) ------------- 6</span><br></pre></td></tr></table></figure>
<p>又因为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x1 * x1 – x2 * x2 &#x3D; (x1 + x2) * (x1 – x2) ------------- 7</span><br></pre></td></tr></table></figure>
<p>所以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b &#x3D; (y1 – y2)&#x2F;(x1 – x2) – a * (x1 + x2) ------------- 8</span><br></pre></td></tr></table></figure>
<p>令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m &#x3D; (y1 – y2) &#x2F; (x1 – x2)</span><br><span class="line">n &#x3D; x1 + x2</span><br></pre></td></tr></table></figure>
<p>所以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b &#x3D; m – a * n------------- 9</span><br></pre></td></tr></table></figure>
<p>因为二次函数的顶点坐标为(-b/(2a), (4ac-b*b)/(4a))，这一点可以查百度。因此：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x3 &#x3D; -b&#x2F;(2a) ------------- 10</span><br><span class="line">y3 &#x3D; (4ac – b*b)&#x2F;(4a)</span><br></pre></td></tr></table></figure>
<p>所以：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c &#x3D; y3 + b * b &#x2F;(4 a)------------- 11</span><br></pre></td></tr></table></figure>

<p>=================================分段线=======================<br>将<code>式9、10</code>代入<code>式2</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y1 – y3 &#x3D; a * x1 * x1 + (m – a * n) + (m –a * n) *(m –a * n)&#x2F;(4a)</span><br></pre></td></tr></table></figure>
<p>化简得：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(4 * x1 * x1 – 4 * n * x1 + n * n) * a * a </span><br><span class="line">   + (4 * m * x1 – 2 * m * n – 4 * (y1 – y3)) * a</span><br><span class="line">     + m * m &#x3D; 0--------------12</span><br></pre></td></tr></table></figure>
<p><code>式子12</code>是关于a的二次方程<br>假设：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A1 &#x3D; 4 * x1 * x1 – 4 * n * x1 + n * n</span><br><span class="line">B1 &#x3D; 4 * m * x1 – 2 * m * n – 4 * (y1 – y3)</span><br><span class="line">C1 &#x3D; m * m</span><br></pre></td></tr></table></figure>
<p>那么<code>式12</code>可以写成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A1 * a * a + B1 * b + C1 &#x3D; 0--------------13</span><br></pre></td></tr></table></figure>
<p>二次方程的有两个根：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a1 &#x3D; -(B1 + sqrt(4A1C1 – B1 * B1))&#x2F;(2* A1)</span><br><span class="line">a2 &#x3D; -(B1 - sqrt(4A1C1 – B1 * B1))&#x2F;(2* A1)</span><br></pre></td></tr></table></figure>
<p>这里可以取a1、a2中的任意一个作为a的值<br>根据式8可以计算b<br>根据式11可以计算c<br>根据式10可以计算x3<br>从上面分段线开始，是基于<code>式2</code>计算所有的参数，也就是基于点<code>(x1, y1)</code>，我们也可以基于<code>式3</code>进行计算，也就是基于点<code>(x2,y2)</code>，但是计算出的结果都是一致的</p>
<h2 id="实现源码"><a href="#实现源码" class="headerlink" title="实现源码"></a>实现源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        float x1 &#x3D; 1.3245f;</span><br><span class="line">        float y1 &#x3D; 0.342f;</span><br><span class="line">        float x2 &#x3D; 11.24f;</span><br><span class="line">        float y2 &#x3D; 6.324f;</span><br><span class="line">        float y3 &#x3D; -8.213f;</span><br><span class="line">        if(Solve(x1, y1, x2, y2, y3, out var x3, out var a, out var b, out var c))</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(string.Format(&quot;&#123;0&#125; &#x3D;&#x3D; &#123;1&#125;&quot;, y1, func(a, b, c, x1)));</span><br><span class="line">            Debug.LogError(string.Format(&quot;&#123;0&#125; &#x3D;&#x3D; &#123;1&#125;&quot;, y2, func(a, b, c, x2)));</span><br><span class="line">            Debug.LogError(string.Format(&quot;&#123;0&#125; &#x3D;&#x3D; &#123;1&#125;&quot;, y3, func(a, b, c, x3)));</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.LogError(&quot;error&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    float func(float a, float b, float c, float x)</span><br><span class="line">    &#123;</span><br><span class="line">        return a * x * x + b * x + c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; a * x * x + b * x + c &#x3D; y</span><br><span class="line">    bool Solve(float x1, float y1, float x2, float y2, float y3, out float x3, out float a, out float b, out float c)</span><br><span class="line">    &#123;</span><br><span class="line">        float eps &#x3D; 0.00001f;</span><br><span class="line">        bool rst &#x3D; true;</span><br><span class="line">        float m, n;</span><br><span class="line">        m &#x3D; (y1 - y2) &#x2F; (x1 - x2);</span><br><span class="line">        n &#x3D; x1 + x2;</span><br><span class="line"></span><br><span class="line">        float A1, B1, C1;</span><br><span class="line">        A1 &#x3D; 4 * x1 * x1 - 4 * n * x1 + n * n;</span><br><span class="line">        B1 &#x3D; 4 * m * x1 - 2 * m * n - 4 * (y1 - y3);</span><br><span class="line">        C1 &#x3D; m * m;</span><br><span class="line"></span><br><span class="line">        float A2, B2, C2;</span><br><span class="line">        A2 &#x3D; 4 * x2 * x2 - 4 * n * x2 + n * n;</span><br><span class="line">        B2 &#x3D; 4 * m * x2 - 2 * m * n - 4 * (y2 - y3);</span><br><span class="line">        C2 &#x3D; m * m;</span><br><span class="line"></span><br><span class="line">        float a1_1, a1_2;</span><br><span class="line">        a1_1 &#x3D; -(B1 + Mathf.Sqrt(B1 * B1 - 4 * A1 * C1)) &#x2F; (2 * A1);</span><br><span class="line">        a1_2 &#x3D; -(B1 - Mathf.Sqrt(B1 * B1 - 4 * A1 * C1)) &#x2F; (2 * A1);</span><br><span class="line">        float a2_1, a2_2;</span><br><span class="line">        a2_1 &#x3D; -(B2 + Mathf.Sqrt(B2 * B2 - 4 * A2 * C2)) &#x2F; (2 * A2);</span><br><span class="line">        a2_2 &#x3D; -(B2 - Mathf.Sqrt(B2 * B2 - 4 * A2 * C2)) &#x2F; (2 * A2);</span><br><span class="line"></span><br><span class="line">        if (Mathf.Abs(a1_1 - a2_1)&lt; eps)</span><br><span class="line">        &#123;</span><br><span class="line">            a &#x3D; a1_1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (Mathf.Abs(a1_2 - a2_2) &lt; eps)</span><br><span class="line">        &#123;</span><br><span class="line">            a &#x3D; a1_2;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            a &#x3D; 1;</span><br><span class="line">            rst &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">        b &#x3D; m - a * n;</span><br><span class="line">        c &#x3D; y3 + b * b &#x2F; (4 * a);</span><br><span class="line">        x3 &#x3D; - b &#x2F; (2 * a);</span><br><span class="line">        return rst;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/06/16/Are-Behavior-Trees-a-Thing-of-the-Past/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/06/16/Are-Behavior-Trees-a-Thing-of-the-Past/" class="post-title-link" itemprop="url">Are Behavior Trees a Thing of the Past?</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-16 15:01:00" itemprop="dateCreated datePublished" datetime="2021-06-16T15:01:00+08:00">2021-06-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-01 22:00:42" itemprop="dateModified" datetime="2021-07-01T22:00:42+08:00">2021-07-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/%E7%BF%BB%E8%AF%91/" itemprop="url" rel="index"><span itemprop="name">翻译</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/%E7%BF%BB%E8%AF%91/%E8%A1%8C%E4%B8%BA%E6%A0%91/" itemprop="url" rel="index"><span itemprop="name">行为树</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.gamasutra.com/blogs/JakobRasmussen/20160427/271188/Are_Behavior_Trees_a_Thing_of_the_Past.php">Are Behavior Trees a Thing of the Past?</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>基于游戏沉浸感、以及和NPC智能交互的需求，游戏开发者在游戏中使用的AI技术成为了新的焦点。曾经在游戏中普遍使用，也是游戏中AI决策的主要方案的行为树，已经显得乏力。当游戏开发者希望实现更为复杂的AI行为时，例如处理突发情况，行为树已经无法满足。因此，更为先进的AI技术——Utility AI，已经逐步取代行为树的位置，开始在游戏中展现出更为优越的AI性能，开启一个新的游戏AI时代。</p>
<h2 id="行为树是如何屹立游戏AI界（以及它的衰落）"><a href="#行为树是如何屹立游戏AI界（以及它的衰落）" class="headerlink" title="行为树是如何屹立游戏AI界（以及它的衰落）"></a>行为树是如何屹立游戏AI界（以及它的衰落）</h2><p>大多数AI开发者都知道有限状态机（FSM）是一种简单且实用AI方法。通过简单地定义状态、以及状态之间切换的条件，然后可以基于决策实现无限循环的AI行为。例如，FSM将持续保持某种状态，直到满足某种条件，才会从一种状态切换到另一种状态。</p>
<p>任何两个状态之间都可以在特定条件下实现切换，很容易设计FSM来实现AI行为。但是，有利也有弊。在一些大型游戏中，构建FSM需要上百个状态，这么多的状态导致异常分析变的非常困难。Damian Isla在2005 GDC论坛中针对Halo 2的AI系统，详细的指出了这一点。<br><img src="https://gamasutra.com/db_area/images/blog/apexgametools05.png"></p>
<p>为了解决这些问题，FSM进一步演化出层级结构，使得它易于设计和异常分析。分层结构使得FSM能够更好的处理大量的状态，但是并没有从根本上解决这个问题，当状态数量进一步增加时，FSM依然会变得难以管理。<br><img src="https://gamasutra.com/db_area/images/blog/apexgametools011.png"></p>
<p>最终，在这种层级组织的思想上，进一步演化出任务组织的树状结构——行为树。和状态机一样，行为树也是由多个状态节点组成，同一时刻只占据一种状态。不同的是，状态机中，任意两个状态之间的跳转都需要单独配置跳转条件，而行为树则是将这些跳转条件进行拆分，这些拆分后的最小条件单元称为条件装饰器。状态机中的跳转仅仅是对当前状态中的条件进行判断，如果满足条件则跳转，而行为树是从根节点开始，定时进行条件遍历，每经过一个装饰器，会进行次条件判断，然后选择不同的状态分支，以此类推。如果最终筛选出的状态和当前状态不同，那么执行状态跳转。因此，行为树解决了FSM中存在的很多问题，例如，FSM中可能发生条件满足却没有跳转的情况，或者其他跳转异常。在Unreal引擎中就实现了一套非常不错的行为树机制。<br><img src="https://gamasutra.com/db_area/images/blog/271188/image02.png"></p>
<p>相较于层级FSM，行为树能够实现更为复杂、同时容易理解的AI系统。并且这种树结构也便于实现可视化的异常分析。<br><img src="https://gamasutra.com/db_area/images/blog/271188/apexgametools00.png"></p>
<p>然而，行为树也有很多缺陷。很多人试图通过实现各种扩展来消除这些缺陷。</p>
<p>当行为树状态数量变得庞大时，每次条件遍历都需要花费大量的时间。因此，有人引入了子树方案，就是将整个行为树分割为多个嵌套的子树，每次条件遍历只需要遍历当前状态所处的子树就可以，这样可以减少遍历数量，只有满足特定条件，才能跳出子树。但是子树的存在，导致行为树在控制、异常处理方便，变得和FSM一样复杂。</p>
<h2 id="顶级的AI需要满足什么条件"><a href="#顶级的AI需要满足什么条件" class="headerlink" title="顶级的AI需要满足什么条件"></a>顶级的AI需要满足什么条件</h2><p>这需要我们重新回顾一下顶级AI的特性。</p>
<p>顶级AI需要具备更为复杂的、更深层次的、沉浸式的游戏世界的处理能力。例如在《Hitman》、《Witcher》、《Assassin’s Creed》中，NPC的数量、定制化数量、生活化的行为数量都变得越来越多。在《Call of Duty》、《The Division》中，对手的数量、以及深度的要求，可变且复杂的策略行为爆炸式的增长。静态的、脚本化的游戏设计不再适用，需要支持动态的、甚至可演化的场景来满足当下的游戏设计。</p>
<p>这依赖于易于设计的、具有复杂行为表达能力的AI机制。例如，这样的AI能够提高突发处理能力，能够应对游戏设计者未曾预料的场景，能够像人类一样表达更为复杂的行为模式。</p>
<p>以上提到AI技术显然无法处理更为庞大的数据输入。AI设计者不可能使用行为树、或状态机来表示所有可能的情况。更别说设计一套保证AI正常使用的测试用例。因此，我们需要一种更好、且更稳定的AI技术。</p>
<p>处理复杂的行为可能是AI中主要的挑战。在游戏开发中的，有很多问题是由于数据量增加、而AI处理能力不足导致的。</p>
<p>1、 技术性遗留问题 - 如果在游戏开发过程中，扩展AI的难度很大，那么后面需要修复的问题、以及所花费的时间将会暴增。<br>2、 生产效率 - 如果不能快速实现满足游戏设计方案的AI系统，那么游戏设计者无法快速原型化其思路。最终结果是游戏缺乏内容，或者内容偏向程序化、没有趣味性。<br>3、 质量 - 最终很多游戏只能放弃、或者最终只是实现无聊的智障游戏。</p>
<h2 id="一个新的AI范例"><a href="#一个新的AI范例" class="headerlink" title="一个新的AI范例"></a>一个新的AI范例</h2><p>Killzone 2 就具有非常棒的AI设计。Guerilla 游戏使用了一个AI公共系统来实现动态决策，并且展示了如何使用简单的打分系统来实现AI决策，即便是在对游戏世界不了解的情况下，该AI决策系统也能达到一个良好的效果。同样的系统已经使用在其他游戏，例如《文明》。</p>
<p>这种公共系统实现方式是，识别可选项，然后基于当前状态，对每一种选项进行打分，然后选出评分最高的选项最为决策项。这种方案具有很多优势：<br>1、设计简单 -<br>2、易于扩展 -<br>3、质量高 - </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blogs/page/2/">2</a><a class="page-number" href="/blogs/page/3/">3</a><a class="extend next" rel="next" href="/blogs/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Tyson Wu"
      src="/blogs/images/avatar.png">
  <p class="site-author-name" itemprop="name">Tyson Wu</p>
  <div class="site-description" itemprop="description">If you want, Just do it!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blogs/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blogs/categories/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blogs/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Tyson-Wu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Tyson-Wu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/zhao-wu-zhu-43" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;zhao-wu-zhu-43" rel="noopener" target="_blank"><i class="知乎 fa-fw"></i>知乎</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/Hi-blog/" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;Hi-blog&#x2F;" rel="noopener" target="_blank">starnight_cyber</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tyson Wu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blogs/lib/anime.min.js"></script>
  <script src="/blogs/lib/velocity/velocity.min.js"></script>
  <script src="/blogs/lib/velocity/velocity.ui.min.js"></script>

<script src="/blogs/js/utils.js"></script>

<script src="/blogs/js/motion.js"></script>


<script src="/blogs/js/schemes/pisces.js"></script>


<script src="/blogs/js/next-boot.js"></script>




  















  

  

</body>
</html>
