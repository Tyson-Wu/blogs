<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blogs/images/girl_180_0.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blogs/images/girl_32_0.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blogs/images/girl_16_0.png">
  <link rel="mask-icon" href="/blogs/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blogs/css/main.css">


<link rel="stylesheet" href="/blogs/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"tyson-wu.github.io","root":"/blogs/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="If you want, Just do it!">
<meta property="og:type" content="website">
<meta property="og:title" content="TysonWu&#39;s Blog">
<meta property="og:url" content="https://tyson-wu.github.io/blogs/page/4/index.html">
<meta property="og:site_name" content="TysonWu&#39;s Blog">
<meta property="og:description" content="If you want, Just do it!">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Tyson Wu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://tyson-wu.github.io/blogs/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>TysonWu's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blogs/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">TysonWu's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">AiCooXiao</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blogs/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blogs/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blogs/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blogs/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blogs/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/06/Ronja_Postprocessing_with_the_Depth_Texture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/06/Ronja_Postprocessing_with_the_Depth_Texture/" class="post-title-link" itemprop="url">Postprocessing with the Depth Texture</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-06 15:01:00" itemprop="dateCreated datePublished" datetime="2021-07-06T15:01:00+08:00">2021-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-20 23:50:31" itemprop="dateModified" datetime="2022-09-20T23:50:31+08:00">2022-09-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/017-postprocessing-depth/">Postprocessing with the Depth Texture</a></p>
<p>在上一篇教程中，我介绍了简单后处理效果的实现过程。但是在实际应用中，我们经常需要使用深度图来实现一些更高级的后处理效果。深度图是从摄像机视角采集的记录场景深度信息的纹理图。</p>
<p>在理解如何借助深度图来实现复杂的后处理之前，建议你先阅读<a href="https://tyson-wu.github.io/blogs/2021/07/06/Ronja_Postprocessing_Basics/">上一篇</a>关于简单后处理效果的介绍。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/017/Result.gif"></p>
<h2 id="Read-Depth"><a href="#Read-Depth" class="headerlink" title="Read Depth"></a>Read Depth</h2><p>这里我们沿用<a href="https://tyson-wu.github.io/blogs/2021/07/06/Ronja_Postprocessing_Basics/">上一篇</a>中实现的最简单的后处理脚本，然后在此基础上进行修改。</p>
<p>首先我们需要对后处理脚本进行扩展，保证后处理摄像机生成深度图，供这里的后处理使用。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Camera cam = GetComponent&lt;Camera&gt;();</span><br><span class="line">    cam.depthTextureMode = cam.depthTextureMode | DepthTextureMode.Depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面对后处理脚本修改完成后，接下来我们要对后处理着色器进行修改。</p>
<p>为了在着色器中访问深度图，我们首先需要定义一个名叫<code>_CameraDepthTexture</code>的纹理，这个名字是Unity内置的。深度图的采样和其他纹理一样，我们可以将采样结果渲染到屏幕上，看看深度图到底长啥样。因为深度图只有一个值有效，所以在纹理中深度值是存储在R通道，我们可以直接进行访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深度图</span></span><br><span class="line">sampler2D _CameraDepthTexture;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//深度采样</span></span><br><span class="line">    <span class="keyword">float</span> depth = tex2D(_CameraDepthTexture, i.uv).r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一切都准备好后，启动游戏，不过这时候屏幕上显示的很可能是一片黑。这是因为深度值得存储位数有限，为了扩大深度值得记录范围，同时保证近景的深度精度，所以采用非线性编码，其中距离摄像机越近的区域深度值得精度越高，反之越低。当你将摄像机靠近物体时，你可能观察到更亮的颜色，这表明这个区域理摄像机很近。如果你将摄像机不断靠近，画面依然很黑，这时候你可以尝试将摄像机的近平面调大一点。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/017/Short.png"></p>
<p>前面的深度编码是考虑到存储的限制，而我们使用深度值之前必须对其进行解码。庆幸的是，Unity为我们提供了解码函数，解码后的深度值是线性的，范围在0-1之间，0表示在摄像机位置，1表示在远平面上。如果解码后的深度图显示除了天空盒区域是白色，其他地方基本是黑色，你可以将远平面调小，这样可以观察到更多的模型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//深度采样</span></span><br><span class="line">    <span class="keyword">float</span> depth = tex2D(_CameraDepthTexture, i.uv).r;</span><br><span class="line">    <span class="comment">//深度解码，解码后的深度值是线性的，范围0-1， 0为摄像机位置，1为远平面上</span></span><br><span class="line">    depth = Linear01Depth(depth);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/017/LinearDepth.png"></p>
<p>接下来的一步是基于摄像机参数，还原真实的深度值。这里有个<code>_ProjectionParams</code>是记录摄像机的投影参数，其中z值是远平面的大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//深度采样</span></span><br><span class="line">    <span class="keyword">float</span> depth = tex2D(_CameraDepthTexture, i.uv).r;</span><br><span class="line">    <span class="comment">//深度值解码</span></span><br><span class="line">    depth = Linear01Depth(depth);</span><br><span class="line">    <span class="comment">//还原深度值，得到点到摄像机的真实距离</span></span><br><span class="line">    depth = depth * _ProjectionParams.z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/017/CorrectDepth.png"></p>
<p>因为场景中绝大多数的模型到摄像机的距离都大于一个单位，所以还原后的深度图显示在屏幕上将会是纯白色，但是这个深度值是与远平面无关的真实深度值，是点到摄像机的距离。</p>
<h2 id="Generate-Wave"><a href="#Generate-Wave" class="headerlink" title="Generate Wave"></a>Generate Wave</h2><p>加下来我将基于这些信息来实现一种波效果，一种不断从玩家开始，向远处传播的效果。同时我们可以自定义某个时刻波距玩家的距离、以及波的拖尾长度、波的颜色。所以首先我们需要在着色器脚本中添加这些变量。这里我们使用<code>Header</code>属性标签来加粗标题，当然这只具有显示功能，不会影响着色器的实际使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在编辑器上显示的属性</span></span><br><span class="line">Properties&#123;</span><br><span class="line">    [HideInInspector]_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    [Header(Wave)]</span><br><span class="line">    _WaveDistance (<span class="string">&quot;Distance from player&quot;</span>, <span class="keyword">float</span>) = <span class="number">10</span></span><br><span class="line">    _WaveTrail (<span class="string">&quot;Length of the trail&quot;</span>, Range(<span class="number">0</span>,<span class="number">5</span>)) = <span class="number">1</span></span><br><span class="line">    _WaveColor (<span class="string">&quot;Color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HLSL 内定义的变量</span></span><br><span class="line"><span class="keyword">float</span> _WaveDistance;</span><br><span class="line"><span class="keyword">float</span> _WaveTrail;</span><br><span class="line">float4 _WaveColor;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/017/Inspector.png"></p>
<p>我们这个波的一头是突然截断、另一头是渐变的拖尾效果。我们首先实现这个突然截断的头部效果。在前面的教程中谈到过<code>step</code>这个函数可以实现跳变的效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//计算波的头部</span></span><br><span class="line"><span class="keyword">float</span> waveFront = step(depth, _WaveDistance);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> waveFront;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/017/Cutoff.gif"></p>
<p>然后我们再使用<code>smoothstep</code>函数来实现尾部渐变效果，这个函数和<code>step</code>函数类似，只不过它有三个参数。如果第三个参数小于第一个参，那么返回0，如果大于第二个参数，那么返回1，其他情况返回一个0-1的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> waveTrail = smoothstep(_WaveDistance - _WaveTrail, _WaveDistance, depth);</span><br><span class="line"><span class="keyword">return</span> waveTrail;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/017/Trail.gif"></p>
<p>你可能注意到上面两个波效果刚好相反，这正是我们想要的效果。因为我们将这两个波值相乘后，只有中间很窄的区域会为1，其他位置都将是0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算前后波</span></span><br><span class="line"><span class="keyword">float</span> waveFront = step(depth, _WaveDistance);</span><br><span class="line"><span class="keyword">float</span> waveTrail = smoothstep(_WaveDistance - _WaveTrail, _WaveDistance, depth);</span><br><span class="line"><span class="keyword">float</span> wave = waveFront * waveTrail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wave;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/017/WhiteWave.gif"></p>
<p>现在我们得到了想要的波，打算将其应用到最终的显示画面上。首先需要采集原始画面，然后和我们的波进行线性插值，插值的时候可以把我们的波颜色也应用上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和原图混合</span></span><br><span class="line">fixed4 col = lerp(source, _WaveColor, wave);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> col;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/017/HitSky.gif"></p>
<p>上面的效果可以发现一些瑕疵，就是当波移动到远平面时，会突然高亮。虽然我们的天空盒就是在远平面处，但是我还是不想出现这种瑕疵。</p>
<p>要解决这个问题，我通过判断深度值是否达到远平面，如果达到，那么直接返回原始图。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//深度采样</span></span><br><span class="line">    <span class="keyword">float</span> depth = tex2D(_CameraDepthTexture, i.uv).r;</span><br><span class="line">    <span class="comment">//深度解码</span></span><br><span class="line">    depth = Linear01Depth(depth);</span><br><span class="line">    <span class="comment">//还原深度值</span></span><br><span class="line">    depth = depth * _ProjectionParams.z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原图采样</span></span><br><span class="line">    fixed4 source = tex2D(_MainTex, i.uv);</span><br><span class="line">    <span class="comment">//当达到远平面时，直接返回原图</span></span><br><span class="line">    <span class="keyword">if</span>(depth &gt;= _ProjectionParams.z)</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算波</span></span><br><span class="line">    <span class="keyword">float</span> waveFront = step(depth, _WaveDistance);</span><br><span class="line">    <span class="keyword">float</span> waveTrail = smoothstep(_WaveDistance - _WaveTrail, _WaveDistance, depth);</span><br><span class="line">    <span class="keyword">float</span> wave = waveFront * waveTrail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//波和原图混合</span></span><br><span class="line">    fixed4 col = lerp(source, _WaveColor, wave);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我想扩展后处理脚本来实现自动设置波位置，并且让它缓慢远离摄像机。我想控制波速以及是否启用波后处理效果。所以我必须记住当前波的位置。下面是我添加的新变量。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="keyword">private</span> Material postprocessMaterial;</span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> waveSpeed;</span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> waveActive;</span><br></pre></td></tr></table></figure>

<p>然后我在后处理脚本中的<code>Update</code>函数中不断刷新波的位置。关闭波效将会重置波的位置，开启波效，波都会冲初始位置开始，慢慢的原理摄像机。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//启用时会不断移动波，关闭时会重置波的位置</span></span><br><span class="line">    <span class="keyword">if</span>(waveActive)&#123;</span><br><span class="line">        waveDistance = waveDistance + waveSpeed * Time.deltaTime;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        waveDistance = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我在<code>OnRenderImage</code>函数中的后处理操作执行之前，将波距离参数传递给着色器，保证每次渲染都是在正确的位置。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/017/AutoWave.gif"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/017_Depth_Postprocessing&quot;</span>&#123;</span><br><span class="line">    <span class="comment">//显示在编辑器上</span></span><br><span class="line">    Properties&#123;</span><br><span class="line">        [HideInInspector]_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        [Header(Wave)]</span><br><span class="line">        _WaveDistance (<span class="string">&quot;Distance from player&quot;</span>, <span class="keyword">float</span>) = <span class="number">10</span></span><br><span class="line">        _WaveTrail (<span class="string">&quot;Length of the trail&quot;</span>, Range(<span class="number">0</span>,<span class="number">5</span>)) = <span class="number">1</span></span><br><span class="line">        _WaveColor (<span class="string">&quot;Color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader&#123;</span><br><span class="line">        <span class="comment">// 关闭剔除</span></span><br><span class="line">        <span class="comment">// 禁用深度缓存功能</span></span><br><span class="line">        Cull Off</span><br><span class="line">        ZWrite Off</span><br><span class="line">        ZTest Always</span><br><span class="line"></span><br><span class="line">        Pass&#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="comment">//引入内置函数和变量</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//声明顶点、片段着色器</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//用于后处理的原图</span></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//深度图</span></span><br><span class="line">            sampler2D _CameraDepthTexture;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//波参数</span></span><br><span class="line">            <span class="keyword">float</span> _WaveDistance;</span><br><span class="line">            <span class="keyword">float</span> _WaveTrail;</span><br><span class="line">            float4 _WaveColor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//模型网格数据</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//中间插值数据</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">                float4 position : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//顶点着色器</span></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">//计算裁剪坐标</span></span><br><span class="line">                o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.uv;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//片段着色器，后处理操作主要是在这里执行</span></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">                <span class="comment">//深度采样</span></span><br><span class="line">                <span class="keyword">float</span> depth = tex2D(_CameraDepthTexture, i.uv).r;</span><br><span class="line">                <span class="comment">//深度解码</span></span><br><span class="line">                depth = Linear01Depth(depth);</span><br><span class="line">                <span class="comment">//深度还原</span></span><br><span class="line">                depth = depth * _ProjectionParams.z;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//原图采样</span></span><br><span class="line">                fixed4 source = tex2D(_MainTex, i.uv);</span><br><span class="line">                <span class="comment">//当达到远平面时，直接返回原图</span></span><br><span class="line">                <span class="keyword">if</span>(depth &gt;= _ProjectionParams.z)</span><br><span class="line">                    <span class="keyword">return</span> source;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//计算波</span></span><br><span class="line">                <span class="keyword">float</span> waveFront = step(depth, _WaveDistance);</span><br><span class="line">                <span class="keyword">float</span> waveTrail = smoothstep(_WaveDistance - _WaveTrail, _WaveDistance, depth);</span><br><span class="line">                <span class="keyword">float</span> wave = waveFront * waveTrail;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//原图与波混合</span></span><br><span class="line">                fixed4 col = lerp(source, _WaveColor, wave);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该脚本需要和摄像机绑定在同一物体</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DepthPostprocessing</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="comment">//用于后处理的材质</span></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> Material postprocessMaterial;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> waveSpeed;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> waveActive;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> waveDistance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//设置当前摄像机为深度采集模式</span></span><br><span class="line">        Camera cam = GetComponent&lt;Camera&gt;();</span><br><span class="line">        cam.depthTextureMode = cam.depthTextureMode | DepthTextureMode.Depth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//启用时会不断移动波，关闭时会重置波的位置</span></span><br><span class="line">        <span class="keyword">if</span>(waveActive)&#123;</span><br><span class="line">            waveDistance = waveDistance + waveSpeed * Time.deltaTime;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            waveDistance = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当当前绑定的摄像机渲染完一帧画面后，会调用该函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture source, RenderTexture destination</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//同步当前波距到着色器</span></span><br><span class="line">        postprocessMaterial.SetFloat(<span class="string">&quot;_WaveDistance&quot;</span>, waveDistance);</span><br><span class="line">		<span class="comment">//将原图按照材质着色器脚本逻辑，写入到结果图</span></span><br><span class="line">        Graphics.Blit(source, destination, postprocessMaterial);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望我的教程能够对你有所帮助。</p>
<p>你可以在以下链接找到源码：<br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/017_DepthPostprocessing/DepthPostprocessing.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/017_DepthPostprocessing/DepthPostprocessing.shader</a><br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/017_DepthPostprocessing/DepthPostprocessing.cs">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/017_DepthPostprocessing/DepthPostprocessing.cs</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/06/Ronja_Postprocessing_Basics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/06/Ronja_Postprocessing_Basics/" class="post-title-link" itemprop="url">Postprocessing Basics</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-06 14:01:00" itemprop="dateCreated datePublished" datetime="2021-07-06T14:01:00+08:00">2021-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-20 23:50:31" itemprop="dateModified" datetime="2022-09-20T23:50:31+08:00">2022-09-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/016-postprocessing-basics/">Postprocessing Basics</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>目前为止，我将所有我实现的着色器应用到了模型上，并将其渲染到屏幕上。着色器还有一个常用的用途就是处理图片、以及我们刚渲染好的上一帧画面。我们对前面渲染好的画面进行处理的操作就叫做后处理。</p>
<p>后处理所使用的着色器在语法和结构上和之间介绍的着色器一样。所以我建议你先了解前面关于着色器的<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Basic_Shader/">基础教程</a>。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/016/Result.jpg"></p>
<h2 id="Postprocessing-Shader"><a href="#Postprocessing-Shader" class="headerlink" title="Postprocessing Shader"></a>Postprocessing Shader</h2><p>作为后处理的入门教程，这里我将展示如何实现简单的颜色取反效果。</p>
<p>因为整个脚本和其他着色器类似，所以我将直接使用<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Basic_Shader/">着色器基础</a>教程中的着色器脚本，并在此基础上进行修改。</p>
<p>当然，即便是最基础的着色器也有一些后处理用不到的变量，我们可以将它删除。例如这里的材质颜色、渲染标签<code>Tags</code>、纹理参数。</p>
<p>然后我们还需要添加一些东西，使得我们的着色器更适用于后处理。例如在后处理中所有的属性变量都是通过脚本赋值的，所以在属性块中可以加入属性隐藏标签，另外后处理操作不应该对影响场景深度图，所以应该禁用深度写入等功能。</p>
<p>基于上述修改，最终的着色器如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/016_Postprocessing&quot;</span>&#123;</span><br><span class="line">    <span class="comment">//材质面板，这里所有属性都将隐藏</span></span><br><span class="line">    Properties&#123;</span><br><span class="line">        [HideInInspector]_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader&#123;</span><br><span class="line">        <span class="comment">// 不需要背面剔除</span></span><br><span class="line">        <span class="comment">// 禁用深度缓存</span></span><br><span class="line">        Cull Off</span><br><span class="line">        ZWrite Off</span><br><span class="line">        ZTest Always</span><br><span class="line"></span><br><span class="line">        Pass&#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="comment">//引入内置函数和变量</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//声明顶点、片段着色器</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//将要进行后处理的图片</span></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//模型纹理数据，后处理会自动生成一个矩阵网格</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//中间插值数据</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">                float4 position : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//顶点着色器</span></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">//变换到裁剪空间，后处理的渲染过程和普通着色器类似</span></span><br><span class="line">                o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.uv;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//片段着色器，后处理主要是在这里执行</span></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">                <span class="comment">//原图片采样</span></span><br><span class="line">                fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Postprocessing-C-Script"><a href="#Postprocessing-C-Script" class="headerlink" title="Postprocessing C# Script"></a>Postprocessing C# Script</h2><p>上面我们已经准备好了用于后处理的着色器，接下来我们要实现C#脚本，来控制后处理过程。摄像机在执行后处理的时候会用到这个脚本。</p>
<p>新建的脚本是一个脚本组件，只有一个函数<code>OnRenderImage</code>。这个函数有Unity在特定时间调用的。其中传递两个参数，一是后处理原图，一是后处理结果图。将一张图中的数据复制到另一张图，可以使用<code>Blit</code>函数。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该脚本需要和摄像机绑定在同一物体</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Postprocessing</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当当前绑定的摄像机渲染完一帧画面后，会调用该函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture source, RenderTexture destination</span>)</span>&#123;</span><br><span class="line">		<span class="comment">//将原图写入到结果图</span></span><br><span class="line">		Graphics.Blit(source, destination);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到目前为止，整个后处理逻辑并不会产生什么特别的效果，因为从原图到结果图没有执行任何操作。我们可以再传第三个材质参数，那么在结果图写入前会执行该材质中的着色器脚本。所以这里我们给这个后处理脚本增加一个材质属性。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该脚本需要和摄像机绑定在同一物体</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Postprocessing</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="comment">//用于后处理的材质</span></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> Material postprocessMaterial;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当当前绑定的摄像机渲染完一帧画面后，会调用该函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture source, RenderTexture destination</span>)</span>&#123;</span><br><span class="line">		<span class="comment">//将原图按照材质着色器脚本逻辑，写入到结果图</span></span><br><span class="line">        Graphics.Blit(source, destination, postprocessMaterial);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前面准备好后，我们创建需要的材质球，然后将该材质球和我们的后处理着色器绑定。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/016/EmptyMaterial.png"></p>
<p>然后将我们的后处理脚本绑定到我们的摄像机物体上，并且将前面的材质球赋值给这个后处理组件。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/016/PostprocessingComponent.png"></p>
<h2 id="Negative-Colors-Effect"><a href="#Negative-Colors-Effect" class="headerlink" title="Negative Colors Effect"></a>Negative Colors Effect</h2><p>做好这一切后，运行程序发现好像没啥特别的变化。要实现颜色取反的效果，我们还需要重新回到我们的后处理着色器中，在片段着色器函数中执行颜色取反的操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//原图采样</span></span><br><span class="line">    fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">    <span class="comment">//颜色取反</span></span><br><span class="line">    col = <span class="number">1</span> - col;</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/016/Result.jpg"></p>
<p>虽然颜色取反并不是我们常用的效果，但是它揭示了后处理的一般流程，为我们打开一个全新的后处理世界。在后面我会陆陆续续介绍其他常用的后处理效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/016_Postprocessing&quot;</span>&#123;</span><br><span class="line">    <span class="comment">//材质面板，这里所有属性都将隐藏</span></span><br><span class="line">    Properties&#123;</span><br><span class="line">        [HideInInspector]_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader&#123;</span><br><span class="line">        <span class="comment">// 不需要背面剔除</span></span><br><span class="line">        <span class="comment">// 禁用深度缓存</span></span><br><span class="line">        Cull Off</span><br><span class="line">        ZWrite Off</span><br><span class="line">        ZTest Always</span><br><span class="line"></span><br><span class="line">        Pass&#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="comment">//引入内置函数和变量</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//声明顶点、片段着色器</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//将要进行后处理的图片</span></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//模型纹理数据，后处理会自动生成一个矩阵网格</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//中间插值数据</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">                float4 position : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//顶点着色器</span></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">//变换到裁剪空间，后处理的渲染过程和普通着色器类似</span></span><br><span class="line">                o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.uv;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//片段着色器，后处理主要是在这里执行</span></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">                <span class="comment">//原图片采样</span></span><br><span class="line">                fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">                <span class="comment">//颜色取反</span></span><br><span class="line">                col = <span class="number">1</span> - col;</span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该脚本需要和摄像机绑定在同一物体</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Postprocessing</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="comment">//用于后处理的材质</span></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> Material postprocessMaterial;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当当前绑定的摄像机渲染完一帧画面后，会调用该函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture source, RenderTexture destination</span>)</span>&#123;</span><br><span class="line">		<span class="comment">//将原图按照材质着色器脚本逻辑，写入到结果图</span></span><br><span class="line">        Graphics.Blit(source, destination, postprocessMaterial);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望本篇教程能够让你了解如何使用简单的后处理效果、能够独立实现一些后处理效果。</p>
<p>你可以在以下链接找到源码：<br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/016_Postprocessing/Postprocessing.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/016_Postprocessing/Postprocessing.shader</a><br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/016_Postprocessing/Postprocessing.cs">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/016_Postprocessing/Postprocessing.cs</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/06/Ronja_Vertex_Displacement/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/06/Ronja_Vertex_Displacement/" class="post-title-link" itemprop="url">Vertex Displacement</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-06 13:01:00" itemprop="dateCreated datePublished" datetime="2021-07-06T13:01:00+08:00">2021-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-20 23:50:31" itemprop="dateModified" datetime="2022-09-20T23:50:31+08:00">2022-09-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/015-wobble-displacement/">Vertex Displacement</a></p>
<p>目前为止，我们使用到最多的就是裁剪坐标系和世界坐标系，其实在顶点着色器中，我们能做的远远不止这些。接下来我将介绍如果将三角函数应用到模型上，从而实现模型抖动效果。</p>
<p>本篇的例子是采用表面着色器，如果你对表面着色器还不了解的话，建议你先从<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Surface_Shader_Basics/">这篇教程</a>看起。当然本篇介绍的思路可以用于到其他着色器上。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/015/Result.gif"></p>
<p>一般我们对顶点坐标的操作都是在顶点着色器中，而我们的表面着色器中似乎并没有顶点着色器函数，实际上表面着色器最终会被翻译为顶点、片段着色器，只不过这些都是由Unity来完成。而在表面着色器中其实还有一个和顶点着色器同名的函数，也是用来处理顶点数据的，只不过定义的时候是和表面着色器一起定义的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表面着色器</span></span><br><span class="line"><span class="comment">//表面着色器函数和标准光照模型</span></span><br><span class="line"><span class="comment">//fullforwardshadows 使用所有的阴影Pass</span></span><br><span class="line"><span class="comment">//vertex:vert 用来处理顶点变换</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> surface surf Standard fullforwardshadows vertex:vert</span></span><br></pre></td></tr></table></figure>

<p>然后我们需要去实现这个顶点处理函数。在无光照的着色器中，我们是在顶点着色器函数中处理裁剪变换。而在表面着色器中，这里的顶点处理函数并不需要处理裁剪变换，因为那些基础部分都由Unity自动生成。这我们只需要处理顶点坐标，然后将处理后的结果传给下一步由Unity自动生成的代码处理。</p>
<p>可以这么说，这里的顶点处理函数是在普通的顶点着色器函数之前执行的，所以顶点处理函数的输入参数也是模型网格数据。这里可以使用Unity提供给我们的<code>appadata_full</code>，也可以自定义。</p>
<p>和表面着色器函数一样，这里的顶点处理函数也不返回任何值，而是通过<code>inout</code>来向外部传递结果。</p>
<p>因为在表面着色器中，所有必要的顶点变换都是由Unity自动生成的，所以定义一个空的顶点处理函数并不会影响原先的表面着色器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vert</span><span class="params">(inout appdata_full data)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较简单的顶点处理就是给所有的顶点乘以一个缩放因子，这样我们就可以控制模型变大变小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void vert(inout appdata_full data)&#123;</span><br><span class="line">    data.vertex.xyz *&#x3D; 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/015/ShadowRealm.png"></p>
<p>虽然模型变大了，但是整个显示却变得不正常了。这里的阴影还是基于原来的为改变的模型顶点来计算的。这是因为表面着色器并不会根据需求自动生成阴影Pass，而依然是复制已有的阴影Pass。为了解决这个问题，我们可以定义<code>addshadow</code>关键字，这样错误的阴影就会消失了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//addshadows 是告诉表面着色器，基于顶点处理函数，重现创建一个阴影Pass</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> surface surf Standard fullforwardshadows vertex:vert addshadow</span></span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/015/FixedShadows.png"></p>
<p>仅仅是缩放模型显得单调了，接下来我们可以实现更有趣的效果。通过计算顶点坐标的x值得三角函数，来改变器y值，从而产生一种波动的效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vert</span><span class="params">(inout appdata_full data)</span></span>&#123;</span><br><span class="line">    data.vertex.y += <span class="built_in">sin</span>(data.vertex.x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/015/QueerMonkey.png"></p>
<p>上面的结果表明当前使用的三角函数波形较大、频率低，因此我们增加两个控制波形的变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">_Amplitude (<span class="string">&quot;Wave Size&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.4</span></span><br><span class="line">_Frequency (<span class="string">&quot;Wave Freqency&quot;</span>, Range(<span class="number">1</span>, <span class="number">8</span>)) = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> _Amplitude;</span><br><span class="line"><span class="keyword">float</span> _Frequency;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vert</span><span class="params">(inout appdata_full data)</span></span>&#123;</span><br><span class="line">float4 modifiedPos = data.vertex;</span><br><span class="line">modifiedPos.y += <span class="built_in">sin</span>(data.vertex.x * _Frequency) * _Amplitude;</span><br><span class="line">data.vertex = modifiedPos;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/015/Sliders.png"><br><img src="https://www.ronja-tutorials.com/assets/images/posts/015/WobblyMonkey.png"></p>
<p>现在我们可以很好地控制我们的模型波形了，但是在顶点处理函数中只处理了顶点坐标，而没有同时处理法向量，因此法向量相对应模型表面来说实际上是不匹配的。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/015/WrongNormalsExplanation.png"></p>
<p>这里最简单且最灵活的计算自定义模型表面法向量的方法是，通过采集模型表面上的点来重新计算法向量。</p>
<p>理论上来说，我们可以采集变形后的局部区域的任意点来计算切平面，进而计算法向量。但是我们需要充分利用已有数据来解析这个切平面。首先对于切向空间我们需要有所了解，在切向空间中，法向量叫<code>normal</code>，切向向量叫<code>tangent</code>，还有一个叫不出名字的<code>bitangent</code>，这三个向量相互垂直，构成切向空间的三个轴。如下图所示，蓝色是法向量，红色是切向量，黄色是<code>bitangent</code>。其中变形前的切向量和法向量都可以从模型网格数据中获取。所以变形前的<code>bitangent</code>可以通过前两者的叉乘来计算。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/015/ShowNormals.png"></p>
<p>在知道变形前的切向向量和<code>bitangent</code>就表示我们知道变形前的切平面，那么计算变形后的切平面我们同样可以先计算变形后的切向量和<code>bitangent</code>。因为这两个向量是沿着模型表面一同变形的，所以可以使用前面的波形函数计算两个向量变形后的方向，然后再通过叉乘来计算变形后的法向量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求解变形后的切向方向临近点的坐标</span></span><br><span class="line">float3 posPlusTangent = data.vertex + data.tangent * <span class="number">0.01</span>;</span><br><span class="line">posPlusTangent.y += <span class="built_in">sin</span>(posPlusTangent.x * _Frequency) * _Amplitude;</span><br><span class="line"><span class="comment">//求解变形后的bitangent方向临近点的坐标</span></span><br><span class="line">float3 bitangent = cross(data.normal, data.tangent);</span><br><span class="line">float3 posPlusBitangent = data.vertex + bitangent * <span class="number">0.01</span>;</span><br><span class="line">posPlusBitangent.y += <span class="built_in">sin</span>(posPlusBitangent.x * _Frequency) * _Amplitude;</span><br></pre></td></tr></table></figure>

<p>上面求解了两个临近点变形后的位置，加上前面计算好的顶点变形后的位置，我们就可以得到变性后的切向平面，然后求切平面的法向量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vert</span><span class="params">(inout appdata_full data)</span></span>&#123;</span><br><span class="line">    <span class="comment">//求解变形后的顶点坐标</span></span><br><span class="line">    float4 modifiedPos = data.vertex;</span><br><span class="line">    modifiedPos.y += <span class="built_in">sin</span>(data.vertex.x * _Frequency) * _Amplitude;</span><br><span class="line">    <span class="comment">//求解变形后的切向方向临近点的坐标</span></span><br><span class="line">    float3 posPlusTangent = data.vertex + data.tangent * <span class="number">0.01</span>;</span><br><span class="line">    posPlusTangent.y += <span class="built_in">sin</span>(posPlusTangent.x * _Frequency) * _Amplitude;</span><br><span class="line">    <span class="comment">//求解变形后的bitangent方向临近点的坐标</span></span><br><span class="line">    float3 bitangent = cross(data.normal, data.tangent);</span><br><span class="line">    float3 posPlusBitangent = data.vertex + bitangent * <span class="number">0.01</span>;</span><br><span class="line">    posPlusBitangent.y += <span class="built_in">sin</span>(posPlusBitangent.x * _Frequency) * _Amplitude;</span><br><span class="line">    <span class="comment">//求解变形后的切平面</span></span><br><span class="line">    float3 modifiedTangent = posPlusTangent - modifiedPos;</span><br><span class="line">    float3 modifiedBitangent = posPlusBitangent - modifiedPos;</span><br><span class="line">    <span class="comment">//求解变形后切平面的法向量，也就是模型变形后的法向量</span></span><br><span class="line">    float3 modifiedNormal = cross(modifiedTangent, modifiedBitangent);</span><br><span class="line">    data.normal = normalize(modifiedNormal);</span><br><span class="line">    data.vertex = modifiedPos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/015/CorrectNormals.png"></p>
<p>最后我希望我们的波形抖动随着时间变化而变化。前面我们只采用了模型顶点坐标的x值作为波形函数的参数，从而得到变形后的坐标，在此基础上引入时间变量是非常简单的。</p>
<p>Unity向着色器中传递的时间变量是一个四维向量，其中第一个元素的值是时间处以20，第二是是时间，第三个是时间成以2，第四个是时间乘以三，这里的时间都是以秒为单位。这里我们选择第二个参数时间来控制波形，另外我们还需要控制波形动画速度的变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">_AnimationSpeed (<span class="string">&quot;Animation Speed&quot;</span>, Range(<span class="number">0</span>,<span class="number">5</span>)) = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> _AnimationSpeed;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vert</span><span class="params">(inout appdata_full data)</span></span>&#123;</span><br><span class="line">    float4 modifiedPos = data.vertex;</span><br><span class="line">    modifiedPos.y += <span class="built_in">sin</span>(data.vertex.x * _Frequency + _Time.y * _AnimationSpeed) * _Amplitude;</span><br><span class="line">    </span><br><span class="line">    float3 posPlusTangent = data.vertex + data.tangent * <span class="number">0.01</span>;</span><br><span class="line">    posPlusTangent.y += <span class="built_in">sin</span>(posPlusTangent.x * _Frequency + _Time.y * _AnimationSpeed) * _Amplitude;</span><br><span class="line"></span><br><span class="line">    float3 bitangent = cross(data.normal, data.tangent);</span><br><span class="line">    float3 posPlusBitangent = data.vertex + bitangent * <span class="number">0.01</span>;</span><br><span class="line">    posPlusBitangent.y += <span class="built_in">sin</span>(posPlusBitangent.x * _Frequency + _Time.y * _AnimationSpeed) * _Amplitude;</span><br><span class="line"></span><br><span class="line">    float3 modifiedTangent = posPlusTangent - modifiedPos;</span><br><span class="line">    float3 modifiedBitangent = posPlusBitangent - modifiedPos;</span><br><span class="line"></span><br><span class="line">    float3 modifiedNormal = cross(modifiedTangent, modifiedBitangent);</span><br><span class="line">    data.normal = normalize(modifiedNormal);</span><br><span class="line">    data.vertex = modifiedPos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/015/Result.gif"></p>
<p>上面计算临近点的时候我们是使用0.01个偏移来是变形更加平滑。这个值越小，其变形变越明显，越大，整个形变越光滑。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/015_vertex_manipulation&quot;</span> &#123;</span><br><span class="line">    <span class="comment">//材质面板</span></span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Smoothness (<span class="string">&quot;Smoothness&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">        _Metallic (<span class="string">&quot;Metalness&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">        [HDR] _Emission (<span class="string">&quot;Emission&quot;</span>, color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        _Amplitude (<span class="string">&quot;Wave Size&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.4</span></span><br><span class="line">        _Frequency (<span class="string">&quot;Wave Freqency&quot;</span>, Range(<span class="number">1</span>, <span class="number">8</span>)) = <span class="number">2</span></span><br><span class="line">        _AnimationSpeed (<span class="string">&quot;Animation Speed&quot;</span>, Range(<span class="number">0</span>,<span class="number">5</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">//不透明物体</span></span><br><span class="line">        Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">        CGPROGRAM</span><br><span class="line"></span><br><span class="line">        <span class="comment">//表面着色器</span></span><br><span class="line">        <span class="comment">//表面着色器函数和标准光照模型</span></span><br><span class="line">        <span class="comment">//fullforwardshadows 使用所有的阴影Pass</span></span><br><span class="line">        <span class="comment">//vertex:vert 用来处理顶点变换</span></span><br><span class="line">        <span class="comment">//addshadows 是告诉表面着色器，基于顶点处理函数，重现创建一个阴影Pass</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> surface surf Standard fullforwardshadows vertex:vert addshadow</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> target 3.0</span></span><br><span class="line"></span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line">        fixed4 _Color;</span><br><span class="line"></span><br><span class="line">        half _Smoothness;</span><br><span class="line">        half _Metallic;</span><br><span class="line">        half3 _Emission;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> _Amplitude;</span><br><span class="line">        <span class="keyword">float</span> _Frequency;</span><br><span class="line">        <span class="keyword">float</span> _AnimationSpeed;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//表面着色器的输入数据</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">            float2 uv_MainTex;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">vert</span><span class="params">(inout appdata_full data)</span></span>&#123;</span><br><span class="line">            float4 modifiedPos = data.vertex;</span><br><span class="line">            modifiedPos.y += <span class="built_in">sin</span>(data.vertex.x * _Frequency + _Time.y * _AnimationSpeed) * _Amplitude;</span><br><span class="line">            </span><br><span class="line">            float3 posPlusTangent = data.vertex + data.tangent * <span class="number">0.01</span>;</span><br><span class="line">            posPlusTangent.y += <span class="built_in">sin</span>(posPlusTangent.x * _Frequency + _Time.y * _AnimationSpeed) * _Amplitude;</span><br><span class="line"></span><br><span class="line">            float3 bitangent = cross(data.normal, data.tangent);</span><br><span class="line">            float3 posPlusBitangent = data.vertex + bitangent * <span class="number">0.01</span>;</span><br><span class="line">            posPlusBitangent.y += <span class="built_in">sin</span>(posPlusBitangent.x * _Frequency + _Time.y * _AnimationSpeed) * _Amplitude;</span><br><span class="line"></span><br><span class="line">            float3 modifiedTangent = posPlusTangent - modifiedPos;</span><br><span class="line">            float3 modifiedBitangent = posPlusBitangent - modifiedPos;</span><br><span class="line"></span><br><span class="line">            float3 modifiedNormal = cross(modifiedTangent, modifiedBitangent);</span><br><span class="line">            data.normal = normalize(modifiedNormal);</span><br><span class="line">            data.vertex = modifiedPos;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//表面着色器函数</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//纹理采样</span></span><br><span class="line">            fixed4 col = tex2D(_MainTex, i.uv_MainTex);</span><br><span class="line">            col *= _Color;</span><br><span class="line">            o.Albedo = col.rgb;</span><br><span class="line">            <span class="comment">//设置标准光照参数</span></span><br><span class="line">            o.Metallic = _Metallic;</span><br><span class="line">            o.Smoothness = _Smoothness;</span><br><span class="line">            o.Emission = _Emission;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Standard&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望本篇能启发你对模型顶点处理的思考，然后创造出美轮美奂的效果。</p>
<p>你可以在以下链接找到源码：<br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/015_VertexManipulation/vertexmanipulation.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/015_VertexManipulation/vertexmanipulation.shader</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/06/Ronja_Polygon_Clipping/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/06/Ronja_Polygon_Clipping/" class="post-title-link" itemprop="url">Polygon Clipping</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-06 12:01:00" itemprop="dateCreated datePublished" datetime="2021-07-06T12:01:00+08:00">2021-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-20 23:50:31" itemprop="dateModified" datetime="2022-09-20T23:50:31+08:00">2022-09-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/014-polygon-clipping/">Polygon Clipping</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>目前为止，我们接触的所有模型渲染都是基于多边形的。有人可能好奇，可不可以通过一系列顶点来实现对多边形的裁剪操作，这也是本文的重点。我将介绍如何在单<code>Pass</code>中的片段着色器函数中实现这个。当然关于裁剪还有其他的实现方案，例如通过将顶点构成的裁剪区域渲染到模板上，然后基于模板进行裁剪操作，但是本文不打算讨论它。</p>
<p>本文主要从技术角度来介绍器基本思路，并不会涉及到复杂的图形效果，所以这里我们以无光照的着色器来实现。关于无光照的着色器介绍可以参考<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Basic_Shader/">这里</a><br><img src="https://www.ronja-tutorials.com/assets/images/posts/014/Result.gif"></p>
<h2 id="Draw-Line"><a href="#Draw-Line" class="headerlink" title="Draw Line"></a>Draw Line</h2><p>首先我们需要顶点的世界坐标，就像前面关于<a href="https://tyson-wu.github.io/blogs/2021/07/02/Ronja_Planar_Mapping/">二维平面映射</a>中介绍的一样，将传入的模型顶点坐标乘以模型矩阵，然后将结果传递给片段着色器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中间插值结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">    float4 position : SV_POSITION;</span><br><span class="line">    float3 worldPos : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点着色器</span></span><br><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    <span class="comment">//计算裁剪坐标</span></span><br><span class="line">    o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    <span class="comment">//计算世界坐标</span></span><br><span class="line">    float4 worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">    o.worldPos = worldPos.xyz;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在片段着色器中，我们需要计算点与线的关系。因为我们后面要使用点来构造线，而两点确定一条线正是我们这里用到的一条基本规律。</p>
<p>为了确定点线之间的关系，我们需要借助两个向量，一是从直线上任意一点到该点的向量，二是直线的法向量。单纯的谈直线的法向量并没有太大意义，因为法向具有方向性，在二维空间有两个，在三维空间有无数个。但是这里我们想判定点是在线的左侧还是右侧，所以我们这里将法向量定义为垂直与直线，并指向直线左侧的向量。</p>
<p>当我们得到这两个向量后，这两个向量的点乘就可以用来判断点与线的关系。如果结果为正，说明在左侧，如果为负，说明在右侧，如果为零，说明在直线上。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/014/Vectors.png"></p>
<p>那么在着色器脚本中，我们首先定义直线上的两个点，然后计算上图中的三个向量。首先我们计算直线的方向，我们将第一个点减去第二个点所得到的方向向量作为直线的方向，然后将该向量旋转90度。接下来我们将直线外的那个点减去直线内的任意一个点。</p>
<p>然后我们将直线的法向量和目标点的向量做点乘，并将结果显示在屏幕上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">float2 linePoint1 = float2(<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">float2 linePoint2 = float2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算这三个向量</span></span><br><span class="line">float2 lineDirection = linePoint2 - linePoint1;</span><br><span class="line">float2 lineNormal = float2(-lineDirection.y, lineDirection.x);</span><br><span class="line">float2 toPos = i.worldPos.xy - linePoint1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算点与线的关系</span></span><br><span class="line"><span class="keyword">float</span> side = dot(toPos, lineNormal);</span><br><span class="line"><span class="comment">//以0为分界线，大于零取1，否则取0</span></span><br><span class="line"><span class="comment">//side = step(0, side);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> side;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/014/Distance.png"></p>
<p>上图中出现一条灰色的过渡带。但是这并不是我们所想要的。因为所有小于零的区域显示为纯黑，0到1之间的显示为灰色区域，大于1的显示为百色。因此我们可以使用<code>step</code>函数来讲中间灰度区域去掉。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以0为分界线，大于零取1，否则取0</span></span><br><span class="line"><span class="keyword">float</span> side = dot(toPos, lineNormal);</span><br><span class="line">side = step(<span class="number">0</span>, side);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> side;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/014/Line.png"></p>
<p>当我们再向其中加入一个点、两条线，就可以构成三角形了。因此我们将上面的判断逻辑抽成一个函数，方便复用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在左边返回1，否则返回0</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">isLeftOfLine</span><span class="params">(float2 pos, float2 linePoint1, float2 linePoint2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//计算三个向量</span></span><br><span class="line">    float2 lineDirection = linePoint2 - linePoint1;</span><br><span class="line">    float2 lineNormal = float2(-lineDirection.y, lineDirection.x);</span><br><span class="line">    float2 toPos = pos - linePoint1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以0为分界线，大于零取1，否则取0</span></span><br><span class="line">    <span class="keyword">float</span> side = dot(toPos, lineNormal);</span><br><span class="line">    side = step(<span class="number">0</span>, side);</span><br><span class="line">    <span class="keyword">return</span> side;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    float2 linePoint1 = float2(<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    float2 linePoint2 = float2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    side = isLeftOfLine(i.worldPos.xy, linePoint1, linePoint2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> side;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Draw-a-Polygon-of-multiple-lines"><a href="#Draw-a-Polygon-of-multiple-lines" class="headerlink" title="Draw a Polygon of multiple lines"></a>Draw a Polygon of multiple lines</h2><p>前面已经抽取点与线的位置判断函数，这样我们可以对多边形的每一条边界线进行判定。然后将所有的判定结果结合起来，判定点与多边形的位置关系。例如我们可以定义当点在所有线的左侧时，为true，反之为false。或者我们可以定义在所有线的右侧时，为false，反之为true。这里我们定义的三角形为顺时针，这意味着线的左侧为三角形的外侧，我们可以将所有线条的判定结果求和，当全为左侧时，为零，否则大于零。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段作色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    float2 linePoint1 = float2(<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    float2 linePoint2 = float2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    float2 linePoint3 = float2(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> outsideTriangle = isLeftOfLine(i.worldPos.xy, linePoint1, linePoint2);</span><br><span class="line">    outsideTriangle = outsideTriangle + isLeftOfLine(i.worldPos.xy, linePoint2, linePoint3);</span><br><span class="line">    outsideTriangle = outsideTriangle + isLeftOfLine(i.worldPos.xy, linePoint3, linePoint1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> outsideTriangle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/014/Triangle.png"></p>
<p>上面我们成功通过边界裁剪来实现多边形效果。现在我想通过材质面板来编辑这个裁剪区域。我们需要引入两个变量，一个是裁剪顶点列表，一个是顶点的个数。顶点列表记录的是我们裁剪区域的顶点位置。第二个是记录顶点的个数，因为着色器中不支持动态数组，所以我们需要定义一个固定数组，然后通过该变量来控制实际参与计算的顶点个数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶点数组和个数</span></span><br><span class="line">uniform float2 _corners[<span class="number">1000</span>];</span><br><span class="line">uniform uint _cornerCount;</span><br></pre></td></tr></table></figure>

<h2 id="Filling-the-Corner-Array"><a href="#Filling-the-Corner-Array" class="headerlink" title="Filling the Corner Array"></a>Filling the Corner Array</h2><p>材质面板并不支持数组显示。所以我们需要创建一个脚本组件来管理这个数组。这里我给新创建的脚本添加两个属性，并且将该脚本定义为编辑模式可执行，这样我们就不需要每次都启动程序了。另外，下面的脚本要求必须和渲染的裁剪多边形绑定，这样我们可以访问其中的材质。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ExecuteInEditMode</span>]</span><br><span class="line">[<span class="meta">RequireComponent(typeof(Renderer))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PolygonController</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是我们想脚本中加入两个变量，一个是裁剪着色器所需要的顶点数组，一个是绑定该着色器的材质。材质属性是私有的，因为我们是直接从当前绑定物体上获取的。顶点数组也是私有的，因为我们也不需要在外部访问，但是我们需要在组件面板上编辑它，所以需要<code>SerializeField</code>来标记它。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="keyword">private</span> Vector2[] corners;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Material _mat;</span><br></pre></td></tr></table></figure>

<p>然后我们实现一个函数将这些顶点数据传递给着色器。首先我们需要获取到当前物体的材质，这里我们使用<code>sharedmaterial</code>属性来获取材质，如果使用<code>material</code>属性的话，获取的将是该材质的副本。</p>
<p>然后我们再创建一个长度为1000的4维向量数组。之所以是4维而不是二维，因为Unity只支持向着色其中传递4为向量数组。而长度为1000是因为着色器中定义的是固定长度的数组。当然这里定义1000是假设我们会用到的顶点个数最大为1000，具有一定的随意性，你也可以根据实际需要调整。</p>
<p>当我们将二维向量赋值给四维向量时，为赋值的部分将会以0填充。</p>
<p>在准备好四维向量数组后，我们将其、以及实际的数组长度传递给着色器。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateMaterial</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//获取当前模型的材质</span></span><br><span class="line">    <span class="keyword">if</span>(_mat == <span class="literal">null</span>)</span><br><span class="line">        _mat = GetComponent&lt;Renderer&gt;().sharedMaterial;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填充顶点位置数组</span></span><br><span class="line">    Vector4[] vec4Corners = <span class="keyword">new</span> Vector4[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;corners.Length;i++)&#123;</span><br><span class="line">        vec4Corners[i] = corners[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传递给着色器</span></span><br><span class="line">    _mat.SetVectorArray(<span class="string">&quot;_corners&quot;</span>, vec4Corners);</span><br><span class="line">    _mat.SetInt(<span class="string">&quot;_cornerCount&quot;</span>, corners.Length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一步是在Unity事件函数中调用上面的函数。这里我们选择<code>Start</code>和<code>OnValidate</code>两个函数，前者在游戏启动时会调用一次，后者在每次修改组件属性面板上的值时会调用一次。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    UpdateMaterial();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnValidate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    UpdateMaterial();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>脚本编写完成后，将其以组件的形式赋给我们的裁剪物体。然后在组件属性面板上可以编辑需要的裁剪顶点。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/014/Inspector.png"></p>
<p>下面我们回到着色器脚本，然后在着色器中使用传入的顶点数组。</p>
<p>然后我们使用<code>for</code>循环来依次遍历这个顶点数组。因为在<code>hlsl</code>中，数组的起点是0，所以我们循环的起点也是0。循环的终止条件是超过实际的顶点个数。这里我们使用<code>for</code>循环来遍历。其实还可以将<code>for</code>循环展开，相比而言在显卡中的效率更高，但是我们需要提前知道循环次数才可以展开。这里我们的循环次数是可变的，所以只能使用<code>for</code>循环。</p>
<p>在循环中，我们计算所有的边界与点之间的关系，然后求和。而边界是由本次遍历的顶点和下次遍历的顶点构成的。但是这里有一个问题，就是最后的一个顶点的下一个顶点应该是第一个点的，所以这里我们可以使用求余来将索引值切回到起始点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> outsideTriangle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    [loop]</span><br><span class="line">    <span class="keyword">for</span>(uint index;index&lt;_cornerCount;index++)&#123;</span><br><span class="line">        outsideTriangle += isLeftOfLine(i.worldPos.xy, _corners[index], _corners[(index+<span class="number">1</span>) % _cornerCount]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> outsideTriangle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/014/Hexagon.png"></p>
<p>最终我们得到由六个点构成的裁剪区域。</p>
<h2 id="Clip-and-Color-the-Polygon"><a href="#Clip-and-Color-the-Polygon" class="headerlink" title="Clip and Color the Polygon"></a>Clip and Color the Polygon</h2><p>前面的步骤实际上是一个区域标记的过程，在区域内外都会进行渲染，只不过使用不同的颜色而已。有人可能想问，如何只渲染其中一部分，这样就可以向其中添加其他模型一同渲染。在<code>hlsl</code>中有一个放弃渲染的函数叫做<code>clip</code>。如果向<code>clip</code>传入的值小于0，那么将不会执行颜色写入的操作，否则的话正常渲染。</p>
<p>前面我们已经计算出区域标记，不过要么是0要么是1，都不小于0，因此我们还需要做一些转换才能将其中一部分渲染剔除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clip(-outsideTriangle);</span><br><span class="line"><span class="keyword">return</span> outsideTriangle;</span><br></pre></td></tr></table></figure>

<p><img src="https://www.ronja-tutorials.com/assets/images/posts/014/SuperHexagon.png"><br><img src="https://www.ronja-tutorials.com/assets/images/posts/014/ConcaveBreaking.gif"></p>
<p>这种裁剪方式有很大的缺陷，就是只能用来渲染凸多边形。ps:其实我觉得凹多边形也不影响。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/014_Polygon&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//属性面板</span></span><br><span class="line">    Properties&#123;</span><br><span class="line">        _Color (<span class="string">&quot;Color&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader&#123;</span><br><span class="line">        <span class="comment">//渲染不透明物体</span></span><br><span class="line">        Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">        Pass&#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="comment">//引入内置函数和变量</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//定义顶点和片段着色器</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//用于裁剪的顶点数组</span></span><br><span class="line">            uniform float2 _corners[<span class="number">1000</span>];</span><br><span class="line">            uniform uint _cornerCount;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//模型网格数据</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//中间插值数据</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">                float4 position : SV_POSITION;</span><br><span class="line">                float3 worldPos : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//顶点着色器</span></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">//计算裁剪坐标</span></span><br><span class="line">                o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">//计算世界坐标</span></span><br><span class="line">                float4 worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">                o.worldPos = worldPos.xyz;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在左边返回1，否则返回0</span></span><br><span class="line">            <span class="function"><span class="keyword">float</span> <span class="title">isLeftOfLine</span><span class="params">(float2 pos, float2 linePoint1, float2 linePoint2)</span></span>&#123;</span><br><span class="line">                <span class="comment">//计算所需的三个向量</span></span><br><span class="line">                float2 lineDirection = linePoint2 - linePoint1;</span><br><span class="line">                float2 lineNormal = float2(-lineDirection.y, lineDirection.x);</span><br><span class="line">                float2 toPos = pos - linePoint1;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//以0为分界线，大于零取1，否则取0</span></span><br><span class="line">                <span class="keyword">float</span> side = dot(toPos, lineNormal);</span><br><span class="line">                side = step(<span class="number">0</span>, side);</span><br><span class="line">                <span class="keyword">return</span> side;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//片段着色器</span></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">float</span> outsideTriangle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                [loop]</span><br><span class="line">                <span class="keyword">for</span>(uint index;index&lt;_cornerCount;index++)&#123;</span><br><span class="line">                    outsideTriangle += isLeftOfLine(i.worldPos.xy, _corners[index], _corners[(index+<span class="number">1</span>) % _cornerCount]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                clip(-outsideTriangle);</span><br><span class="line">                <span class="keyword">return</span> _Color;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ExecuteInEditMode</span>]</span><br><span class="line">[<span class="meta">RequireComponent(typeof(Renderer))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PolygonController</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">	[<span class="meta">SerializeField</span>]</span><br><span class="line">	<span class="keyword">private</span> Vector2[] corners;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Material _mat;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		UpdateMaterial();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnValidate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		UpdateMaterial();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">UpdateMaterial</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="comment">//获取当前模型所用的材质</span></span><br><span class="line">		<span class="keyword">if</span>(_mat == <span class="literal">null</span>)</span><br><span class="line">			_mat = GetComponent&lt;Renderer&gt;().sharedMaterial;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//填充顶点数组</span></span><br><span class="line">		Vector4[] vec4Corners = <span class="keyword">new</span> Vector4[<span class="number">1000</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;corners.Length;i++)&#123;</span><br><span class="line">			vec4Corners[i] = corners[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//传递给着色器</span></span><br><span class="line">		_mat.SetVectorArray(<span class="string">&quot;_corners&quot;</span>, vec4Corners);</span><br><span class="line">		_mat.SetInt(<span class="string">&quot;_cornerCount&quot;</span>, corners.Length);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望你能从这边文章中了解到如何处理点、线等多边形问题。也希望我所介绍到刚好是你想知道的！</p>
<p>你可以在以下链接找到源码：<br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/014_Polygon/Polygon.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/014_Polygon/Polygon.shader</a><br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/014_Polygon/PolygonController.cs">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/014_Polygon/PolygonController.cs</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/05/Ronja_Custom_Lighting/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/05/Ronja_Custom_Lighting/" class="post-title-link" itemprop="url">Custom Lighting</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-05 22:01:00" itemprop="dateCreated datePublished" datetime="2021-07-05T22:01:00+08:00">2021-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-20 23:50:31" itemprop="dateModified" datetime="2022-09-20T23:50:31+08:00">2022-09-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/013-custom-lighting/">Custom Lighting</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>表面着色器真的非常方便，特别是在处理光照时，表面着色器可以使用PBR模型快速实现物理光照效果。但是有时候我们可能想实现其他一些光照效果，例如卡通风格的。这时候我们可以使用自定义光照函数来满足我们的需求。</p>
<p>本篇主要介绍表面着色器特有的一些功能。但是光照处理的基本原理可以应用到其他着色器中。只不过Unity会为表面着色器生成一个基本的可复用的光照框架，如果我们使用其他着色器，那么必须手动补全这部分代码，但是这些并不是本文的重点，所以不做赘述。</p>
<p>如果你是一个初学者，建议你从<a href="https://tyson-wu.github.io/blogs/2021/06/25/Ronja_Structure/">第一章</a>开始看。</p>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/013/Result.png"></p>
<h2 id="Use-Custom-Lighting-Function"><a href="#Use-Custom-Lighting-Function" class="headerlink" title="Use Custom Lighting Function"></a>Use Custom Lighting Function</h2><p>首先我们需要将光照模型设置为我们自定义的光照函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表面着色器</span></span><br><span class="line"><span class="comment">//表面着色函数以及我们的自定义光照函数</span></span><br><span class="line"><span class="comment">//fullforwardshadows 应用所有的阴影Pass</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> surface surf Custom fullforwardShadows</span></span><br></pre></td></tr></table></figure>

<p>然后我们添加我们的自定义光照函数。光照函数的名字结构是<code>LightingX</code>，其中<code>X</code>是上面定义的光照函数，这里是<code>Custom</code>。在下面的自定义光照函数中使用的<code>SurfaceOutput</code>结构体，实际上是由<code>surf</code>表面着色器函数返回的数据，两者最终的数据结构必须一致。另外还有光照方向、以及光照衰减度，衰减度在后面会介绍。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义光照函数，针对每个光源都会处理一遍</span></span><br><span class="line"><span class="function">float4 <span class="title">LightingCustom</span><span class="params">(SurfaceOutput s, float3 lightDir, <span class="keyword">float</span> atten)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SurfaceOutput</code>和<code>SurfaceOutputSstandard</code>都是Unity预定义的数据结构，前者是针对非物理渲染的，后者是提供了物理渲染的基本参数。当然你也可以把他们当做是一个参考模板，然后实现自己的数据结构。使用的方法是，先在表面着色器函数中对该结构赋值，然后在自定义光照函数中使用。因为<code>SurfaceOutput</code>不包含光滑度、以及金属度的属性，所以在表面着色器删除对这两者的赋值。</p>
<p>//表面着色器<br>void surf (Input i, inout SurfaceOutput o) {<br>    //纹理采样<br>    fixed4 col = tex2D(_MainTex, i.uv_MainTex);<br>    col *= _Color;<br>    o.Albedo = col.rgb;</p>
<pre><code>//o.Emission = _Emission;</code></pre>
<p>}</p>
<p>现在我们有了自己的光照函数，但是该函数目前返回的是0，所以模型渲染后看不到光照效果。</p>
<p>按理说光照为零的话，整个模型应该是纯黑色，但是我们现在却能看清模型的基本轮廓。这是因为，光照函数处理的是直接光源，但是在模型渲染的时候除了直接光源，还有间接光源作用。其中环境光就是一种间接光源，Unity会自动将天空盒的颜色来当成环境光的一部分，所以我们在环境光的作用下还能看清物体。如果你在Unity编辑器的场景窗口上方选择关闭环境光的按钮，那么整个模型最终就会变成纯黑色，并且其最终显示都完全受我们的自定义光照函数控制。当然这里我保留Unity编辑器的默认设置。</p>
<h2 id="Implement-Lighting-Ramp"><a href="#Implement-Lighting-Ramp" class="headerlink" title="Implement Lighting Ramp"></a>Implement Lighting Ramp</h2><p>下面我们来实现简单的自定义光照函数。第一步我们先求解表面法向和入射光线方向向量的点乘，这两个参数正好在自定义光照函数的参数列表中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义光照函数</span></span><br><span class="line"><span class="function">float4 <span class="title">LightingCustom</span><span class="params">(SurfaceOutput s, float3 lightDir, <span class="keyword">float</span> atten)</span></span>&#123;</span><br><span class="line">    <span class="comment">//法向和光照入射方向的点乘，可以用来表示光照密度</span></span><br><span class="line">    <span class="keyword">float</span> towardsLight = dot(s.Normal, lightDir);</span><br><span class="line">    <span class="keyword">return</span> towardsLight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/013/DotLight.png"></p>
<p>下面我们实现的光照函数非常简单，涵盖了一般通用结构。我们使用光线入射向量来最为纹理纹理采样的参数，并将采样结果当成光源在该点的亮度。</p>
<p>因此我们必须将点乘结果的取值范围从<code>[-1, 1]</code>映射为<code>[0, 1]</code>，因为后者是UV的取值范围。</p>
<p>然后我们创建一个叫<code>ramp</code>的纹理变量。按照前面说的采样方法进行采样。然后在材质面板上设置纹理为半黑半白的图片。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//材质面板</span></span><br><span class="line">Properties &#123;</span><br><span class="line">    _Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    [HDR] _Emission (<span class="string">&quot;Emission&quot;</span>, color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    _Ramp (<span class="string">&quot;Toon Ramp&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">sampler2D _Ramp;</span><br></pre></td></tr></table></figure>

<p>下面是我们所用的<code>ramp</code>纹理。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/013/HardRamp.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义光照函数</span></span><br><span class="line"><span class="function">float4 <span class="title">LightingCustom</span><span class="params">(SurfaceOutput s, float3 lightDir, <span class="keyword">float</span> atten)</span></span>&#123;</span><br><span class="line">    <span class="comment">//入射光强</span></span><br><span class="line">    <span class="keyword">float</span> towardsLight = dot(s.Normal, lightDir);</span><br><span class="line">    <span class="comment">//数值区间映射</span></span><br><span class="line">    towardsLight = towardsLight * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//纹理采样</span></span><br><span class="line">    float3 lightIntensity = tex2D(_Ramp, towardsLight).rgb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> float4(lightIntensity, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/013/DrawRamp.png"></p>
<p>在上图中，模型背光面也能看清模型表面纹理。这还是因为环境光的影响。</p>
<p>为了让效果看起来更好，我们将模型颜色和光照密度相乘、同时应用衰减因子，最终的到一个具有颜色、且强度随距离变化的光源。模型最终的表现也和光源的颜色、和距离相关。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义光照</span></span><br><span class="line"><span class="function">float4 <span class="title">LightingCustom</span><span class="params">(SurfaceOutput s, float3 lightDir, <span class="keyword">float</span> atten)</span></span>&#123;</span><br><span class="line">    <span class="comment">//法向和光入射方向点乘</span></span><br><span class="line">    <span class="keyword">float</span> towardsLight = dot(s.Normal, lightDir);</span><br><span class="line">    <span class="comment">//数值范围映射</span></span><br><span class="line">    towardsLight = towardsLight * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//光强采样</span></span><br><span class="line">    float3 lightIntensity = tex2D(_Ramp, towardsLight).rgb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最终的颜色</span></span><br><span class="line">    float4 col;</span><br><span class="line">    <span class="comment">//应用光照</span></span><br><span class="line">    col.rgb = lightIntensity * s.Albedo * atten * _LightColor0.rgb;</span><br><span class="line">    <span class="comment">//赋值透明通道</span></span><br><span class="line">    col.a = s.Alpha; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/013/CorrectRampLighting.png"></p>
<p>上面已经介绍完了一个完整的自定义光照着色器的实现。我们可以使用不同的<code>ramp</code>纹理来得到完全不同的渲染风格。比如下面，我们采样冷暖色条纹，实现的卡通效果。图片源于<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/SL-SurfaceShaderLightingExamples.html">这里</a><br><img src="https://www.ronja-tutorials.com/assets/images/posts/013/HotColdRamp.png"><br><img src="https://www.ronja-tutorials.com/assets/images/posts/013/HotColdRampModel.png"></p>
<p>在着色器我们还有一个<code>emission</code>没有用到，但是模型最终的显示中却受自发光这个变量的影响。</p>
<p>上面这种卡通风格的着色器非常有用，在很多地方可以灵活运用。</p>
<p>自定义光照函数非常强大，但是只能用在前向渲染中。即便是你把渲染路径改为延迟渲染，最终渲染管线依然会把这部分的渲染转移到前向渲染路径中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/013_CustomSurfaceLighting&quot;</span> &#123;</span><br><span class="line">    <span class="comment">//材质面板</span></span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        [HDR] _Emission (<span class="string">&quot;Emission&quot;</span>, color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        _Ramp (<span class="string">&quot;Toon Ramp&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">//不透明物体</span></span><br><span class="line">        Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">        CGPROGRAM</span><br><span class="line"></span><br><span class="line">        <span class="comment">//表面着色器</span></span><br><span class="line">        <span class="comment">//自定义表面着色器函数、自定义光照函数</span></span><br><span class="line">        <span class="comment">//fullforwardshadows 使用所有的阴影Pass</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> surface surf Custom fullforwardshadows</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> target 3.0</span></span><br><span class="line"></span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line">        fixed4 _Color;</span><br><span class="line">        half3 _Emission;</span><br><span class="line"></span><br><span class="line">        sampler2D _Ramp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自定义光照函数</span></span><br><span class="line">        <span class="function">float4 <span class="title">LightingCustom</span><span class="params">(SurfaceOutput s, float3 lightDir, <span class="keyword">float</span> atten)</span></span>&#123;</span><br><span class="line">            <span class="comment">//点乘</span></span><br><span class="line">            <span class="keyword">float</span> towardsLight = dot(s.Normal, lightDir);</span><br><span class="line">            <span class="comment">//数值范围映射</span></span><br><span class="line">            towardsLight = towardsLight * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//采样</span></span><br><span class="line">            float3 lightIntensity = tex2D(_Ramp, towardsLight).rgb;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//最终的颜色</span></span><br><span class="line">            float4 col;</span><br><span class="line">            <span class="comment">//计算光照</span></span><br><span class="line">            col.rgb = lightIntensity * s.Albedo * atten * _LightColor0.rgb;</span><br><span class="line">            <span class="comment">//使用透明通道</span></span><br><span class="line">            col.a = s.Alpha; </span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> col;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输入结构体</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">            float2 uv_MainTex;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//表边着色器函数</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutput o)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//纹理采样</span></span><br><span class="line">            fixed4 col = tex2D(_MainTex, i.uv_MainTex);</span><br><span class="line">            col *= _Color;</span><br><span class="line">            o.Albedo = col.rgb;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//o.Emission = _Emission;</span></span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Standard&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望本篇能帮助你理解表面着色器和自定义光照。</p>
<p>你可以在以下链接找到源码：<br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/013_CustomSurfaceLighting/CustomLighting.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/013_CustomSurfaceLighting/CustomLighting.shader</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/05/Ronja_Fresnel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/05/Ronja_Fresnel/" class="post-title-link" itemprop="url">Fresnel</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-05 19:01:00" itemprop="dateCreated datePublished" datetime="2021-07-05T19:01:00+08:00">2021-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-20 23:50:31" itemprop="dateModified" datetime="2022-09-20T23:50:31+08:00">2022-09-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/012-fresnel/">Fresnel</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>菲涅尔效果是渲染中常用的效果。使用菲涅尔效果我们可以很方便的对模型的边缘进行增亮、加黑等边缘效果，加强场景的深度感。</p>
<p>本篇将采用表面着色器的实现方法，所以如果你对表面着色器还不了解的话，建议你先看看<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Surface_Shader_Basics/">这篇</a>文章。当然你也可以将菲涅尔效果应用到其他类型的着色器，来增强模型平滑度、或突出重点。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/012/Result.jpg"></p>
<h2 id="Highlighting-one-Side-of-the-Model"><a href="#Highlighting-one-Side-of-the-Model" class="headerlink" title="Highlighting one Side of the Model"></a>Highlighting one Side of the Model</h2><p>我们通过修改表面着色器来实现菲涅尔效果。菲涅尔效果是根据法向来计算效果的密度、或厚度。因为要在片段着色器中使用到世界坐标系中的法向量，所以我们首先在顶点着色器中计算好世界坐标系中的顶点法向，然后通过中间插值结构传递给片段着色器。当然，我们的输入结构体和中间插值结构体都需要定义法向量。</p>
<p>在<a href="https://tyson-wu.github.io/blogs/2021/07/02/Ronja_Triplanar_Mapping/">三维平面映射</a>我们介绍了如何计算顶点的世界法向量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入的模型网格数据，其中采用宏定义来定义部分数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">    float2 uv_MainTex;</span><br><span class="line">    float3 worldNormal;</span><br><span class="line">    INTERNAL_DATA</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以通过计算相邻向量之间的点乘，从而了解模型表明的平滑度、或者梯度。单位向量之间的点乘越大，说明它们方向越一致。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/012/DotSphere.png"><br><img src="https://www.ronja-tutorials.com/assets/images/posts/012/DotDirection.png"></p>
<p>首先，我将所有法向量与一个固定向量做点乘，可以让我们更容易理解点乘的意义。然后将点乘的结果传递给<code>emission</code>变量，将点乘结果通过自发光的形式表现出来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表面着色器函数，主要用了计算光照模型的输入参数，然后由光照模型进行最中的颜色计算</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//两个向量之间的点乘</span></span><br><span class="line">    <span class="keyword">float</span> fresnel = dot(i.worldNormal, float3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">//应用菲涅尔效果</span></span><br><span class="line">    o.Emission = _Emission + fresnel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/012/WhiteTopBlackBottom.png"></p>
<p>上图我们可以看到，越朝上的地方越亮、越朝下越暗。为了避免自发光出现负数，这里将菲涅尔值限定在<code>[0,1]</code>之间。这里有两个函数<code>staturate</code>和<code>clamp</code>都可以实现范围限定的功能，但是<code>staturate</code>在GPU上执行速度更快。下面是限定后的效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表面着色器函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算菲涅尔值</span></span><br><span class="line">    <span class="keyword">float</span> fresnel = dot(i.worldNormal, float3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">//限定为 0 - 1 之间</span></span><br><span class="line">    fresnel = saturate(fresnel);</span><br><span class="line">    <span class="comment">//应用菲尼尔效果</span></span><br><span class="line">    o.Emission = _Emission + fresnel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/012/WhiteTopBlackBottom.png"></p>
<h2 id="Highlighting-the-outer-Parts"><a href="#Highlighting-the-outer-Parts" class="headerlink" title="Highlighting the outer Parts"></a>Highlighting the outer Parts</h2><p>接下来我们使用视角方向来计算菲涅尔值。视角放向可以直接定义输入结构体中，然后在表面着色器函数中就可以访问。</p>
<p>如果是在无光照着色器中实现菲涅尔效果，那么视角方向可以通过摄像机的位置和顶点世界坐标来计算。其中摄像机坐标存储在<code>_WorldSpaceCameraPos</code>这个内置变量中，由Unity来赋值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表面着色器的输入结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">    float2 uv_MainTex;</span><br><span class="line">    float3 worldNormal;</span><br><span class="line">    float3 viewDir;</span><br><span class="line">    INTERNAL_DATA</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表面着色器函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//金属度与光滑度</span></span><br><span class="line">    o.Metallic = _Metallic;</span><br><span class="line">    o.Smoothness = _Smoothness;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//菲尼尔值</span></span><br><span class="line">    <span class="keyword">float</span> fresnel = dot(i.worldNormal, i.viewDir);</span><br><span class="line">    <span class="comment">//范围限定在 0 - 1</span></span><br><span class="line">    fresnel = saturate(fresnel);</span><br><span class="line">    <span class="comment">//应用菲涅尔值</span></span><br><span class="line">    o.Emission = _Emission + fresnel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/012/WhiteFront.png"></p>
<p>总体来说实现了菲涅尔效果，但是整个材质是靠近中心区域更亮，而不是边缘更亮。如果我们想让边缘更亮，我们可以将1减去菲涅尔值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表面着色器函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//菲涅尔值</span></span><br><span class="line">    <span class="keyword">float</span> fresnel = dot(i.worldNormal, i.viewDir);</span><br><span class="line">    <span class="comment">//效果反转</span></span><br><span class="line">    fresnel = saturate(<span class="number">1</span> - fresnel);</span><br><span class="line">    <span class="comment">//应用菲涅尔效果</span></span><br><span class="line">    o.Emission = _Emission + fresnel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/012/WhiteFresnel.png"></p>
<h2 id="Add-Fresnel-Color-and-Intensity"><a href="#Add-Fresnel-Color-and-Intensity" class="headerlink" title="Add Fresnel Color and Intensity"></a>Add Fresnel Color and Intensity</h2><p>最后，我想增加一些自定义属性，比如菲涅尔颜色。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">_FresnelColor (<span class="string">&quot;Fresnel Color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">float3 _FresnelColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//表面着色器函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//菲涅尔值</span></span><br><span class="line">    <span class="keyword">float</span> fresnel = dot(i.worldNormal, i.viewDir);</span><br><span class="line">    <span class="comment">//效果反转</span></span><br><span class="line">    fresnel = saturate(<span class="number">1</span> - fresnel);</span><br><span class="line">    <span class="comment">//使用菲涅尔自定义颜色</span></span><br><span class="line">    float3 fresnelColor = fresnel * _FresnelColor;</span><br><span class="line">    <span class="comment">//应用菲涅尔效果</span></span><br><span class="line">    o.Emission = _Emission + fresnelColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/012/Result.jpg"></p>
<p>然后再增加一个控制菲涅尔强度的属性。这里我们使用指数函数来调节菲涅尔强度。</p>
<p>因为指数函数计算消耗非常大，所以如果有其他方法能实现相同的效果，尽量不要使用指数函数。当然，指数函数用法简单、便捷，在设计效果的时候可以直接使用指数函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">[PowerSlider(<span class="number">4</span>)] _FresnelExponent (<span class="string">&quot;Fresnel Exponent&quot;</span>, Range(<span class="number">0.25</span>, <span class="number">4</span>)) = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> _FresnelExponent;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//表面着色器函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//菲涅尔值</span></span><br><span class="line">    <span class="keyword">float</span> fresnel = dot(i.worldNormal, i.viewDir);</span><br><span class="line">    <span class="comment">//效果反转</span></span><br><span class="line">    fresnel = saturate(<span class="number">1</span> - fresnel);</span><br><span class="line">    <span class="comment">//使用菲涅尔自定义颜色</span></span><br><span class="line">    float3 fresnelColor = fresnel * _FresnelColor;</span><br><span class="line">    <span class="comment">//强度调节</span></span><br><span class="line">    fresnel = <span class="built_in">pow</span>(fresnel, _FresnelExponent);</span><br><span class="line">    <span class="comment">//应用菲涅尔效果</span></span><br><span class="line">    o.Emission = _Emission + fresnelColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/012/ExponentAdjustment.gif"></p>
<p>菲涅尔效果除了用来突出轮廓外，还可以用来实现各种渐变效果，这里不展开，有兴趣可以自行尝试。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/012_Fresnel&quot;</span> &#123;</span><br><span class="line">    <span class="comment">//材质面板</span></span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Smoothness (<span class="string">&quot;Smoothness&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">        _Metallic (<span class="string">&quot;Metalness&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">        [HDR] _Emission (<span class="string">&quot;Emission&quot;</span>, color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        _FresnelColor (<span class="string">&quot;Fresnel Color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        [PowerSlider(<span class="number">4</span>)] _FresnelExponent (<span class="string">&quot;Fresnel Exponent&quot;</span>, Range(<span class="number">0.25</span>, <span class="number">4</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">//不透明物体</span></span><br><span class="line">        Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">        CGPROGRAM</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这是表面着色器，unity会自动生成部分代码</span></span><br><span class="line">        <span class="comment">//surf 是被定义为表面着色器函数</span></span><br><span class="line">        <span class="comment">//fullforwardshadows 告诉Unity将所有阴影Pass都复制过来</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> surface surf Standard fullforwardshadows</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> target 3.0</span></span><br><span class="line"></span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line">        fixed4 _Color;</span><br><span class="line"></span><br><span class="line">        half _Smoothness;</span><br><span class="line">        half _Metallic;</span><br><span class="line">        half3 _Emission;</span><br><span class="line"></span><br><span class="line">        float3 _FresnelColor;</span><br><span class="line">        <span class="keyword">float</span> _FresnelExponent;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//表面着色器的输入结构</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">            float2 uv_MainTex;</span><br><span class="line">            float3 worldNormal;</span><br><span class="line">            float3 viewDir;</span><br><span class="line">            INTERNAL_DATA</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//表面着色器函数，主要用来计算光照模型所需的参数</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//纹理采样</span></span><br><span class="line">            fixed4 col = tex2D(_MainTex, i.uv_MainTex);</span><br><span class="line">            col *= _Color;</span><br><span class="line">            o.Albedo = col.rgb;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//光滑度、和金属度</span></span><br><span class="line">            o.Metallic = _Metallic;</span><br><span class="line">            o.Smoothness = _Smoothness;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//菲涅尔值</span></span><br><span class="line">            <span class="keyword">float</span> fresnel = dot(i.worldNormal, i.viewDir);</span><br><span class="line">            <span class="comment">//效果翻转</span></span><br><span class="line">            fresnel = saturate(<span class="number">1</span> - fresnel);</span><br><span class="line">            <span class="comment">//控制菲涅尔强度</span></span><br><span class="line">            fresnel = <span class="built_in">pow</span>(fresnel, _FresnelExponent);</span><br><span class="line">            <span class="comment">//应用菲涅尔颜色</span></span><br><span class="line">            float3 fresnelColor = fresnel * _FresnelColor;</span><br><span class="line">            <span class="comment">//应用菲涅尔</span></span><br><span class="line">            o.Emission = _Emission + fresnelColor;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Standard&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望本篇能让你对菲涅尔效果有所了解。</p>
<p>你可以在以下链接找到源码：<a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/012_Fresnel/Fresnel.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/012_Fresnel/Fresnel.shader</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/05/Ronja_Checkerboard_Pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/05/Ronja_Checkerboard_Pattern/" class="post-title-link" itemprop="url">Checkerboard Pattern</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-05 13:01:00" itemprop="dateCreated datePublished" datetime="2021-07-05T13:01:00+08:00">2021-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-20 23:50:31" itemprop="dateModified" datetime="2022-09-20T23:50:31+08:00">2022-09-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/011-chessboard/">Checkerboard Pattern</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>我觉得使用着色器来生成图片比较有意思。下面我以棋盘格为例，像你们展示如何通过程序生成模型纹理的。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/011/Result.png"></p>
<h2 id="Stripes"><a href="#Stripes" class="headerlink" title="Stripes"></a>Stripes</h2><p>参考前面关于<a href="https://tyson-wu.github.io/blogs/2021/07/02/Ronja_Planar_Mapping/">二维平面映射</a>的教程，这里我们也是基于模型顶点的世界坐标来生成UV，这样的话，移动模型的过程中，其表面纹理在前后帧的渲染图可以无缝衔接。如果你希望生成的纹理跟随模型一起运动，那么可以选择基于模型坐标系进行计算。</p>
<p>首先，我们在顶点着色器中通过坐标变换，计算得到顶点的世界坐标，然后通过中间插值数据结构将计算结果传递到片段着色器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">    float4 position : SV_POSITION;</span><br><span class="line">    float3 worldPos : TEXCOORD0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    <span class="comment">//计算裁剪坐标</span></span><br><span class="line">    o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    <span class="comment">//计算世界坐标</span></span><br><span class="line">    o.worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在片段着色器中，我们首先考虑一个维度上的棋盘格效果，也就是黑白相间的条纹效果。方法很简单，就是选取世界坐标中的一个轴向的值，然后取整，两个整数之间的数取整后的结果是一样的，也就是说取整后的值代表了两个整数之间的区域，正是我们这个里的条纹效果。</p>
<p>然后我们要区分条纹的奇偶顺序，因为两个相邻的条纹刚好可以用两个相邻的整数来表示，所以只需要求其整数的奇偶性。求一个整数的奇偶性，可以通过对2的求余操作来实现。然后通过奇偶性来判断其颜色。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//选择x轴的值取整</span></span><br><span class="line">    <span class="keyword">float</span> chessboard = <span class="built_in">floor</span>(i.worldPos.x);</span><br><span class="line">    <span class="comment">//计算余数的一半</span></span><br><span class="line">    chessboard = frac(chessboard * <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">//计算余数</span></span><br><span class="line">    chessboard *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> chessboard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/011/1d.png"></p>
<h2 id="Checkerboard-in-2d-and-3d"><a href="#Checkerboard-in-2d-and-3d" class="headerlink" title="Checkerboard in 2d and 3d"></a>Checkerboard in 2d and 3d</h2><p>接下来，我们处理两个轴向的棋盘格。按照前面的操作，另外在选一个轴向进行计算，这时候分别知道两个轴的奇偶性，然后两个奇偶值相加，再求一遍奇偶性，得到最终格子的颜色。实际上可以进一步优化，可以直接在取整之后就求和，然后后面的奇偶求解可以合并。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//合并两个轴向</span></span><br><span class="line">    <span class="keyword">float</span> chessboard = <span class="built_in">floor</span>(i.worldPos.x) + <span class="built_in">floor</span>(i.worldPos.y);</span><br><span class="line">    <span class="comment">//计算余数的一半</span></span><br><span class="line">    chessboard = frac(chessboard * <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">//计算余数</span></span><br><span class="line">    chessboard *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> chessboard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/011/OddEvenPattern.png"><br><img src="https://www.ronja-tutorials.com/assets/images/posts/011/2d.png"></p>
<p>我们还可以进一步扩展到三个轴。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//合并三个轴向</span></span><br><span class="line">    <span class="keyword">float</span> chessboard = <span class="built_in">floor</span>(i.worldPos.x) + <span class="built_in">floor</span>(i.worldPos.y) + <span class="built_in">floor</span>(i.worldPos.z);</span><br><span class="line">    <span class="comment">//计算余数的一半</span></span><br><span class="line">    chessboard = frac(chessboard * <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">//计算余数</span></span><br><span class="line">    chessboard *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> chessboard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/011/3d.png"></p>
<h2 id="Scaling"><a href="#Scaling" class="headerlink" title="Scaling"></a>Scaling</h2><p>下面我们再给棋盘格增加一个缩放功能。我们需要在材质面板上引入缩放变量，方便后续调参。然后在片段着色器中，先将世界坐标处以这个缩放参数，然后在执行上面的操作。这样我们在材质面板上减小缩放变量时，棋盘格的大小也会变小。</p>
<p>除此之外，这里还有一个细微的改变，就是我们不再是对各个轴向分开取整，而是直接采样向量的方法，同时对所有轴向进行求整。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//材质面板属性</span></span><br><span class="line">Properties&#123;</span><br><span class="line">    _Scale (<span class="string">&quot;Pattern Size&quot;</span>, Range(<span class="number">0</span>,<span class="number">10</span>)) = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> _Scale;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//使用向量方法对各个轴向同时取整</span></span><br><span class="line">    float3 adjustedWorldPos = <span class="built_in">floor</span>(i.worldPos / _Scale);</span><br><span class="line">    <span class="comment">//各个轴向求和</span></span><br><span class="line">    <span class="keyword">float</span> chessboard = adjustedWorldPos.x + adjustedWorldPos.y + adjustedWorldPos.z;</span><br><span class="line">    <span class="comment">//计算余数的一半</span></span><br><span class="line">    chessboard = frac(chessboard * <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">//计算余数</span></span><br><span class="line">    chessboard *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> chessboard;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/011/Scaling.gif"></p>
<h2 id="Customizable-Colors"><a href="#Customizable-Colors" class="headerlink" title="Customizable Colors"></a>Customizable Colors</h2><p>最后，我们还可以增加两个变量来控制棋盘格的颜色。在片段着色器的最后我使用线性插值函数来实现两种颜色的二选一操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//材质面板</span></span><br><span class="line">Properties&#123;</span><br><span class="line">    _Scale (<span class="string">&quot;Pattern Size&quot;</span>, Range(<span class="number">0</span>,<span class="number">10</span>)) = <span class="number">1</span></span><br><span class="line">    _EvenColor(<span class="string">&quot;Color 1&quot;</span>, Color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    _OddColor(<span class="string">&quot;Color 2&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">float4 _EvenColor;</span><br><span class="line">float4 _OddColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//同时取整</span></span><br><span class="line">    float3 adjustedWorldPos = <span class="built_in">floor</span>(i.worldPos / _Scale);</span><br><span class="line">    <span class="comment">//三个维度求和</span></span><br><span class="line">    <span class="keyword">float</span> chessboard = adjustedWorldPos.x + adjustedWorldPos.y + adjustedWorldPos.z;</span><br><span class="line">    <span class="comment">//计算余数的一半</span></span><br><span class="line">    chessboard = frac(chessboard * <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">//计算余数</span></span><br><span class="line">    chessboard *= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二选一操作</span></span><br><span class="line">    float4 color = lerp(_EvenColor, _OddColor, chessboard);</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/011/colors.png"></p>
<p>下面是最终的棋盘格生成着色器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/011_Chessboard&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//材质面板</span></span><br><span class="line">    Properties&#123;</span><br><span class="line">        _Scale (<span class="string">&quot;Pattern Size&quot;</span>, Range(<span class="number">0</span>,<span class="number">10</span>)) = <span class="number">1</span></span><br><span class="line">        _EvenColor(<span class="string">&quot;Color 1&quot;</span>, Color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        _OddColor(<span class="string">&quot;Color 2&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader&#123;</span><br><span class="line">        <span class="comment">//不透明物体</span></span><br><span class="line">        Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Pass&#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> _Scale;</span><br><span class="line"></span><br><span class="line">            float4 _EvenColor;</span><br><span class="line">            float4 _OddColor;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">                float4 position : SV_POSITION;</span><br><span class="line">                float3 worldPos : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">//计算裁剪坐标</span></span><br><span class="line">                o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">//计算世界坐标</span></span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">                <span class="comment">//同时取整</span></span><br><span class="line">                float3 adjustedWorldPos = <span class="built_in">floor</span>(i.worldPos / _Scale);</span><br><span class="line">                <span class="comment">//求和</span></span><br><span class="line">                <span class="keyword">float</span> chessboard = adjustedWorldPos.x + adjustedWorldPos.y + adjustedWorldPos.z;</span><br><span class="line">                <span class="comment">//计算余数的一半</span></span><br><span class="line">                chessboard = frac(chessboard * <span class="number">0.5</span>);</span><br><span class="line">                <span class="comment">//计算余数</span></span><br><span class="line">                chessboard *= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//二选一插值</span></span><br><span class="line">                float4 color = lerp(_EvenColor, _OddColor, chessboard);</span><br><span class="line">                <span class="keyword">return</span> color;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Standard&quot;</span> <span class="comment">//后补着色器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望本篇对你有所帮助，能够让你知道如何通过程序实现模型纹理图。</p>
<p>你可以在以下链接找到源码：<a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/011_ChessBoard/Chessboard.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/011_ChessBoard/Chessboard.shader</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/02/Ronja_Triplanar_Mapping/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/02/Ronja_Triplanar_Mapping/" class="post-title-link" itemprop="url">Triplanar Mapping</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-02 13:01:00" itemprop="dateCreated datePublished" datetime="2021-07-02T13:01:00+08:00">2021-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-20 23:50:31" itemprop="dateModified" datetime="2022-09-20T23:50:31+08:00">2022-09-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/010-triplanar-mapping/">Triplanar Mapping</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>在前面我们介绍过二维平面映射的实现方法，这里我们来讲讲三维平面的映射方法。<br>纳尼？平面本身是二维的叫二维平面还可以理解，你这来个三维平面，是欺负我读书少，想糊弄我？？？<br>稍安勿躁！首先专业名字本身依据其专业用途、含义来取的，很容易和我们习惯相冲突，比如数学领域各种眼花缭乱的术语。这里我们的三维平面更多的值得是三维空间上的平面，可以有三个维度的取值。之前提到的二维平面映射，是只从一个方向进行投影，换句话说，我们只用沿着其投影方向进行渲染，才能看到我们的纹理贴合在模型表面，如果换个角度，你可能就看不到了，即便看到了也可能是模糊不清的。而三维平面映射，是从分别从三个维度进行投影映射，然后将得到的三个纹理颜色进行混合，这样无论我们采用怎样刁钻的角度，也挑不出啥毛病。</p>
<p>当然，本文也是在之前的二维平面映射的基础上扩展的，在了解其原理后，你也可以使用表面着色器重写一遍。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/010/Result.gif"></p>
<h2 id="Calcualte-Projection-Planes"><a href="#Calcualte-Projection-Planes" class="headerlink" title="Calcualte Projection Planes"></a>Calcualte Projection Planes</h2><p>首先，为了得到三个不同方向的UV坐标，我们需要改变UV坐标的生成方式。在二维平面映射中，我们是在顶点着色器中进行UV变换。这里我们直接将顶点的世界坐标传递到片段着色器中，然后在片段着色器中进行uv变换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">    float4 position : SV_POSITION;</span><br><span class="line">    float3 worldPos : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    <span class="comment">//计算裁剪空间坐标</span></span><br><span class="line">    o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    <span class="comment">//计算世界坐标</span></span><br><span class="line">    float4 worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">    o.worldPos = worldPos.xyz;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们对三个方向投影所对应的uv坐标进行UV变换。在这里我把世界坐标的<code>y</code>轴对应uv坐标的<code>v</code>，这样渲染出来的纹理就是正的。当然，你也可以随意尝试多种对应关系，看看会有什么不一样的效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//分别计算三个投影方向的uv变换</span></span><br><span class="line">    float2 uv_front = TRANSFORM_TEX(i.worldPos.xy, _MainTex);</span><br><span class="line">    float2 uv_side = TRANSFORM_TEX(i.worldPos.zy, _MainTex);</span><br><span class="line">    float2 uv_top = TRANSFORM_TEX(i.worldPos.xz, _MainTex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用变换后的uv值进行纹理采样，并将三个不同的采样值进行平均。当然你也可以直接求和，不过最终结果会显得非常亮。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分别对三个方向进行纹理采样</span></span><br><span class="line">fixed4 col_front = tex2D(_MainTex, uv_front);</span><br><span class="line">fixed4 col_side = tex2D(_MainTex, uv_side);</span><br><span class="line">fixed4 col_top = tex2D(_MainTex, uv_top);</span><br><span class="line"></span><br><span class="line"><span class="comment">//求平均值</span></span><br><span class="line">fixed4 col = (col_front + col_side + col_top) / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//叠加材质颜色</span></span><br><span class="line">col *= _Color;</span><br><span class="line"><span class="keyword">return</span> col;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/010/AllSides.png"></p>
<h2 id="Normals"><a href="#Normals" class="headerlink" title="Normals"></a>Normals</h2><p>到目前为止，你会发现整个材质表现的非常怪异，各种重影迭起，这是因为我们只是单纯的对三个方向的采样值进行平均。为了消除这种重影，我们可以根据不同的朝向，侧重显示对应朝向的采样值。表面朝向有个专业点的名称：法向向量。在我们的网格数据中就包含法向数据。因为一些特殊考虑，网格数据中的法向和顶点是一一对应的。</p>
<p>所以，我们首先要做的是在我们的输入结构体中加入法向变量，然后在顶点着色其中将其变换到世界坐标系，并且通过插值数据传入到片段着色器中参与后续的计算。这里之所以要变换到世界坐标系，是因为我们的纹理映射是基于世界坐标系的。换句话说，我们在进行计算时，应该保证空间数据的空间一致性。</p>
<p>其中将法向从模型坐标系变换到世界坐标系有些特殊。一般的顶点在两个坐标系之间转换是直接乘以模型矩阵，但是法向是乘以模型矩阵转置的逆矩阵。当然其中的矩阵推导比较复杂，我们记住这个结论就行。如果你好奇心很强，那我这里可以先定性地给你分析一下为什么不能直接乘以模型矩阵。前面说过，法向是垂直与表面的向量，假设我们将模型沿着<code>x</code>轴正方向拉伸，这时候表面相对于<code>y</code>轴会变得越来越陡，如果我们也对法向做同样的拉伸，你会发现法向也变得越来越陡，这时候法向和表面不再是垂直关系。我们这里描述的拉伸实际上就是一个空间变换的操作，因此法向和顶点不能使用同样的空间变换，否则将会打破两者的垂直关系。而模型矩阵转置的逆矩阵正是一种相反的操作，可以始终保持两者的垂直关系。当然我们还需要将该矩阵裁剪为<code>3X3</code>的矩阵，因为<code>4x4</code>矩阵还包含了平移变换，而我们的法向量最为方向是没有位置的概念的，所以需要剔除掉矩阵中的平移部分。</p>
<p>事实上，在实际的代码中，我们可能并不会直接使用模型矩阵转置的逆矩阵，而是会采用一些小巧的方法，尽可能的减少计算量。例如世界到模型的变换矩阵刚好等于模型矩阵的逆矩阵，同时向量与矩阵乘积的顺序调转，刚好可以替代转置操作。所以实际上我们可以用法向量左乘世界到模型的变换矩阵来计算在世界坐标系下的法向量。是不是很绕、很晕？那没办法，给你一张图自己去捂捂！<br><img src="https://www.ronja-tutorials.com/assets/images/posts/010/NormalScaling.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    float3 normal : NORMAL;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">    float4 position : SV_POSITION;</span><br><span class="line">    float3 worldPos : TEXCOORD0;</span><br><span class="line">    float3 normal : NORMAL;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    <span class="comment">//计算裁剪空间下的坐标</span></span><br><span class="line">    o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    <span class="comment">//计算世界空间下的坐标</span></span><br><span class="line">    float4 worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">    o.worldPos = worldPos.xyz;</span><br><span class="line">    <span class="comment">//计算世界空间下的法向量</span></span><br><span class="line">    float3 worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);<span class="comment">//再给你点提提示，向量在左叫左乘，后面是从世界到模型空间的变换矩阵</span></span><br><span class="line">    o.normal = normalize(worldNormal);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在学习渲染的过程中，记住可视化是我们的看家本领，所以很多时候都可以通过渲染后的表现效果来分析我们的计算过程。这里可以将法向量进行可视化，很简单就是直接将法向量当成颜色返回。所谓的高大上的可视化到咱这还不算一行代码的事，实在不行就多写两行！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fixed4(i.normal.xyz, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/010/Normals.png"></p>
<p>在得到世界空间下的法向后，我们还需要对法向取绝对值才能应用到后面的权重分配部分。因为法向作为方向向量其取值是在<code>[-1,1]</code>之间，这也是为什么前面的法向可视化中，朝着负轴向的表面颜色是黑色。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float3 weights = i.normal;</span><br><span class="line">weights = <span class="built_in">abs</span>(weights);</span><br></pre></td></tr></table></figure>

<p>法向的各个轴向值得大小表明了法向与各个轴向的重合程度。所以我们将权重的各个轴向值分别乘以前面三个投影方向的采样值，例如<code>xy</code>投影平面的投影方向是<code>z</code>轴，所以将其采样值乘以<code>z</code>轴的权重值，依次类推。</p>
<p>这里我们不需要做平均，因为我们并不是简单的将三个采样值进行相加。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/010/ZPlane.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在世界坐标系下的法向量当做权重值</span></span><br><span class="line">float3 weights = i.normal;</span><br><span class="line"><span class="comment">//取其绝对值</span></span><br><span class="line">weights = <span class="built_in">abs</span>(weights);</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘以权重值</span></span><br><span class="line">col_front *= weights.z;</span><br><span class="line">col_side *= weights.x;</span><br><span class="line">col_top *= weights.y;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求和</span></span><br><span class="line">fixed4 col = col_front + col_side + col_top;</span><br><span class="line"></span><br><span class="line"><span class="comment">//叠加材质的基本颜色</span></span><br><span class="line">col *= _Color;</span><br><span class="line"><span class="keyword">return</span> col;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/010/AddPlanes.jpg"></p>
<p>上图可以看到整个模型看你来更加凝实了，少了很多眼花缭乱的重影。但是还有一个问题，前面的例子中有一个求平均的过程，但是为甚么要求平均呢，因为求平均可以保证最终混合结果不会过亮。但是我们这里使用法向权重值之和会大概率会大于1,最终导致显示过亮。所以我么可以先除以权重和。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保证权重之和为 1</span></span><br><span class="line">weights = weights / (weights.x + weights.y + weights.z);</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/010/AddPlanesNormalized.jpg"></p>
<p>现在看起来和纹理原本的亮度差不多。</p>
<p>最后一步是尽可能的提高各个投影方向纹理的权重差异。因为上图的显示效果还是有很大一部分相互叠加。这是因为即便某个投影方向有权重优势，但这种优势并不是碾压式的，不能占有绝对比重。为了使强者越强、弱者越弱，指数函数是一个很好地选择。我们先定义一个表示指数的参数。然后在权重之前，对其各个分量执行指数操作。然后在材质面板上调节这个指数参数，观察显示变化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">_Sharpness(<span class="string">&quot;Blend Sharpness&quot;</span>, Range(<span class="number">1</span>, <span class="number">64</span>)) = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> _Sharpness;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指数操作，强者越强，弱者越弱</span></span><br><span class="line">weights = <span class="built_in">pow</span>(weights, _sharpness)</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/010/BlendSharpness.gif"></p>
<p>上面的三维平面映射效果还有些问题，表面45度的地方存在明显的过渡痕迹，不过这种痕迹的出现是由于纹理上下左右边界不衔接导致的。另外三维平面映射的性能消耗要更大，因为这里执行了三次纹理采样。</p>
<p>我们可以将三维平面映射应用在表面着色器上，例如对<code>albedo</code>进行三维平面映射，或者对<code>specular</code>等纹理。但是法向纹理需要额外的操作才行，因为我们在三维平面映射的过程中使用的法向向量，这里不做深入研究了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/010_Triplanar_Mapping&quot;</span>&#123;</span><br><span class="line">	<span class="comment">//材质面板显示的属性</span></span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">		_Sharpness (<span class="string">&quot;Blend sharpness&quot;</span>, Range(<span class="number">1</span>, <span class="number">64</span>)) = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		<span class="comment">//不透明物体</span></span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//纹理数据</span></span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">			fixed4 _Color;</span><br><span class="line">			<span class="keyword">float</span> _Sharpness;</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">				float3 worldPos : TEXCOORD0;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				<span class="comment">//计算裁剪空间坐标</span></span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				<span class="comment">//计算世界空间坐标</span></span><br><span class="line">				float4 worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">				o.worldPos = worldPos.xyz;</span><br><span class="line">				<span class="comment">//计算世界空间法向量</span></span><br><span class="line">				float3 worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);</span><br><span class="line">				o.normal = normalize(worldNormal);</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">				<span class="comment">//分别计算三个方向的uv变换</span></span><br><span class="line">				float2 uv_front = TRANSFORM_TEX(i.worldPos.xy, _MainTex);</span><br><span class="line">				float2 uv_side = TRANSFORM_TEX(i.worldPos.zy, _MainTex);</span><br><span class="line">				float2 uv_top = TRANSFORM_TEX(i.worldPos.xz, _MainTex);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//分别执行三个方向的纹理采样</span></span><br><span class="line">				fixed4 col_front = tex2D(_MainTex, uv_front);</span><br><span class="line">				fixed4 col_side = tex2D(_MainTex, uv_side);</span><br><span class="line">				fixed4 col_top = tex2D(_MainTex, uv_top);</span><br><span class="line"></span><br><span class="line">				<span class="comment">//将法向量当成权重</span></span><br><span class="line">				float3 weights = i.normal;</span><br><span class="line">				<span class="comment">//绝对值</span></span><br><span class="line">				weights = <span class="built_in">abs</span>(weights);</span><br><span class="line">				<span class="comment">//求权重指数</span></span><br><span class="line">				weights = <span class="built_in">pow</span>(weights, _Sharpness);</span><br><span class="line">				<span class="comment">//权重归一</span></span><br><span class="line">				weights = weights / (weights.x + weights.y + weights.z);</span><br><span class="line"></span><br><span class="line">				<span class="comment">//权重应用</span></span><br><span class="line">				col_front *= weights.z;</span><br><span class="line">				col_side *= weights.x;</span><br><span class="line">				col_top *= weights.y;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//求和</span></span><br><span class="line">				fixed4 col = col_front + col_side + col_top;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//应用基本颜色</span></span><br><span class="line">				col *= _Color;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack <span class="string">&quot;Standard&quot;</span> <span class="comment">//当当前着色器不支持时，选择后补着色器中的功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望本文能够帮助你理解什么是三维平面映射。</p>
<p>你可以在以下链接找到源码：<a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/010_Triplanar_Mapping/triplanar_mapping.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/010_Triplanar_Mapping/triplanar_mapping.shader</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/02/Ronja_Color_Interpolation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/02/Ronja_Color_Interpolation/" class="post-title-link" itemprop="url">Color Interpolation</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-02 11:01:00" itemprop="dateCreated datePublished" datetime="2021-07-02T11:01:00+08:00">2021-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-20 23:50:31" itemprop="dateModified" datetime="2022-09-20T23:50:31+08:00">2022-09-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/009-interpolating-colors/">Color Interpolation</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>很多时候，我们的模型需要使用多张纹理，并且同时应用这些纹理，例如地形材质。这时候我们需要通过一些插值的方法将这些纹理采集的颜色进行有效融合。</p>
<p>本教程是在上一个<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Sprite_Shaders/">图片着色器</a>的基础上实现的。但是你也可以根据其基本思路，以表面着色器的形式重写其功能。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/009/Result.png"></p>
<h2 id="Interpolate-Colors"><a href="#Interpolate-Colors" class="headerlink" title="Interpolate Colors"></a>Interpolate Colors</h2><p>首先，我们颜色混合着色器的第一个版本仅仅处理两个纯色之间的混合。因为这样我们就不需要考虑什么纹理、uv之类的。我们只需在加一个颜色变量、以及一个用于混合的参数，这个参数将决定两个颜色的混合权重，这里我们把它设为<code>Range</code>类，这样方便在材质面板上调节参数，同时确保参数的有效性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//材质面板上显示的属性</span></span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color (<span class="string">&quot;Color&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) <span class="comment">//the base color</span></span><br><span class="line">		_SecondaryColor (<span class="string">&quot;Secondary Color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>) <span class="comment">//the color to blend to</span></span><br><span class="line">		_Blend (<span class="string">&quot;Blend Value&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0</span> <span class="comment">//0 is the first color, 1 the second</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//混合参数，或权重</span></span><br><span class="line"><span class="keyword">float</span> _Blend;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于混合的两个颜色</span></span><br><span class="line">fixed4 _Color;</span><br><span class="line">fixed4 _SecondaryColor;</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">虽然我们没有使用纹理的颜色，但是也可以保留顶点着色器中关于UV变换的操作，下一个版本还会用到它。而作为第一个版本，我么只修改片段着色器就可以，直接根据混合参数，将第二种颜色叠加到原先的颜色上。</span><br><span class="line">```c++</span><br><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    fixed4 col = _Color + _SecondaryColor * _Blend;</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>!()[<a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/assets/images/posts/009/BlendColorsAdd.gif]">https://www.ronja-tutorials.com/assets/images/posts/009/BlendColorsAdd.gif]</a></p>
<p>现在我们可以看到混合后颜色的变化了，但是我们始终无法将其颜色完全过度到第二种颜色。这是因为混合参数只改变第二种颜色混入的颜色，而第一种颜色依然存在。</p>
<p>为了实现两种颜色之间的过渡渐变效果，我们需要保证两种颜色的权重和为1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    fixed4 col = _Color * (<span class="number">1</span> - _Blend) + _SecondaryColor * _Blend;</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/009/BlendColors.gif"></p>
<p>这种混合操作叫做线性插值，Unity内置的<code>lerp</code>函数就是实现这个线性插值功能。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    fixed4 col = lerp(_Color, _SecondaryColor, _Blend);</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终两个颜色间的混合着色器源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/009_Color_Blending/Plain&quot;</span>&#123;</span><br><span class="line">	<span class="comment">//材质面板上显示的属性</span></span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color (<span class="string">&quot;Color&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) <span class="comment">//基础颜色</span></span><br><span class="line">		_SecondaryColor (<span class="string">&quot;Secondary Color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>) <span class="comment">//用于混合的颜色</span></span><br><span class="line">		_Blend (<span class="string">&quot;Blend Value&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0</span> <span class="comment">//混合权重，0 表示只显示基础颜色, 1 表示只显示混合颜色</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		<span class="comment">//渲染不透明物体</span></span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="comment">//引入内置变量和函数</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//定义着色器函数</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//混合参数</span></span><br><span class="line">			<span class="keyword">float</span> _Blend;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//两个用于混合的颜色</span></span><br><span class="line">			fixed4 _Color;</span><br><span class="line">			fixed4 _SecondaryColor;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//输入的网格数据</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//中间插值的变量，由顶点着色器到片段着色器</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//顶点着色器</span></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				<span class="comment">//计算裁剪空间下的坐标</span></span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//片段着色器</span></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">				fixed4 col = lerp(_Color, _SecondaryColor, _Blend);</span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Interpolate-Textures"><a href="#Interpolate-Textures" class="headerlink" title="Interpolate Textures"></a>Interpolate Textures</h2><p>我们颜色混合着色器的第二个版本将考虑混合两张纹理贴图的颜色。首先我们删掉前面两个颜色变量，改成两个纹理变量。因为涉及到纹理，所以需要uv坐标来进行纹理采样。之前的纹理采样都执行了uv变换操作，实际上这一步并不是必须的，如果我们不打算缩放纹理的话，这一步就可以省略掉，与之相关的纹理参数也可以省掉。但是我们这里有两张纹理，每张纹理都打算使用各自的缩放参数，这时候可以在顶点着色器中执行uv变换，然后在传给片段着色器，也可以直接在片段着色器中进行uv变换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//材质面板上显示的属性</span></span><br><span class="line">Properties&#123;</span><br><span class="line">    _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; <span class="comment">//基础纹理颜色</span></span><br><span class="line">    _SecondaryTex (<span class="string">&quot;Secondary Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;black&quot;</span> &#123;&#125; <span class="comment">//用于混合的纹理颜色</span></span><br><span class="line">    _Blend (<span class="string">&quot;Blend Value&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0</span> <span class="comment">//混合权重，0 表示只显示基础颜色, 1 表示只显示混合颜色</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义着色器函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输入的网格数据</span></span><br><span class="line">struct appdata&#123;</span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    float2 uv : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中间插值的变量，由顶点着色器到片段着色器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">    float4 position : SV_POSITION;</span><br><span class="line">    float2 uv : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点着色器</span></span><br><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    <span class="comment">//计算裁剪空间下的坐标</span></span><br><span class="line">    o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>这里我们是在片段着色其中进行uv变换的。并且使用各自变换后的uv进行纹理采样。在得到采样颜色后，我们就可以和上一个版本一样进行线性插值了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//分别进行uv变换</span></span><br><span class="line">    float2 main_uv = TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">    float2 secondary_uv = TRANSFORM_TEX(i.uv, _SecondaryTex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分别进行纹理采样</span></span><br><span class="line">    fixed4 main_color = tex2D(_MainTex, main_uv);</span><br><span class="line">    fixed4 secondary_color = tex2D(_SecondaryTex, secondary_uv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最终执行线性插值</span></span><br><span class="line">    fixed4 col = lerp(main_color, secondary_color, _Blend);</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/009/BlendTextures.gif"></p>
<p>下面是我们这个图片混合着色器的完整脚本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/009_Color_Blending/Texture&quot;</span>&#123;</span><br><span class="line">	<span class="comment">//材质面板属性显示</span></span><br><span class="line">	Properties&#123;</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; <span class="comment">//第一张图</span></span><br><span class="line">		_SecondaryTex (<span class="string">&quot;Secondary Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;black&quot;</span> &#123;&#125; <span class="comment">//第二张图</span></span><br><span class="line">		_Blend (<span class="string">&quot;Blend Value&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0</span> <span class="comment">//0 表示只显示第一张图, 1 只显示第二张图</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		<span class="comment">//不透明材质</span></span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="comment">//引入内置变量和函数</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//定义着色器函数</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//混合参数</span></span><br><span class="line">			<span class="keyword">float</span> _Blend;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//两张图</span></span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">			sampler2D _SecondaryTex;</span><br><span class="line">			float4 _SecondaryTex_ST;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//输入的网格数据</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//中间的插值数据</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//顶点着色器</span></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				<span class="comment">//变换到裁剪空间</span></span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				o.uv = v.uv;</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//片段着色器</span></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">				<span class="comment">//各自进行uv变换</span></span><br><span class="line">				float2 main_uv = TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">				float2 secondary_uv = TRANSFORM_TEX(i.uv, _SecondaryTex);</span><br><span class="line"></span><br><span class="line">				<span class="comment">//各自进行纹理采样</span></span><br><span class="line">				fixed4 main_color = tex2D(_MainTex, main_uv);</span><br><span class="line">				fixed4 secondary_color = tex2D(_SecondaryTex, secondary_uv);</span><br><span class="line"></span><br><span class="line">				<span class="comment">//线性插值</span></span><br><span class="line">				fixed4 col = lerp(main_color, secondary_color, _Blend);</span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Interpolation-based-on-a-Texture"><a href="#Interpolation-based-on-a-Texture" class="headerlink" title="Interpolation based on a Texture"></a>Interpolation based on a Texture</h2><p>前面连个的混合参数都是一个统一的变量，这样模型表面每个区域的混合权重都一样。为了达到不同权重的混合效果，最后这个版本使用纹理来作为我们的混合参数。</p>
<p>首先我们是将原先的混合变量用一个纹理变量替代。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//材质面板属性</span></span><br><span class="line">Properties&#123;</span><br><span class="line">    _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; <span class="comment">//第一张图</span></span><br><span class="line">    _SecondaryTex (<span class="string">&quot;Secondary Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;black&quot;</span> &#123;&#125; <span class="comment">//第二张图</span></span><br><span class="line">    _BlendTex (<span class="string">&quot;Blend Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;grey&quot;</span> <span class="comment">//混合权重图</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//混合权重</span></span><br><span class="line">sampler2D _BlendTex;</span><br><span class="line">float4 _BlendTex_ST;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于混合的图</span></span><br><span class="line">sampler2D _MainTex;</span><br><span class="line">float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">sampler2D _SecondaryTex;</span><br><span class="line">float4 _SecondaryTex_ST;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>同样的，我们也对权重图进行uv变换，然后再进行采样。但是纹理采样的结果还是颜色，是一个向量，而我们的插值权重是一个标量，这时候我们可以选择其中一个合适的通道值来作为我们的插值权重。和前面一样，最后我们用这个权重值进行颜色插值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//分别进行uv变换</span></span><br><span class="line">    float2 main_uv = TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">    float2 secondary_uv = TRANSFORM_TEX(i.uv, _SecondaryTex);</span><br><span class="line">    float2 blend_uv = TRANSFORM_TEX(i.uv, _BlendTex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分别进行纹理采样</span></span><br><span class="line">    fixed4 main_color = tex2D(_MainTex, main_uv);</span><br><span class="line">    fixed4 secondary_color = tex2D(_SecondaryTex, secondary_uv);</span><br><span class="line">    fixed4 blend_color = tex2D(_BlendTex, blend_uv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选其中红色通道作为混合权重</span></span><br><span class="line">    fixed blend_value = blend_color.r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最终的颜色插值</span></span><br><span class="line">    fixed4 col = lerp(main_color, secondary_color, blend_value);</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/009/BlendWithTexture.png"></p>
<p>好了，下面是完整的着色器脚本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/009_Color_Blending/TextureBasedBlending&quot;</span>&#123;</span><br><span class="line">	<span class="comment">//材质面板上的属性</span></span><br><span class="line">	Properties&#123;</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; <span class="comment">//第一张图</span></span><br><span class="line">		_SecondaryTex (<span class="string">&quot;Secondary Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;black&quot;</span> &#123;&#125; <span class="comment">//第二张图</span></span><br><span class="line">		_BlendTex (<span class="string">&quot;Blend Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;grey&quot;</span> <span class="comment">//权重图</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		<span class="comment">//渲染不透明物体</span></span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="comment">//引入内置变量和函数</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//定义着色器函数</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//混合权重图</span></span><br><span class="line">			sampler2D _BlendTex;</span><br><span class="line">			float4 _BlendTex_ST;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//用于混合的两张纹理</span></span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">			sampler2D _SecondaryTex;</span><br><span class="line">			float4 _SecondaryTex_ST;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//输入的模型数据</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//中间的插值数据</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//顶点着色器</span></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				<span class="comment">//变换到裁剪空间</span></span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				o.uv = v.uv;</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//片段着色器</span></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">				<span class="comment">//分别进行uv变换</span></span><br><span class="line">				float2 main_uv = TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">				float2 secondary_uv = TRANSFORM_TEX(i.uv, _SecondaryTex);</span><br><span class="line">				float2 blend_uv = TRANSFORM_TEX(i.uv, _BlendTex);</span><br><span class="line"></span><br><span class="line">				<span class="comment">//分别进行纹理采样</span></span><br><span class="line">				fixed4 main_color = tex2D(_MainTex, main_uv);</span><br><span class="line">				fixed4 secondary_color = tex2D(_SecondaryTex, secondary_uv);</span><br><span class="line">				fixed4 blend_color = tex2D(_BlendTex, blend_uv);</span><br><span class="line"></span><br><span class="line">				<span class="comment">//选取一个通道作为混合权重</span></span><br><span class="line">				fixed blend_value = blend_color.r;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//最终的颜色插值</span></span><br><span class="line">				fixed4 col = lerp(main_color, secondary_color, blend_value);</span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望本文能让你了解着色器中颜色的基本使用、以及插值的实际应用。</p>
<p>所有的源码都在以下链接可以找到：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/009_Color_Blending/ColorBlending_Plain.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/009_Color_Blending/ColorBlending_Plain.shader</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/009_Color_Blending/ColorBlending_Texture.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/009_Color_Blending/ColorBlending_Texture.shader</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/009_Color_Blending/ColorBlending_TextureBasedBlending.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/009_Color_Blending/ColorBlending_TextureBasedBlending.shader</a></li>
</ul>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/02/Ronja_Planar_Mapping/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/02/Ronja_Planar_Mapping/" class="post-title-link" itemprop="url">Planar Mapping</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-02 10:01:00" itemprop="dateCreated datePublished" datetime="2021-07-02T10:01:00+08:00">2021-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-09-20 23:50:31" itemprop="dateModified" datetime="2022-09-20T23:50:31+08:00">2022-09-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/008-planar-mapping/">Planar Mapping</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>有时候我们的网格数据中并没有UV坐标，或者说器UV坐标并不适用于将要使用的纹理，或者我们想让纹理和模型表面根据某一规则对齐。或者还有其他什么原因，我们需要动态生成UV坐标。那么接下来的教程，我们将以最简单的方法，二维平面映射，来创建我们的UV坐标。</p>
<p>本教程是在上一个<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Sprite_Shaders/">图片着色器</a>的基础上实现的。但是你也可以根据其基本思路，以表面着色器的形式重写其功能。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/008/Result.png"></p>
<h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><p>首先我们将输入结构体中的uv变量删除掉，因为我们打算通过脚本生成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">    <span class="keyword">float</span> vertex : POSITION;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为片段着色器中的输入参数是由顶点着色器中的输出参数插值而得到的，因此我们选择在顶点着色器中计算新的uv值。首先我们将其顶点UV设置为顶点在模型坐标系下的<code>x</code>和<code>z</code>的值。这样足以让纹理出现在模型表面了，并且其效果看起来就好像是图片从上往下投影到模型表面一样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.uv = v.vertex.xz;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Adjustable-Tiling"><a href="#Adjustable-Tiling" class="headerlink" title="Adjustable Tiling"></a>Adjustable Tiling</h2><p>前面并没有考虑图片的缩放，或者我们可能希望图片显示不跟随模型一起旋转。</p>
<p>图片缩放的问题可以通过<code>TRANSFORM_TEX</code>宏来执行UV变换，这样最终用于纹理采样的UV可以跟随纹理缩放而相应改变。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.uv = TRANSFORM_TEX(v.vertex.xz, _MainTex);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/008/AdjustTilingOffset.gif"></p>
<h2 id="Texture-Coordinates-based-on-World-Position"><a href="#Texture-Coordinates-based-on-World-Position" class="headerlink" title="Texture Coordinates based on World Position"></a>Texture Coordinates based on World Position</h2><p>为了消除模型位置、和旋转对UV坐标的影响，我们需要将顶点坐标转换到世界坐标系，前面的例子是使用模型坐标系中的顶点坐标来生成UV坐标的。计算世界坐标的方法很简单，只需要将顶点坐标乘以模型空间矩阵。在我们得到世界坐标后，使用其世界坐标来生成UV坐标。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">	v2f o;</span><br><span class="line">	<span class="comment">//计算裁剪空间下的顶点坐标</span></span><br><span class="line">	o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">	<span class="comment">//计算世界空间下的顶点坐标</span></span><br><span class="line">	float4 worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">	<span class="comment">//应用纹理缩放，执行UV变换</span></span><br><span class="line">	o.uv = TRANSFORM_TEX(worldPos.xz, _MainTex);</span><br><span class="line">	<span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/008/MoveSphere.gif"></p>
<p>从上面我们也可以看到基于世界坐标的二维平面映射也不完美，因为我们必须使用可重复的图片，否则无法覆盖整个空间区域。而且最终用渲染出来的纹理也会因为观察角度不同而发生扭曲。但是我们可以使用更牛的技术来改进，例如后面将会介绍的,三维平面映射。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/008_Planar_Mapping&quot;</span>&#123;</span><br><span class="line">	<span class="comment">//材质面板上显示的属性</span></span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		<span class="comment">//渲染不透明物体</span></span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//定义公共变量</span></span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">			fixed4 _Color;</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				<span class="comment">//计算裁剪空间下的坐标</span></span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				<span class="comment">//计算世界空间下的坐标</span></span><br><span class="line">				float4 worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">				<span class="comment">//执行UV变换</span></span><br><span class="line">				o.uv = TRANSFORM_TEX(worldPos.xz, _MainTex);</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">				<span class="comment">//纹理采样</span></span><br><span class="line">				fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">				<span class="comment">//多个颜色叠加</span></span><br><span class="line">				col *= _Color;</span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack <span class="string">&quot;Standard&quot;</span> <span class="comment">//当当前着色器不支持时，选择后补着色器中的功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以在以下链接找到源码：<a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/008_Planar_Mapping/planar_mapping.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/008_Planar_Mapping/planar_mapping.shader</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blogs/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/blogs/">1</a><span class="space">&hellip;</span><a class="page-number" href="/blogs/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/blogs/page/5/">5</a><a class="page-number" href="/blogs/page/6/">6</a><a class="extend next" rel="next" href="/blogs/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Tyson Wu"
      src="/blogs/images/avatar.png">
  <p class="site-author-name" itemprop="name">Tyson Wu</p>
  <div class="site-description" itemprop="description">If you want, Just do it!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blogs/archives/">
        
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blogs/categories/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blogs/tags/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Tyson-Wu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Tyson-Wu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/zhao-wu-zhu-43" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;zhao-wu-zhu-43" rel="noopener" target="_blank"><i class="知乎 fa-fw"></i>知乎</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/Hi-blog/" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;Hi-blog&#x2F;" rel="noopener" target="_blank">starnight_cyber</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tyson Wu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blogs/lib/anime.min.js"></script>
  <script src="/blogs/lib/velocity/velocity.min.js"></script>
  <script src="/blogs/lib/velocity/velocity.ui.min.js"></script>

<script src="/blogs/js/utils.js"></script>

<script src="/blogs/js/motion.js"></script>


<script src="/blogs/js/schemes/pisces.js"></script>


<script src="/blogs/js/next-boot.js"></script>




  















  

  

</body>
</html>
