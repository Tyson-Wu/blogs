<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blogs/images/girl_180_0.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blogs/images/girl_32_0.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blogs/images/girl_16_0.png">
  <link rel="mask-icon" href="/blogs/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blogs/css/main.css">


<link rel="stylesheet" href="/blogs/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"tyson-wu.github.io","root":"/blogs/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="If you want, Just do it!">
<meta property="og:type" content="website">
<meta property="og:title" content="TysonWu&#39;s Blog">
<meta property="og:url" content="https://tyson-wu.github.io/blogs/page/3/index.html">
<meta property="og:site_name" content="TysonWu&#39;s Blog">
<meta property="og:description" content="If you want, Just do it!">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Tyson Wu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://tyson-wu.github.io/blogs/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>TysonWu's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blogs/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">TysonWu's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">AiCooXiao</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blogs/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blogs/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blogs/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blogs/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blogs/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/06/Ronja_Polygon_Clipping/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/06/Ronja_Polygon_Clipping/" class="post-title-link" itemprop="url">Polygon Clipping</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-06 12:01:00" itemprop="dateCreated datePublished" datetime="2021-07-06T12:01:00+08:00">2021-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-02 21:04:33" itemprop="dateModified" datetime="2022-08-02T21:04:33+08:00">2022-08-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/014-polygon-clipping/">Polygon Clipping</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>目前为止，我们接触的所有模型渲染都是基于多边形的。有人可能好奇，可不可以通过一系列顶点来实现对多边形的裁剪操作，这也是本文的重点。我将介绍如何在单<code>Pass</code>中的片段着色器函数中实现这个。当然关于裁剪还有其他的实现方案，例如通过将顶点构成的裁剪区域渲染到模板上，然后基于模板进行裁剪操作，但是本文不打算讨论它。</p>
<p>本文主要从技术角度来介绍器基本思路，并不会涉及到复杂的图形效果，所以这里我们以无光照的着色器来实现。关于无光照的着色器介绍可以参考<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Basic_Shader/">这里</a><br><img src="https://www.ronja-tutorials.com/assets/images/posts/014/Result.gif"></p>
<h2 id="Draw-Line"><a href="#Draw-Line" class="headerlink" title="Draw Line"></a>Draw Line</h2><p>首先我们需要顶点的世界坐标，就像前面关于<a href="https://tyson-wu.github.io/blogs/2021/07/02/Ronja_Planar_Mapping/">二维平面映射</a>中介绍的一样，将传入的模型顶点坐标乘以模型矩阵，然后将结果传递给片段着色器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中间插值结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">    float4 position : SV_POSITION;</span><br><span class="line">    float3 worldPos : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点着色器</span></span><br><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    <span class="comment">//计算裁剪坐标</span></span><br><span class="line">    o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    <span class="comment">//计算世界坐标</span></span><br><span class="line">    float4 worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">    o.worldPos = worldPos.xyz;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在片段着色器中，我们需要计算点与线的关系。因为我们后面要使用点来构造线，而两点确定一条线正是我们这里用到的一条基本规律。</p>
<p>为了确定点线之间的关系，我们需要借助两个向量，一是从直线上任意一点到该点的向量，二是直线的法向量。单纯的谈直线的法向量并没有太大意义，因为法向具有方向性，在二维空间有两个，在三维空间有无数个。但是这里我们想判定点是在线的左侧还是右侧，所以我们这里将法向量定义为垂直与直线，并指向直线左侧的向量。</p>
<p>当我们得到这两个向量后，这两个向量的点乘就可以用来判断点与线的关系。如果结果为正，说明在左侧，如果为负，说明在右侧，如果为零，说明在直线上。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/014/Vectors.png"></p>
<p>那么在着色器脚本中，我们首先定义直线上的两个点，然后计算上图中的三个向量。首先我们计算直线的方向，我们将第一个点减去第二个点所得到的方向向量作为直线的方向，然后将该向量旋转90度。接下来我们将直线外的那个点减去直线内的任意一个点。</p>
<p>然后我们将直线的法向量和目标点的向量做点乘，并将结果显示在屏幕上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">float2 linePoint1 = float2(<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">float2 linePoint2 = float2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算这三个向量</span></span><br><span class="line">float2 lineDirection = linePoint2 - linePoint1;</span><br><span class="line">float2 lineNormal = float2(-lineDirection.y, lineDirection.x);</span><br><span class="line">float2 toPos = i.worldPos.xy - linePoint1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算点与线的关系</span></span><br><span class="line"><span class="keyword">float</span> side = dot(toPos, lineNormal);</span><br><span class="line"><span class="comment">//以0为分界线，大于零取1，否则取0</span></span><br><span class="line"><span class="comment">//side = step(0, side);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> side;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/014/Distance.png"></p>
<p>上图中出现一条灰色的过渡带。但是这并不是我们所想要的。因为所有小于零的区域显示为纯黑，0到1之间的显示为灰色区域，大于1的显示为百色。因此我们可以使用<code>step</code>函数来讲中间灰度区域去掉。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以0为分界线，大于零取1，否则取0</span></span><br><span class="line"><span class="keyword">float</span> side = dot(toPos, lineNormal);</span><br><span class="line">side = step(<span class="number">0</span>, side);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> side;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/014/Line.png"></p>
<p>当我们再向其中加入一个点、两条线，就可以构成三角形了。因此我们将上面的判断逻辑抽成一个函数，方便复用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在左边返回1，否则返回0</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">isLeftOfLine</span><span class="params">(float2 pos, float2 linePoint1, float2 linePoint2)</span></span>&#123;</span><br><span class="line">    <span class="comment">//计算三个向量</span></span><br><span class="line">    float2 lineDirection = linePoint2 - linePoint1;</span><br><span class="line">    float2 lineNormal = float2(-lineDirection.y, lineDirection.x);</span><br><span class="line">    float2 toPos = pos - linePoint1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以0为分界线，大于零取1，否则取0</span></span><br><span class="line">    <span class="keyword">float</span> side = dot(toPos, lineNormal);</span><br><span class="line">    side = step(<span class="number">0</span>, side);</span><br><span class="line">    <span class="keyword">return</span> side;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    float2 linePoint1 = float2(<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    float2 linePoint2 = float2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    side = isLeftOfLine(i.worldPos.xy, linePoint1, linePoint2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> side;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Draw-a-Polygon-of-multiple-lines"><a href="#Draw-a-Polygon-of-multiple-lines" class="headerlink" title="Draw a Polygon of multiple lines"></a>Draw a Polygon of multiple lines</h2><p>前面已经抽取点与线的位置判断函数，这样我们可以对多边形的每一条边界线进行判定。然后将所有的判定结果结合起来，判定点与多边形的位置关系。例如我们可以定义当点在所有线的左侧时，为true，反之为false。或者我们可以定义在所有线的右侧时，为false，反之为true。这里我们定义的三角形为顺时针，这意味着线的左侧为三角形的外侧，我们可以将所有线条的判定结果求和，当全为左侧时，为零，否则大于零。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段作色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    float2 linePoint1 = float2(<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    float2 linePoint2 = float2(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    float2 linePoint3 = float2(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> outsideTriangle = isLeftOfLine(i.worldPos.xy, linePoint1, linePoint2);</span><br><span class="line">    outsideTriangle = outsideTriangle + isLeftOfLine(i.worldPos.xy, linePoint2, linePoint3);</span><br><span class="line">    outsideTriangle = outsideTriangle + isLeftOfLine(i.worldPos.xy, linePoint3, linePoint1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> outsideTriangle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/014/Triangle.png"></p>
<p>上面我们成功通过边界裁剪来实现多边形效果。现在我想通过材质面板来编辑这个裁剪区域。我们需要引入两个变量，一个是裁剪顶点列表，一个是顶点的个数。顶点列表记录的是我们裁剪区域的顶点位置。第二个是记录顶点的个数，因为着色器中不支持动态数组，所以我们需要定义一个固定数组，然后通过该变量来控制实际参与计算的顶点个数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶点数组和个数</span></span><br><span class="line">uniform float2 _corners[<span class="number">1000</span>];</span><br><span class="line">uniform uint _cornerCount;</span><br></pre></td></tr></table></figure>

<h2 id="Filling-the-Corner-Array"><a href="#Filling-the-Corner-Array" class="headerlink" title="Filling the Corner Array"></a>Filling the Corner Array</h2><p>材质面板并不支持数组显示。所以我们需要创建一个脚本组件来管理这个数组。这里我给新创建的脚本添加两个属性，并且将该脚本定义为编辑模式可执行，这样我们就不需要每次都启动程序了。另外，下面的脚本要求必须和渲染的裁剪多边形绑定，这样我们可以访问其中的材质。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ExecuteInEditMode</span>]</span><br><span class="line">[<span class="meta">RequireComponent(typeof(Renderer))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PolygonController</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是我们想脚本中加入两个变量，一个是裁剪着色器所需要的顶点数组，一个是绑定该着色器的材质。材质属性是私有的，因为我们是直接从当前绑定物体上获取的。顶点数组也是私有的，因为我们也不需要在外部访问，但是我们需要在组件面板上编辑它，所以需要<code>SerializeField</code>来标记它。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="keyword">private</span> Vector2[] corners;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Material _mat;</span><br></pre></td></tr></table></figure>

<p>然后我们实现一个函数将这些顶点数据传递给着色器。首先我们需要获取到当前物体的材质，这里我们使用<code>sharedmaterial</code>属性来获取材质，如果使用<code>material</code>属性的话，获取的将是该材质的副本。</p>
<p>然后我们再创建一个长度为1000的4维向量数组。之所以是4维而不是二维，因为Unity只支持向着色其中传递4为向量数组。而长度为1000是因为着色器中定义的是固定长度的数组。当然这里定义1000是假设我们会用到的顶点个数最大为1000，具有一定的随意性，你也可以根据实际需要调整。</p>
<p>当我们将二维向量赋值给四维向量时，为赋值的部分将会以0填充。</p>
<p>在准备好四维向量数组后，我们将其、以及实际的数组长度传递给着色器。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpdateMaterial</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//获取当前模型的材质</span></span><br><span class="line">    <span class="keyword">if</span>(_mat == <span class="literal">null</span>)</span><br><span class="line">        _mat = GetComponent&lt;Renderer&gt;().sharedMaterial;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//填充顶点位置数组</span></span><br><span class="line">    Vector4[] vec4Corners = <span class="keyword">new</span> Vector4[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;corners.Length;i++)&#123;</span><br><span class="line">        vec4Corners[i] = corners[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传递给着色器</span></span><br><span class="line">    _mat.SetVectorArray(<span class="string">&quot;_corners&quot;</span>, vec4Corners);</span><br><span class="line">    _mat.SetInt(<span class="string">&quot;_cornerCount&quot;</span>, corners.Length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下一步是在Unity事件函数中调用上面的函数。这里我们选择<code>Start</code>和<code>OnValidate</code>两个函数，前者在游戏启动时会调用一次，后者在每次修改组件属性面板上的值时会调用一次。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    UpdateMaterial();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnValidate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    UpdateMaterial();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>脚本编写完成后，将其以组件的形式赋给我们的裁剪物体。然后在组件属性面板上可以编辑需要的裁剪顶点。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/014/Inspector.png"></p>
<p>下面我们回到着色器脚本，然后在着色器中使用传入的顶点数组。</p>
<p>然后我们使用<code>for</code>循环来依次遍历这个顶点数组。因为在<code>hlsl</code>中，数组的起点是0，所以我们循环的起点也是0。循环的终止条件是超过实际的顶点个数。这里我们使用<code>for</code>循环来遍历。其实还可以将<code>for</code>循环展开，相比而言在显卡中的效率更高，但是我们需要提前知道循环次数才可以展开。这里我们的循环次数是可变的，所以只能使用<code>for</code>循环。</p>
<p>在循环中，我们计算所有的边界与点之间的关系，然后求和。而边界是由本次遍历的顶点和下次遍历的顶点构成的。但是这里有一个问题，就是最后的一个顶点的下一个顶点应该是第一个点的，所以这里我们可以使用求余来将索引值切回到起始点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> outsideTriangle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    [loop]</span><br><span class="line">    <span class="keyword">for</span>(uint index;index&lt;_cornerCount;index++)&#123;</span><br><span class="line">        outsideTriangle += isLeftOfLine(i.worldPos.xy, _corners[index], _corners[(index+<span class="number">1</span>) % _cornerCount]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> outsideTriangle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/014/Hexagon.png"></p>
<p>最终我们得到由六个点构成的裁剪区域。</p>
<h2 id="Clip-and-Color-the-Polygon"><a href="#Clip-and-Color-the-Polygon" class="headerlink" title="Clip and Color the Polygon"></a>Clip and Color the Polygon</h2><p>前面的步骤实际上是一个区域标记的过程，在区域内外都会进行渲染，只不过使用不同的颜色而已。有人可能想问，如何只渲染其中一部分，这样就可以向其中添加其他模型一同渲染。在<code>hlsl</code>中有一个放弃渲染的函数叫做<code>clip</code>。如果向<code>clip</code>传入的值小于0，那么将不会执行颜色写入的操作，否则的话正常渲染。</p>
<p>前面我们已经计算出区域标记，不过要么是0要么是1，都不小于0，因此我们还需要做一些转换才能将其中一部分渲染剔除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clip(-outsideTriangle);</span><br><span class="line"><span class="keyword">return</span> outsideTriangle;</span><br></pre></td></tr></table></figure>

<p><img src="https://www.ronja-tutorials.com/assets/images/posts/014/SuperHexagon.png"><br><img src="https://www.ronja-tutorials.com/assets/images/posts/014/ConcaveBreaking.gif"></p>
<p>这种裁剪方式有很大的缺陷，就是只能用来渲染凸多边形。ps:其实我觉得凹多边形也不影响。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/014_Polygon&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//属性面板</span></span><br><span class="line">    Properties&#123;</span><br><span class="line">        _Color (<span class="string">&quot;Color&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader&#123;</span><br><span class="line">        <span class="comment">//渲染不透明物体</span></span><br><span class="line">        Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">        Pass&#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="comment">//引入内置函数和变量</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//定义顶点和片段着色器</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            fixed4 _Color;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//用于裁剪的顶点数组</span></span><br><span class="line">            uniform float2 _corners[<span class="number">1000</span>];</span><br><span class="line">            uniform uint _cornerCount;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//模型网格数据</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//中间插值数据</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">                float4 position : SV_POSITION;</span><br><span class="line">                float3 worldPos : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//顶点着色器</span></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">//计算裁剪坐标</span></span><br><span class="line">                o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">//计算世界坐标</span></span><br><span class="line">                float4 worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">                o.worldPos = worldPos.xyz;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在左边返回1，否则返回0</span></span><br><span class="line">            <span class="function"><span class="keyword">float</span> <span class="title">isLeftOfLine</span><span class="params">(float2 pos, float2 linePoint1, float2 linePoint2)</span></span>&#123;</span><br><span class="line">                <span class="comment">//计算所需的三个向量</span></span><br><span class="line">                float2 lineDirection = linePoint2 - linePoint1;</span><br><span class="line">                float2 lineNormal = float2(-lineDirection.y, lineDirection.x);</span><br><span class="line">                float2 toPos = pos - linePoint1;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//以0为分界线，大于零取1，否则取0</span></span><br><span class="line">                <span class="keyword">float</span> side = dot(toPos, lineNormal);</span><br><span class="line">                side = step(<span class="number">0</span>, side);</span><br><span class="line">                <span class="keyword">return</span> side;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//片段着色器</span></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">float</span> outsideTriangle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                [loop]</span><br><span class="line">                <span class="keyword">for</span>(uint index;index&lt;_cornerCount;index++)&#123;</span><br><span class="line">                    outsideTriangle += isLeftOfLine(i.worldPos.xy, _corners[index], _corners[(index+<span class="number">1</span>) % _cornerCount]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                clip(-outsideTriangle);</span><br><span class="line">                <span class="keyword">return</span> _Color;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ExecuteInEditMode</span>]</span><br><span class="line">[<span class="meta">RequireComponent(typeof(Renderer))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PolygonController</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">	[<span class="meta">SerializeField</span>]</span><br><span class="line">	<span class="keyword">private</span> Vector2[] corners;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Material _mat;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		UpdateMaterial();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnValidate</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		UpdateMaterial();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">UpdateMaterial</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="comment">//获取当前模型所用的材质</span></span><br><span class="line">		<span class="keyword">if</span>(_mat == <span class="literal">null</span>)</span><br><span class="line">			_mat = GetComponent&lt;Renderer&gt;().sharedMaterial;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//填充顶点数组</span></span><br><span class="line">		Vector4[] vec4Corners = <span class="keyword">new</span> Vector4[<span class="number">1000</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;corners.Length;i++)&#123;</span><br><span class="line">			vec4Corners[i] = corners[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//传递给着色器</span></span><br><span class="line">		_mat.SetVectorArray(<span class="string">&quot;_corners&quot;</span>, vec4Corners);</span><br><span class="line">		_mat.SetInt(<span class="string">&quot;_cornerCount&quot;</span>, corners.Length);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望你能从这边文章中了解到如何处理点、线等多边形问题。也希望我所介绍到刚好是你想知道的！</p>
<p>你可以在以下链接找到源码：<br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/014_Polygon/Polygon.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/014_Polygon/Polygon.shader</a><br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/014_Polygon/PolygonController.cs">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/014_Polygon/PolygonController.cs</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/05/Ronja_Custom_Lighting/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/05/Ronja_Custom_Lighting/" class="post-title-link" itemprop="url">Custom Lighting</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-05 22:01:00" itemprop="dateCreated datePublished" datetime="2021-07-05T22:01:00+08:00">2021-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-02 21:04:33" itemprop="dateModified" datetime="2022-08-02T21:04:33+08:00">2022-08-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/013-custom-lighting/">Custom Lighting</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>表面着色器真的非常方便，特别是在处理光照时，表面着色器可以使用PBR模型快速实现物理光照效果。但是有时候我们可能想实现其他一些光照效果，例如卡通风格的。这时候我们可以使用自定义光照函数来满足我们的需求。</p>
<p>本篇主要介绍表面着色器特有的一些功能。但是光照处理的基本原理可以应用到其他着色器中。只不过Unity会为表面着色器生成一个基本的可复用的光照框架，如果我们使用其他着色器，那么必须手动补全这部分代码，但是这些并不是本文的重点，所以不做赘述。</p>
<p>如果你是一个初学者，建议你从<a href="https://tyson-wu.github.io/blogs/2021/06/25/Ronja_Structure/">第一章</a>开始看。</p>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/013/Result.png"></p>
<h2 id="Use-Custom-Lighting-Function"><a href="#Use-Custom-Lighting-Function" class="headerlink" title="Use Custom Lighting Function"></a>Use Custom Lighting Function</h2><p>首先我们需要将光照模型设置为我们自定义的光照函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表面着色器</span></span><br><span class="line"><span class="comment">//表面着色函数以及我们的自定义光照函数</span></span><br><span class="line"><span class="comment">//fullforwardshadows 应用所有的阴影Pass</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> surface surf Custom fullforwardShadows</span></span><br></pre></td></tr></table></figure>

<p>然后我们添加我们的自定义光照函数。光照函数的名字结构是<code>LightingX</code>，其中<code>X</code>是上面定义的光照函数，这里是<code>Custom</code>。在下面的自定义光照函数中使用的<code>SurfaceOutput</code>结构体，实际上是由<code>surf</code>表面着色器函数返回的数据，两者最终的数据结构必须一致。另外还有光照方向、以及光照衰减度，衰减度在后面会介绍。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义光照函数，针对每个光源都会处理一遍</span></span><br><span class="line"><span class="function">float4 <span class="title">LightingCustom</span><span class="params">(SurfaceOutput s, float3 lightDir, <span class="keyword">float</span> atten)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SurfaceOutput</code>和<code>SurfaceOutputSstandard</code>都是Unity预定义的数据结构，前者是针对非物理渲染的，后者是提供了物理渲染的基本参数。当然你也可以把他们当做是一个参考模板，然后实现自己的数据结构。使用的方法是，先在表面着色器函数中对该结构赋值，然后在自定义光照函数中使用。因为<code>SurfaceOutput</code>不包含光滑度、以及金属度的属性，所以在表面着色器删除对这两者的赋值。</p>
<p>//表面着色器<br>void surf (Input i, inout SurfaceOutput o) {<br>    //纹理采样<br>    fixed4 col = tex2D(_MainTex, i.uv_MainTex);<br>    col *= _Color;<br>    o.Albedo = col.rgb;</p>
<pre><code>//o.Emission = _Emission;</code></pre>
<p>}</p>
<p>现在我们有了自己的光照函数，但是该函数目前返回的是0，所以模型渲染后看不到光照效果。</p>
<p>按理说光照为零的话，整个模型应该是纯黑色，但是我们现在却能看清模型的基本轮廓。这是因为，光照函数处理的是直接光源，但是在模型渲染的时候除了直接光源，还有间接光源作用。其中环境光就是一种间接光源，Unity会自动将天空盒的颜色来当成环境光的一部分，所以我们在环境光的作用下还能看清物体。如果你在Unity编辑器的场景窗口上方选择关闭环境光的按钮，那么整个模型最终就会变成纯黑色，并且其最终显示都完全受我们的自定义光照函数控制。当然这里我保留Unity编辑器的默认设置。</p>
<h2 id="Implement-Lighting-Ramp"><a href="#Implement-Lighting-Ramp" class="headerlink" title="Implement Lighting Ramp"></a>Implement Lighting Ramp</h2><p>下面我们来实现简单的自定义光照函数。第一步我们先求解表面法向和入射光线方向向量的点乘，这两个参数正好在自定义光照函数的参数列表中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义光照函数</span></span><br><span class="line"><span class="function">float4 <span class="title">LightingCustom</span><span class="params">(SurfaceOutput s, float3 lightDir, <span class="keyword">float</span> atten)</span></span>&#123;</span><br><span class="line">    <span class="comment">//法向和光照入射方向的点乘，可以用来表示光照密度</span></span><br><span class="line">    <span class="keyword">float</span> towardsLight = dot(s.Normal, lightDir);</span><br><span class="line">    <span class="keyword">return</span> towardsLight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/013/DotLight.png"></p>
<p>下面我们实现的光照函数非常简单，涵盖了一般通用结构。我们使用光线入射向量来最为纹理纹理采样的参数，并将采样结果当成光源在该点的亮度。</p>
<p>因此我们必须将点乘结果的取值范围从<code>[-1, 1]</code>映射为<code>[0, 1]</code>，因为后者是UV的取值范围。</p>
<p>然后我们创建一个叫<code>ramp</code>的纹理变量。按照前面说的采样方法进行采样。然后在材质面板上设置纹理为半黑半白的图片。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//材质面板</span></span><br><span class="line">Properties &#123;</span><br><span class="line">    _Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    [HDR] _Emission (<span class="string">&quot;Emission&quot;</span>, color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    _Ramp (<span class="string">&quot;Toon Ramp&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">sampler2D _Ramp;</span><br></pre></td></tr></table></figure>

<p>下面是我们所用的<code>ramp</code>纹理。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/013/HardRamp.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义光照函数</span></span><br><span class="line"><span class="function">float4 <span class="title">LightingCustom</span><span class="params">(SurfaceOutput s, float3 lightDir, <span class="keyword">float</span> atten)</span></span>&#123;</span><br><span class="line">    <span class="comment">//入射光强</span></span><br><span class="line">    <span class="keyword">float</span> towardsLight = dot(s.Normal, lightDir);</span><br><span class="line">    <span class="comment">//数值区间映射</span></span><br><span class="line">    towardsLight = towardsLight * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//纹理采样</span></span><br><span class="line">    float3 lightIntensity = tex2D(_Ramp, towardsLight).rgb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> float4(lightIntensity, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/013/DrawRamp.png"></p>
<p>在上图中，模型背光面也能看清模型表面纹理。这还是因为环境光的影响。</p>
<p>为了让效果看起来更好，我们将模型颜色和光照密度相乘、同时应用衰减因子，最终的到一个具有颜色、且强度随距离变化的光源。模型最终的表现也和光源的颜色、和距离相关。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义光照</span></span><br><span class="line"><span class="function">float4 <span class="title">LightingCustom</span><span class="params">(SurfaceOutput s, float3 lightDir, <span class="keyword">float</span> atten)</span></span>&#123;</span><br><span class="line">    <span class="comment">//法向和光入射方向点乘</span></span><br><span class="line">    <span class="keyword">float</span> towardsLight = dot(s.Normal, lightDir);</span><br><span class="line">    <span class="comment">//数值范围映射</span></span><br><span class="line">    towardsLight = towardsLight * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//光强采样</span></span><br><span class="line">    float3 lightIntensity = tex2D(_Ramp, towardsLight).rgb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最终的颜色</span></span><br><span class="line">    float4 col;</span><br><span class="line">    <span class="comment">//应用光照</span></span><br><span class="line">    col.rgb = lightIntensity * s.Albedo * atten * _LightColor0.rgb;</span><br><span class="line">    <span class="comment">//赋值透明通道</span></span><br><span class="line">    col.a = s.Alpha; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/013/CorrectRampLighting.png"></p>
<p>上面已经介绍完了一个完整的自定义光照着色器的实现。我们可以使用不同的<code>ramp</code>纹理来得到完全不同的渲染风格。比如下面，我们采样冷暖色条纹，实现的卡通效果。图片源于<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/SL-SurfaceShaderLightingExamples.html">这里</a><br><img src="https://www.ronja-tutorials.com/assets/images/posts/013/HotColdRamp.png"><br><img src="https://www.ronja-tutorials.com/assets/images/posts/013/HotColdRampModel.png"></p>
<p>在着色器我们还有一个<code>emission</code>没有用到，但是模型最终的显示中却受自发光这个变量的影响。</p>
<p>上面这种卡通风格的着色器非常有用，在很多地方可以灵活运用。</p>
<p>自定义光照函数非常强大，但是只能用在前向渲染中。即便是你把渲染路径改为延迟渲染，最终渲染管线依然会把这部分的渲染转移到前向渲染路径中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/013_CustomSurfaceLighting&quot;</span> &#123;</span><br><span class="line">    <span class="comment">//材质面板</span></span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        [HDR] _Emission (<span class="string">&quot;Emission&quot;</span>, color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        _Ramp (<span class="string">&quot;Toon Ramp&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">//不透明物体</span></span><br><span class="line">        Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">        CGPROGRAM</span><br><span class="line"></span><br><span class="line">        <span class="comment">//表面着色器</span></span><br><span class="line">        <span class="comment">//自定义表面着色器函数、自定义光照函数</span></span><br><span class="line">        <span class="comment">//fullforwardshadows 使用所有的阴影Pass</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> surface surf Custom fullforwardshadows</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> target 3.0</span></span><br><span class="line"></span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line">        fixed4 _Color;</span><br><span class="line">        half3 _Emission;</span><br><span class="line"></span><br><span class="line">        sampler2D _Ramp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自定义光照函数</span></span><br><span class="line">        <span class="function">float4 <span class="title">LightingCustom</span><span class="params">(SurfaceOutput s, float3 lightDir, <span class="keyword">float</span> atten)</span></span>&#123;</span><br><span class="line">            <span class="comment">//点乘</span></span><br><span class="line">            <span class="keyword">float</span> towardsLight = dot(s.Normal, lightDir);</span><br><span class="line">            <span class="comment">//数值范围映射</span></span><br><span class="line">            towardsLight = towardsLight * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//采样</span></span><br><span class="line">            float3 lightIntensity = tex2D(_Ramp, towardsLight).rgb;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//最终的颜色</span></span><br><span class="line">            float4 col;</span><br><span class="line">            <span class="comment">//计算光照</span></span><br><span class="line">            col.rgb = lightIntensity * s.Albedo * atten * _LightColor0.rgb;</span><br><span class="line">            <span class="comment">//使用透明通道</span></span><br><span class="line">            col.a = s.Alpha; </span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> col;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输入结构体</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">            float2 uv_MainTex;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//表边着色器函数</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutput o)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//纹理采样</span></span><br><span class="line">            fixed4 col = tex2D(_MainTex, i.uv_MainTex);</span><br><span class="line">            col *= _Color;</span><br><span class="line">            o.Albedo = col.rgb;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//o.Emission = _Emission;</span></span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Standard&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望本篇能帮助你理解表面着色器和自定义光照。</p>
<p>你可以在以下链接找到源码：<br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/013_CustomSurfaceLighting/CustomLighting.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/013_CustomSurfaceLighting/CustomLighting.shader</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/05/Ronja_Fresnel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/05/Ronja_Fresnel/" class="post-title-link" itemprop="url">Fresnel</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-05 19:01:00" itemprop="dateCreated datePublished" datetime="2021-07-05T19:01:00+08:00">2021-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-02 21:04:33" itemprop="dateModified" datetime="2022-08-02T21:04:33+08:00">2022-08-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/012-fresnel/">Fresnel</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>菲涅尔效果是渲染中常用的效果。使用菲涅尔效果我们可以很方便的对模型的边缘进行增亮、加黑等边缘效果，加强场景的深度感。</p>
<p>本篇将采用表面着色器的实现方法，所以如果你对表面着色器还不了解的话，建议你先看看<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Surface_Shader_Basics/">这篇</a>文章。当然你也可以将菲涅尔效果应用到其他类型的着色器，来增强模型平滑度、或突出重点。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/012/Result.jpg"></p>
<h2 id="Highlighting-one-Side-of-the-Model"><a href="#Highlighting-one-Side-of-the-Model" class="headerlink" title="Highlighting one Side of the Model"></a>Highlighting one Side of the Model</h2><p>我们通过修改表面着色器来实现菲涅尔效果。菲涅尔效果是根据法向来计算效果的密度、或厚度。因为要在片段着色器中使用到世界坐标系中的法向量，所以我们首先在顶点着色器中计算好世界坐标系中的顶点法向，然后通过中间插值结构传递给片段着色器。当然，我们的输入结构体和中间插值结构体都需要定义法向量。</p>
<p>在<a href="https://tyson-wu.github.io/blogs/2021/07/02/Ronja_Triplanar_Mapping/">三维平面映射</a>我们介绍了如何计算顶点的世界法向量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入的模型网格数据，其中采用宏定义来定义部分数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">    float2 uv_MainTex;</span><br><span class="line">    float3 worldNormal;</span><br><span class="line">    INTERNAL_DATA</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以通过计算相邻向量之间的点乘，从而了解模型表明的平滑度、或者梯度。单位向量之间的点乘越大，说明它们方向越一致。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/012/DotSphere.png"><br><img src="https://www.ronja-tutorials.com/assets/images/posts/012/DotDirection.png"></p>
<p>首先，我将所有法向量与一个固定向量做点乘，可以让我们更容易理解点乘的意义。然后将点乘的结果传递给<code>emission</code>变量，将点乘结果通过自发光的形式表现出来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表面着色器函数，主要用了计算光照模型的输入参数，然后由光照模型进行最中的颜色计算</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//两个向量之间的点乘</span></span><br><span class="line">    <span class="keyword">float</span> fresnel = dot(i.worldNormal, float3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">//应用菲涅尔效果</span></span><br><span class="line">    o.Emission = _Emission + fresnel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/012/WhiteTopBlackBottom.png"></p>
<p>上图我们可以看到，越朝上的地方越亮、越朝下越暗。为了避免自发光出现负数，这里将菲涅尔值限定在<code>[0,1]</code>之间。这里有两个函数<code>staturate</code>和<code>clamp</code>都可以实现范围限定的功能，但是<code>staturate</code>在GPU上执行速度更快。下面是限定后的效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表面着色器函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算菲涅尔值</span></span><br><span class="line">    <span class="keyword">float</span> fresnel = dot(i.worldNormal, float3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">//限定为 0 - 1 之间</span></span><br><span class="line">    fresnel = saturate(fresnel);</span><br><span class="line">    <span class="comment">//应用菲尼尔效果</span></span><br><span class="line">    o.Emission = _Emission + fresnel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/012/WhiteTopBlackBottom.png"></p>
<h2 id="Highlighting-the-outer-Parts"><a href="#Highlighting-the-outer-Parts" class="headerlink" title="Highlighting the outer Parts"></a>Highlighting the outer Parts</h2><p>接下来我们使用视角方向来计算菲涅尔值。视角放向可以直接定义输入结构体中，然后在表面着色器函数中就可以访问。</p>
<p>如果是在无光照着色器中实现菲涅尔效果，那么视角方向可以通过摄像机的位置和顶点世界坐标来计算。其中摄像机坐标存储在<code>_WorldSpaceCameraPos</code>这个内置变量中，由Unity来赋值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表面着色器的输入结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">    float2 uv_MainTex;</span><br><span class="line">    float3 worldNormal;</span><br><span class="line">    float3 viewDir;</span><br><span class="line">    INTERNAL_DATA</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表面着色器函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//金属度与光滑度</span></span><br><span class="line">    o.Metallic = _Metallic;</span><br><span class="line">    o.Smoothness = _Smoothness;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//菲尼尔值</span></span><br><span class="line">    <span class="keyword">float</span> fresnel = dot(i.worldNormal, i.viewDir);</span><br><span class="line">    <span class="comment">//范围限定在 0 - 1</span></span><br><span class="line">    fresnel = saturate(fresnel);</span><br><span class="line">    <span class="comment">//应用菲涅尔值</span></span><br><span class="line">    o.Emission = _Emission + fresnel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/012/WhiteFront.png"></p>
<p>总体来说实现了菲涅尔效果，但是整个材质是靠近中心区域更亮，而不是边缘更亮。如果我们想让边缘更亮，我们可以将1减去菲涅尔值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表面着色器函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//菲涅尔值</span></span><br><span class="line">    <span class="keyword">float</span> fresnel = dot(i.worldNormal, i.viewDir);</span><br><span class="line">    <span class="comment">//效果反转</span></span><br><span class="line">    fresnel = saturate(<span class="number">1</span> - fresnel);</span><br><span class="line">    <span class="comment">//应用菲涅尔效果</span></span><br><span class="line">    o.Emission = _Emission + fresnel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/012/WhiteFresnel.png"></p>
<h2 id="Add-Fresnel-Color-and-Intensity"><a href="#Add-Fresnel-Color-and-Intensity" class="headerlink" title="Add Fresnel Color and Intensity"></a>Add Fresnel Color and Intensity</h2><p>最后，我想增加一些自定义属性，比如菲涅尔颜色。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">_FresnelColor (<span class="string">&quot;Fresnel Color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">float3 _FresnelColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//表面着色器函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//菲涅尔值</span></span><br><span class="line">    <span class="keyword">float</span> fresnel = dot(i.worldNormal, i.viewDir);</span><br><span class="line">    <span class="comment">//效果反转</span></span><br><span class="line">    fresnel = saturate(<span class="number">1</span> - fresnel);</span><br><span class="line">    <span class="comment">//使用菲涅尔自定义颜色</span></span><br><span class="line">    float3 fresnelColor = fresnel * _FresnelColor;</span><br><span class="line">    <span class="comment">//应用菲涅尔效果</span></span><br><span class="line">    o.Emission = _Emission + fresnelColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/012/Result.jpg"></p>
<p>然后再增加一个控制菲涅尔强度的属性。这里我们使用指数函数来调节菲涅尔强度。</p>
<p>因为指数函数计算消耗非常大，所以如果有其他方法能实现相同的效果，尽量不要使用指数函数。当然，指数函数用法简单、便捷，在设计效果的时候可以直接使用指数函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">[PowerSlider(<span class="number">4</span>)] _FresnelExponent (<span class="string">&quot;Fresnel Exponent&quot;</span>, Range(<span class="number">0.25</span>, <span class="number">4</span>)) = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> _FresnelExponent;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//表面着色器函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//菲涅尔值</span></span><br><span class="line">    <span class="keyword">float</span> fresnel = dot(i.worldNormal, i.viewDir);</span><br><span class="line">    <span class="comment">//效果反转</span></span><br><span class="line">    fresnel = saturate(<span class="number">1</span> - fresnel);</span><br><span class="line">    <span class="comment">//使用菲涅尔自定义颜色</span></span><br><span class="line">    float3 fresnelColor = fresnel * _FresnelColor;</span><br><span class="line">    <span class="comment">//强度调节</span></span><br><span class="line">    fresnel = <span class="built_in">pow</span>(fresnel, _FresnelExponent);</span><br><span class="line">    <span class="comment">//应用菲涅尔效果</span></span><br><span class="line">    o.Emission = _Emission + fresnelColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/012/ExponentAdjustment.gif"></p>
<p>菲涅尔效果除了用来突出轮廓外，还可以用来实现各种渐变效果，这里不展开，有兴趣可以自行尝试。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/012_Fresnel&quot;</span> &#123;</span><br><span class="line">    <span class="comment">//材质面板</span></span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Smoothness (<span class="string">&quot;Smoothness&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">        _Metallic (<span class="string">&quot;Metalness&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">        [HDR] _Emission (<span class="string">&quot;Emission&quot;</span>, color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        _FresnelColor (<span class="string">&quot;Fresnel Color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        [PowerSlider(<span class="number">4</span>)] _FresnelExponent (<span class="string">&quot;Fresnel Exponent&quot;</span>, Range(<span class="number">0.25</span>, <span class="number">4</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">//不透明物体</span></span><br><span class="line">        Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">        CGPROGRAM</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这是表面着色器，unity会自动生成部分代码</span></span><br><span class="line">        <span class="comment">//surf 是被定义为表面着色器函数</span></span><br><span class="line">        <span class="comment">//fullforwardshadows 告诉Unity将所有阴影Pass都复制过来</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> surface surf Standard fullforwardshadows</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> target 3.0</span></span><br><span class="line"></span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line">        fixed4 _Color;</span><br><span class="line"></span><br><span class="line">        half _Smoothness;</span><br><span class="line">        half _Metallic;</span><br><span class="line">        half3 _Emission;</span><br><span class="line"></span><br><span class="line">        float3 _FresnelColor;</span><br><span class="line">        <span class="keyword">float</span> _FresnelExponent;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//表面着色器的输入结构</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">            float2 uv_MainTex;</span><br><span class="line">            float3 worldNormal;</span><br><span class="line">            float3 viewDir;</span><br><span class="line">            INTERNAL_DATA</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//表面着色器函数，主要用来计算光照模型所需的参数</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//纹理采样</span></span><br><span class="line">            fixed4 col = tex2D(_MainTex, i.uv_MainTex);</span><br><span class="line">            col *= _Color;</span><br><span class="line">            o.Albedo = col.rgb;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//光滑度、和金属度</span></span><br><span class="line">            o.Metallic = _Metallic;</span><br><span class="line">            o.Smoothness = _Smoothness;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//菲涅尔值</span></span><br><span class="line">            <span class="keyword">float</span> fresnel = dot(i.worldNormal, i.viewDir);</span><br><span class="line">            <span class="comment">//效果翻转</span></span><br><span class="line">            fresnel = saturate(<span class="number">1</span> - fresnel);</span><br><span class="line">            <span class="comment">//控制菲涅尔强度</span></span><br><span class="line">            fresnel = <span class="built_in">pow</span>(fresnel, _FresnelExponent);</span><br><span class="line">            <span class="comment">//应用菲涅尔颜色</span></span><br><span class="line">            float3 fresnelColor = fresnel * _FresnelColor;</span><br><span class="line">            <span class="comment">//应用菲涅尔</span></span><br><span class="line">            o.Emission = _Emission + fresnelColor;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Standard&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望本篇能让你对菲涅尔效果有所了解。</p>
<p>你可以在以下链接找到源码：<a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/012_Fresnel/Fresnel.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/012_Fresnel/Fresnel.shader</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/05/Ronja_Checkerboard_Pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/05/Ronja_Checkerboard_Pattern/" class="post-title-link" itemprop="url">Checkerboard Pattern</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-05 13:01:00" itemprop="dateCreated datePublished" datetime="2021-07-05T13:01:00+08:00">2021-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-02 21:04:33" itemprop="dateModified" datetime="2022-08-02T21:04:33+08:00">2022-08-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/011-chessboard/">Checkerboard Pattern</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>我觉得使用着色器来生成图片比较有意思。下面我以棋盘格为例，像你们展示如何通过程序生成模型纹理的。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/011/Result.png"></p>
<h2 id="Stripes"><a href="#Stripes" class="headerlink" title="Stripes"></a>Stripes</h2><p>参考前面关于<a href="https://tyson-wu.github.io/blogs/2021/07/02/Ronja_Planar_Mapping/">二维平面映射</a>的教程，这里我们也是基于模型顶点的世界坐标来生成UV，这样的话，移动模型的过程中，其表面纹理在前后帧的渲染图可以无缝衔接。如果你希望生成的纹理跟随模型一起运动，那么可以选择基于模型坐标系进行计算。</p>
<p>首先，我们在顶点着色器中通过坐标变换，计算得到顶点的世界坐标，然后通过中间插值数据结构将计算结果传递到片段着色器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">    float4 position : SV_POSITION;</span><br><span class="line">    float3 worldPos : TEXCOORD0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    <span class="comment">//计算裁剪坐标</span></span><br><span class="line">    o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    <span class="comment">//计算世界坐标</span></span><br><span class="line">    o.worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在片段着色器中，我们首先考虑一个维度上的棋盘格效果，也就是黑白相间的条纹效果。方法很简单，就是选取世界坐标中的一个轴向的值，然后取整，两个整数之间的数取整后的结果是一样的，也就是说取整后的值代表了两个整数之间的区域，正是我们这个里的条纹效果。</p>
<p>然后我们要区分条纹的奇偶顺序，因为两个相邻的条纹刚好可以用两个相邻的整数来表示，所以只需要求其整数的奇偶性。求一个整数的奇偶性，可以通过对2的求余操作来实现。然后通过奇偶性来判断其颜色。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//选择x轴的值取整</span></span><br><span class="line">    <span class="keyword">float</span> chessboard = <span class="built_in">floor</span>(i.worldPos.x);</span><br><span class="line">    <span class="comment">//计算余数的一半</span></span><br><span class="line">    chessboard = frac(chessboard * <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">//计算余数</span></span><br><span class="line">    chessboard *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> chessboard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/011/1d.png"></p>
<h2 id="Checkerboard-in-2d-and-3d"><a href="#Checkerboard-in-2d-and-3d" class="headerlink" title="Checkerboard in 2d and 3d"></a>Checkerboard in 2d and 3d</h2><p>接下来，我们处理两个轴向的棋盘格。按照前面的操作，另外在选一个轴向进行计算，这时候分别知道两个轴的奇偶性，然后两个奇偶值相加，再求一遍奇偶性，得到最终格子的颜色。实际上可以进一步优化，可以直接在取整之后就求和，然后后面的奇偶求解可以合并。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//合并两个轴向</span></span><br><span class="line">    <span class="keyword">float</span> chessboard = <span class="built_in">floor</span>(i.worldPos.x) + <span class="built_in">floor</span>(i.worldPos.y);</span><br><span class="line">    <span class="comment">//计算余数的一半</span></span><br><span class="line">    chessboard = frac(chessboard * <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">//计算余数</span></span><br><span class="line">    chessboard *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> chessboard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/011/OddEvenPattern.png"><br><img src="https://www.ronja-tutorials.com/assets/images/posts/011/2d.png"></p>
<p>我们还可以进一步扩展到三个轴。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//合并三个轴向</span></span><br><span class="line">    <span class="keyword">float</span> chessboard = <span class="built_in">floor</span>(i.worldPos.x) + <span class="built_in">floor</span>(i.worldPos.y) + <span class="built_in">floor</span>(i.worldPos.z);</span><br><span class="line">    <span class="comment">//计算余数的一半</span></span><br><span class="line">    chessboard = frac(chessboard * <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">//计算余数</span></span><br><span class="line">    chessboard *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> chessboard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/011/3d.png"></p>
<h2 id="Scaling"><a href="#Scaling" class="headerlink" title="Scaling"></a>Scaling</h2><p>下面我们再给棋盘格增加一个缩放功能。我们需要在材质面板上引入缩放变量，方便后续调参。然后在片段着色器中，先将世界坐标处以这个缩放参数，然后在执行上面的操作。这样我们在材质面板上减小缩放变量时，棋盘格的大小也会变小。</p>
<p>除此之外，这里还有一个细微的改变，就是我们不再是对各个轴向分开取整，而是直接采样向量的方法，同时对所有轴向进行求整。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//材质面板属性</span></span><br><span class="line">Properties&#123;</span><br><span class="line">    _Scale (<span class="string">&quot;Pattern Size&quot;</span>, Range(<span class="number">0</span>,<span class="number">10</span>)) = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> _Scale;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//使用向量方法对各个轴向同时取整</span></span><br><span class="line">    float3 adjustedWorldPos = <span class="built_in">floor</span>(i.worldPos / _Scale);</span><br><span class="line">    <span class="comment">//各个轴向求和</span></span><br><span class="line">    <span class="keyword">float</span> chessboard = adjustedWorldPos.x + adjustedWorldPos.y + adjustedWorldPos.z;</span><br><span class="line">    <span class="comment">//计算余数的一半</span></span><br><span class="line">    chessboard = frac(chessboard * <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">//计算余数</span></span><br><span class="line">    chessboard *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> chessboard;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/011/Scaling.gif"></p>
<h2 id="Customizable-Colors"><a href="#Customizable-Colors" class="headerlink" title="Customizable Colors"></a>Customizable Colors</h2><p>最后，我们还可以增加两个变量来控制棋盘格的颜色。在片段着色器的最后我使用线性插值函数来实现两种颜色的二选一操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//材质面板</span></span><br><span class="line">Properties&#123;</span><br><span class="line">    _Scale (<span class="string">&quot;Pattern Size&quot;</span>, Range(<span class="number">0</span>,<span class="number">10</span>)) = <span class="number">1</span></span><br><span class="line">    _EvenColor(<span class="string">&quot;Color 1&quot;</span>, Color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    _OddColor(<span class="string">&quot;Color 2&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">float4 _EvenColor;</span><br><span class="line">float4 _OddColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//同时取整</span></span><br><span class="line">    float3 adjustedWorldPos = <span class="built_in">floor</span>(i.worldPos / _Scale);</span><br><span class="line">    <span class="comment">//三个维度求和</span></span><br><span class="line">    <span class="keyword">float</span> chessboard = adjustedWorldPos.x + adjustedWorldPos.y + adjustedWorldPos.z;</span><br><span class="line">    <span class="comment">//计算余数的一半</span></span><br><span class="line">    chessboard = frac(chessboard * <span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">//计算余数</span></span><br><span class="line">    chessboard *= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二选一操作</span></span><br><span class="line">    float4 color = lerp(_EvenColor, _OddColor, chessboard);</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/011/colors.png"></p>
<p>下面是最终的棋盘格生成着色器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/011_Chessboard&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//材质面板</span></span><br><span class="line">    Properties&#123;</span><br><span class="line">        _Scale (<span class="string">&quot;Pattern Size&quot;</span>, Range(<span class="number">0</span>,<span class="number">10</span>)) = <span class="number">1</span></span><br><span class="line">        _EvenColor(<span class="string">&quot;Color 1&quot;</span>, Color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        _OddColor(<span class="string">&quot;Color 2&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader&#123;</span><br><span class="line">        <span class="comment">//不透明物体</span></span><br><span class="line">        Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Pass&#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> _Scale;</span><br><span class="line"></span><br><span class="line">            float4 _EvenColor;</span><br><span class="line">            float4 _OddColor;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">                float4 position : SV_POSITION;</span><br><span class="line">                float3 worldPos : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">//计算裁剪坐标</span></span><br><span class="line">                o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                <span class="comment">//计算世界坐标</span></span><br><span class="line">                o.worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">                <span class="comment">//同时取整</span></span><br><span class="line">                float3 adjustedWorldPos = <span class="built_in">floor</span>(i.worldPos / _Scale);</span><br><span class="line">                <span class="comment">//求和</span></span><br><span class="line">                <span class="keyword">float</span> chessboard = adjustedWorldPos.x + adjustedWorldPos.y + adjustedWorldPos.z;</span><br><span class="line">                <span class="comment">//计算余数的一半</span></span><br><span class="line">                chessboard = frac(chessboard * <span class="number">0.5</span>);</span><br><span class="line">                <span class="comment">//计算余数</span></span><br><span class="line">                chessboard *= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//二选一插值</span></span><br><span class="line">                float4 color = lerp(_EvenColor, _OddColor, chessboard);</span><br><span class="line">                <span class="keyword">return</span> color;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Standard&quot;</span> <span class="comment">//后补着色器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望本篇对你有所帮助，能够让你知道如何通过程序实现模型纹理图。</p>
<p>你可以在以下链接找到源码：<a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/011_ChessBoard/Chessboard.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/011_ChessBoard/Chessboard.shader</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/02/Ronja_Triplanar_Mapping/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/02/Ronja_Triplanar_Mapping/" class="post-title-link" itemprop="url">Triplanar Mapping</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-02 13:01:00" itemprop="dateCreated datePublished" datetime="2021-07-02T13:01:00+08:00">2021-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-02 21:04:33" itemprop="dateModified" datetime="2022-08-02T21:04:33+08:00">2022-08-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/010-triplanar-mapping/">Triplanar Mapping</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>在前面我们介绍过二维平面映射的实现方法，这里我们来讲讲三维平面的映射方法。<br>纳尼？平面本身是二维的叫二维平面还可以理解，你这来个三维平面，是欺负我读书少，想糊弄我？？？<br>稍安勿躁！首先专业名字本身依据其专业用途、含义来取的，很容易和我们习惯相冲突，比如数学领域各种眼花缭乱的术语。这里我们的三维平面更多的值得是三维空间上的平面，可以有三个维度的取值。之前提到的二维平面映射，是只从一个方向进行投影，换句话说，我们只用沿着其投影方向进行渲染，才能看到我们的纹理贴合在模型表面，如果换个角度，你可能就看不到了，即便看到了也可能是模糊不清的。而三维平面映射，是从分别从三个维度进行投影映射，然后将得到的三个纹理颜色进行混合，这样无论我们采用怎样刁钻的角度，也挑不出啥毛病。</p>
<p>当然，本文也是在之前的二维平面映射的基础上扩展的，在了解其原理后，你也可以使用表面着色器重写一遍。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/010/Result.gif"></p>
<h2 id="Calcualte-Projection-Planes"><a href="#Calcualte-Projection-Planes" class="headerlink" title="Calcualte Projection Planes"></a>Calcualte Projection Planes</h2><p>首先，为了得到三个不同方向的UV坐标，我们需要改变UV坐标的生成方式。在二维平面映射中，我们是在顶点着色器中进行UV变换。这里我们直接将顶点的世界坐标传递到片段着色器中，然后在片段着色器中进行uv变换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">    float4 position : SV_POSITION;</span><br><span class="line">    float3 worldPos : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    <span class="comment">//计算裁剪空间坐标</span></span><br><span class="line">    o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    <span class="comment">//计算世界坐标</span></span><br><span class="line">    float4 worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">    o.worldPos = worldPos.xyz;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们对三个方向投影所对应的uv坐标进行UV变换。在这里我把世界坐标的<code>y</code>轴对应uv坐标的<code>v</code>，这样渲染出来的纹理就是正的。当然，你也可以随意尝试多种对应关系，看看会有什么不一样的效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//分别计算三个投影方向的uv变换</span></span><br><span class="line">    float2 uv_front = TRANSFORM_TEX(i.worldPos.xy, _MainTex);</span><br><span class="line">    float2 uv_side = TRANSFORM_TEX(i.worldPos.zy, _MainTex);</span><br><span class="line">    float2 uv_top = TRANSFORM_TEX(i.worldPos.xz, _MainTex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用变换后的uv值进行纹理采样，并将三个不同的采样值进行平均。当然你也可以直接求和，不过最终结果会显得非常亮。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分别对三个方向进行纹理采样</span></span><br><span class="line">fixed4 col_front = tex2D(_MainTex, uv_front);</span><br><span class="line">fixed4 col_side = tex2D(_MainTex, uv_side);</span><br><span class="line">fixed4 col_top = tex2D(_MainTex, uv_top);</span><br><span class="line"></span><br><span class="line"><span class="comment">//求平均值</span></span><br><span class="line">fixed4 col = (col_front + col_side + col_top) / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//叠加材质颜色</span></span><br><span class="line">col *= _Color;</span><br><span class="line"><span class="keyword">return</span> col;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/010/AllSides.png"></p>
<h2 id="Normals"><a href="#Normals" class="headerlink" title="Normals"></a>Normals</h2><p>到目前为止，你会发现整个材质表现的非常怪异，各种重影迭起，这是因为我们只是单纯的对三个方向的采样值进行平均。为了消除这种重影，我们可以根据不同的朝向，侧重显示对应朝向的采样值。表面朝向有个专业点的名称：法向向量。在我们的网格数据中就包含法向数据。因为一些特殊考虑，网格数据中的法向和顶点是一一对应的。</p>
<p>所以，我们首先要做的是在我们的输入结构体中加入法向变量，然后在顶点着色其中将其变换到世界坐标系，并且通过插值数据传入到片段着色器中参与后续的计算。这里之所以要变换到世界坐标系，是因为我们的纹理映射是基于世界坐标系的。换句话说，我们在进行计算时，应该保证空间数据的空间一致性。</p>
<p>其中将法向从模型坐标系变换到世界坐标系有些特殊。一般的顶点在两个坐标系之间转换是直接乘以模型矩阵，但是法向是乘以模型矩阵转置的逆矩阵。当然其中的矩阵推导比较复杂，我们记住这个结论就行。如果你好奇心很强，那我这里可以先定性地给你分析一下为什么不能直接乘以模型矩阵。前面说过，法向是垂直与表面的向量，假设我们将模型沿着<code>x</code>轴正方向拉伸，这时候表面相对于<code>y</code>轴会变得越来越陡，如果我们也对法向做同样的拉伸，你会发现法向也变得越来越陡，这时候法向和表面不再是垂直关系。我们这里描述的拉伸实际上就是一个空间变换的操作，因此法向和顶点不能使用同样的空间变换，否则将会打破两者的垂直关系。而模型矩阵转置的逆矩阵正是一种相反的操作，可以始终保持两者的垂直关系。当然我们还需要将该矩阵裁剪为<code>3X3</code>的矩阵，因为<code>4x4</code>矩阵还包含了平移变换，而我们的法向量最为方向是没有位置的概念的，所以需要剔除掉矩阵中的平移部分。</p>
<p>事实上，在实际的代码中，我们可能并不会直接使用模型矩阵转置的逆矩阵，而是会采用一些小巧的方法，尽可能的减少计算量。例如世界到模型的变换矩阵刚好等于模型矩阵的逆矩阵，同时向量与矩阵乘积的顺序调转，刚好可以替代转置操作。所以实际上我们可以用法向量左乘世界到模型的变换矩阵来计算在世界坐标系下的法向量。是不是很绕、很晕？那没办法，给你一张图自己去捂捂！<br><img src="https://www.ronja-tutorials.com/assets/images/posts/010/NormalScaling.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    float3 normal : NORMAL;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">    float4 position : SV_POSITION;</span><br><span class="line">    float3 worldPos : TEXCOORD0;</span><br><span class="line">    float3 normal : NORMAL;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    <span class="comment">//计算裁剪空间下的坐标</span></span><br><span class="line">    o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    <span class="comment">//计算世界空间下的坐标</span></span><br><span class="line">    float4 worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">    o.worldPos = worldPos.xyz;</span><br><span class="line">    <span class="comment">//计算世界空间下的法向量</span></span><br><span class="line">    float3 worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);<span class="comment">//再给你点提提示，向量在左叫左乘，后面是从世界到模型空间的变换矩阵</span></span><br><span class="line">    o.normal = normalize(worldNormal);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在学习渲染的过程中，记住可视化是我们的看家本领，所以很多时候都可以通过渲染后的表现效果来分析我们的计算过程。这里可以将法向量进行可视化，很简单就是直接将法向量当成颜色返回。所谓的高大上的可视化到咱这还不算一行代码的事，实在不行就多写两行！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fixed4(i.normal.xyz, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/010/Normals.png"></p>
<p>在得到世界空间下的法向后，我们还需要对法向取绝对值才能应用到后面的权重分配部分。因为法向作为方向向量其取值是在<code>[-1,1]</code>之间，这也是为什么前面的法向可视化中，朝着负轴向的表面颜色是黑色。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float3 weights = i.normal;</span><br><span class="line">weights = <span class="built_in">abs</span>(weights);</span><br></pre></td></tr></table></figure>

<p>法向的各个轴向值得大小表明了法向与各个轴向的重合程度。所以我们将权重的各个轴向值分别乘以前面三个投影方向的采样值，例如<code>xy</code>投影平面的投影方向是<code>z</code>轴，所以将其采样值乘以<code>z</code>轴的权重值，依次类推。</p>
<p>这里我们不需要做平均，因为我们并不是简单的将三个采样值进行相加。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/010/ZPlane.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在世界坐标系下的法向量当做权重值</span></span><br><span class="line">float3 weights = i.normal;</span><br><span class="line"><span class="comment">//取其绝对值</span></span><br><span class="line">weights = <span class="built_in">abs</span>(weights);</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘以权重值</span></span><br><span class="line">col_front *= weights.z;</span><br><span class="line">col_side *= weights.x;</span><br><span class="line">col_top *= weights.y;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求和</span></span><br><span class="line">fixed4 col = col_front + col_side + col_top;</span><br><span class="line"></span><br><span class="line"><span class="comment">//叠加材质的基本颜色</span></span><br><span class="line">col *= _Color;</span><br><span class="line"><span class="keyword">return</span> col;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/010/AddPlanes.jpg"></p>
<p>上图可以看到整个模型看你来更加凝实了，少了很多眼花缭乱的重影。但是还有一个问题，前面的例子中有一个求平均的过程，但是为甚么要求平均呢，因为求平均可以保证最终混合结果不会过亮。但是我们这里使用法向权重值之和会大概率会大于1,最终导致显示过亮。所以我么可以先除以权重和。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保证权重之和为 1</span></span><br><span class="line">weights = weights / (weights.x + weights.y + weights.z);</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/010/AddPlanesNormalized.jpg"></p>
<p>现在看起来和纹理原本的亮度差不多。</p>
<p>最后一步是尽可能的提高各个投影方向纹理的权重差异。因为上图的显示效果还是有很大一部分相互叠加。这是因为即便某个投影方向有权重优势，但这种优势并不是碾压式的，不能占有绝对比重。为了使强者越强、弱者越弱，指数函数是一个很好地选择。我们先定义一个表示指数的参数。然后在权重之前，对其各个分量执行指数操作。然后在材质面板上调节这个指数参数，观察显示变化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">_Sharpness(<span class="string">&quot;Blend Sharpness&quot;</span>, Range(<span class="number">1</span>, <span class="number">64</span>)) = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> _Sharpness;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指数操作，强者越强，弱者越弱</span></span><br><span class="line">weights = <span class="built_in">pow</span>(weights, _sharpness)</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/010/BlendSharpness.gif"></p>
<p>上面的三维平面映射效果还有些问题，表面45度的地方存在明显的过渡痕迹，不过这种痕迹的出现是由于纹理上下左右边界不衔接导致的。另外三维平面映射的性能消耗要更大，因为这里执行了三次纹理采样。</p>
<p>我们可以将三维平面映射应用在表面着色器上，例如对<code>albedo</code>进行三维平面映射，或者对<code>specular</code>等纹理。但是法向纹理需要额外的操作才行，因为我们在三维平面映射的过程中使用的法向向量，这里不做深入研究了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/010_Triplanar_Mapping&quot;</span>&#123;</span><br><span class="line">	<span class="comment">//材质面板显示的属性</span></span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">		_Sharpness (<span class="string">&quot;Blend sharpness&quot;</span>, Range(<span class="number">1</span>, <span class="number">64</span>)) = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		<span class="comment">//不透明物体</span></span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//纹理数据</span></span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">			fixed4 _Color;</span><br><span class="line">			<span class="keyword">float</span> _Sharpness;</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">				float3 worldPos : TEXCOORD0;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				<span class="comment">//计算裁剪空间坐标</span></span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				<span class="comment">//计算世界空间坐标</span></span><br><span class="line">				float4 worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">				o.worldPos = worldPos.xyz;</span><br><span class="line">				<span class="comment">//计算世界空间法向量</span></span><br><span class="line">				float3 worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);</span><br><span class="line">				o.normal = normalize(worldNormal);</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">				<span class="comment">//分别计算三个方向的uv变换</span></span><br><span class="line">				float2 uv_front = TRANSFORM_TEX(i.worldPos.xy, _MainTex);</span><br><span class="line">				float2 uv_side = TRANSFORM_TEX(i.worldPos.zy, _MainTex);</span><br><span class="line">				float2 uv_top = TRANSFORM_TEX(i.worldPos.xz, _MainTex);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//分别执行三个方向的纹理采样</span></span><br><span class="line">				fixed4 col_front = tex2D(_MainTex, uv_front);</span><br><span class="line">				fixed4 col_side = tex2D(_MainTex, uv_side);</span><br><span class="line">				fixed4 col_top = tex2D(_MainTex, uv_top);</span><br><span class="line"></span><br><span class="line">				<span class="comment">//将法向量当成权重</span></span><br><span class="line">				float3 weights = i.normal;</span><br><span class="line">				<span class="comment">//绝对值</span></span><br><span class="line">				weights = <span class="built_in">abs</span>(weights);</span><br><span class="line">				<span class="comment">//求权重指数</span></span><br><span class="line">				weights = <span class="built_in">pow</span>(weights, _Sharpness);</span><br><span class="line">				<span class="comment">//权重归一</span></span><br><span class="line">				weights = weights / (weights.x + weights.y + weights.z);</span><br><span class="line"></span><br><span class="line">				<span class="comment">//权重应用</span></span><br><span class="line">				col_front *= weights.z;</span><br><span class="line">				col_side *= weights.x;</span><br><span class="line">				col_top *= weights.y;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//求和</span></span><br><span class="line">				fixed4 col = col_front + col_side + col_top;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//应用基本颜色</span></span><br><span class="line">				col *= _Color;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack <span class="string">&quot;Standard&quot;</span> <span class="comment">//当当前着色器不支持时，选择后补着色器中的功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望本文能够帮助你理解什么是三维平面映射。</p>
<p>你可以在以下链接找到源码：<a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/010_Triplanar_Mapping/triplanar_mapping.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/010_Triplanar_Mapping/triplanar_mapping.shader</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/02/Ronja_Color_Interpolation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/02/Ronja_Color_Interpolation/" class="post-title-link" itemprop="url">Color Interpolation</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-02 11:01:00" itemprop="dateCreated datePublished" datetime="2021-07-02T11:01:00+08:00">2021-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-02 21:04:33" itemprop="dateModified" datetime="2022-08-02T21:04:33+08:00">2022-08-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/009-interpolating-colors/">Color Interpolation</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>很多时候，我们的模型需要使用多张纹理，并且同时应用这些纹理，例如地形材质。这时候我们需要通过一些插值的方法将这些纹理采集的颜色进行有效融合。</p>
<p>本教程是在上一个<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Sprite_Shaders/">图片着色器</a>的基础上实现的。但是你也可以根据其基本思路，以表面着色器的形式重写其功能。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/009/Result.png"></p>
<h2 id="Interpolate-Colors"><a href="#Interpolate-Colors" class="headerlink" title="Interpolate Colors"></a>Interpolate Colors</h2><p>首先，我们颜色混合着色器的第一个版本仅仅处理两个纯色之间的混合。因为这样我们就不需要考虑什么纹理、uv之类的。我们只需在加一个颜色变量、以及一个用于混合的参数，这个参数将决定两个颜色的混合权重，这里我们把它设为<code>Range</code>类，这样方便在材质面板上调节参数，同时确保参数的有效性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//材质面板上显示的属性</span></span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color (<span class="string">&quot;Color&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) <span class="comment">//the base color</span></span><br><span class="line">		_SecondaryColor (<span class="string">&quot;Secondary Color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>) <span class="comment">//the color to blend to</span></span><br><span class="line">		_Blend (<span class="string">&quot;Blend Value&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0</span> <span class="comment">//0 is the first color, 1 the second</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//混合参数，或权重</span></span><br><span class="line"><span class="keyword">float</span> _Blend;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于混合的两个颜色</span></span><br><span class="line">fixed4 _Color;</span><br><span class="line">fixed4 _SecondaryColor;</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">虽然我们没有使用纹理的颜色，但是也可以保留顶点着色器中关于UV变换的操作，下一个版本还会用到它。而作为第一个版本，我么只修改片段着色器就可以，直接根据混合参数，将第二种颜色叠加到原先的颜色上。</span><br><span class="line">```c++</span><br><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    fixed4 col = _Color + _SecondaryColor * _Blend;</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>!()[<a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/assets/images/posts/009/BlendColorsAdd.gif]">https://www.ronja-tutorials.com/assets/images/posts/009/BlendColorsAdd.gif]</a></p>
<p>现在我们可以看到混合后颜色的变化了，但是我们始终无法将其颜色完全过度到第二种颜色。这是因为混合参数只改变第二种颜色混入的颜色，而第一种颜色依然存在。</p>
<p>为了实现两种颜色之间的过渡渐变效果，我们需要保证两种颜色的权重和为1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    fixed4 col = _Color * (<span class="number">1</span> - _Blend) + _SecondaryColor * _Blend;</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/009/BlendColors.gif"></p>
<p>这种混合操作叫做线性插值，Unity内置的<code>lerp</code>函数就是实现这个线性插值功能。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    fixed4 col = lerp(_Color, _SecondaryColor, _Blend);</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终两个颜色间的混合着色器源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/009_Color_Blending/Plain&quot;</span>&#123;</span><br><span class="line">	<span class="comment">//材质面板上显示的属性</span></span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color (<span class="string">&quot;Color&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) <span class="comment">//基础颜色</span></span><br><span class="line">		_SecondaryColor (<span class="string">&quot;Secondary Color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>) <span class="comment">//用于混合的颜色</span></span><br><span class="line">		_Blend (<span class="string">&quot;Blend Value&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0</span> <span class="comment">//混合权重，0 表示只显示基础颜色, 1 表示只显示混合颜色</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		<span class="comment">//渲染不透明物体</span></span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="comment">//引入内置变量和函数</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//定义着色器函数</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//混合参数</span></span><br><span class="line">			<span class="keyword">float</span> _Blend;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//两个用于混合的颜色</span></span><br><span class="line">			fixed4 _Color;</span><br><span class="line">			fixed4 _SecondaryColor;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//输入的网格数据</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//中间插值的变量，由顶点着色器到片段着色器</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//顶点着色器</span></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				<span class="comment">//计算裁剪空间下的坐标</span></span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//片段着色器</span></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">				fixed4 col = lerp(_Color, _SecondaryColor, _Blend);</span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Interpolate-Textures"><a href="#Interpolate-Textures" class="headerlink" title="Interpolate Textures"></a>Interpolate Textures</h2><p>我们颜色混合着色器的第二个版本将考虑混合两张纹理贴图的颜色。首先我们删掉前面两个颜色变量，改成两个纹理变量。因为涉及到纹理，所以需要uv坐标来进行纹理采样。之前的纹理采样都执行了uv变换操作，实际上这一步并不是必须的，如果我们不打算缩放纹理的话，这一步就可以省略掉，与之相关的纹理参数也可以省掉。但是我们这里有两张纹理，每张纹理都打算使用各自的缩放参数，这时候可以在顶点着色器中执行uv变换，然后在传给片段着色器，也可以直接在片段着色器中进行uv变换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//材质面板上显示的属性</span></span><br><span class="line">Properties&#123;</span><br><span class="line">    _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; <span class="comment">//基础纹理颜色</span></span><br><span class="line">    _SecondaryTex (<span class="string">&quot;Secondary Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;black&quot;</span> &#123;&#125; <span class="comment">//用于混合的纹理颜色</span></span><br><span class="line">    _Blend (<span class="string">&quot;Blend Value&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0</span> <span class="comment">//混合权重，0 表示只显示基础颜色, 1 表示只显示混合颜色</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义着色器函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输入的网格数据</span></span><br><span class="line">struct appdata&#123;</span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    float2 uv : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中间插值的变量，由顶点着色器到片段着色器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">    float4 position : SV_POSITION;</span><br><span class="line">    float2 uv : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点着色器</span></span><br><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    <span class="comment">//计算裁剪空间下的坐标</span></span><br><span class="line">    o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>这里我们是在片段着色其中进行uv变换的。并且使用各自变换后的uv进行纹理采样。在得到采样颜色后，我们就可以和上一个版本一样进行线性插值了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//分别进行uv变换</span></span><br><span class="line">    float2 main_uv = TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">    float2 secondary_uv = TRANSFORM_TEX(i.uv, _SecondaryTex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分别进行纹理采样</span></span><br><span class="line">    fixed4 main_color = tex2D(_MainTex, main_uv);</span><br><span class="line">    fixed4 secondary_color = tex2D(_SecondaryTex, secondary_uv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最终执行线性插值</span></span><br><span class="line">    fixed4 col = lerp(main_color, secondary_color, _Blend);</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/009/BlendTextures.gif"></p>
<p>下面是我们这个图片混合着色器的完整脚本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/009_Color_Blending/Texture&quot;</span>&#123;</span><br><span class="line">	<span class="comment">//材质面板属性显示</span></span><br><span class="line">	Properties&#123;</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; <span class="comment">//第一张图</span></span><br><span class="line">		_SecondaryTex (<span class="string">&quot;Secondary Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;black&quot;</span> &#123;&#125; <span class="comment">//第二张图</span></span><br><span class="line">		_Blend (<span class="string">&quot;Blend Value&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0</span> <span class="comment">//0 表示只显示第一张图, 1 只显示第二张图</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		<span class="comment">//不透明材质</span></span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="comment">//引入内置变量和函数</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//定义着色器函数</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//混合参数</span></span><br><span class="line">			<span class="keyword">float</span> _Blend;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//两张图</span></span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">			sampler2D _SecondaryTex;</span><br><span class="line">			float4 _SecondaryTex_ST;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//输入的网格数据</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//中间的插值数据</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//顶点着色器</span></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				<span class="comment">//变换到裁剪空间</span></span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				o.uv = v.uv;</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//片段着色器</span></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">				<span class="comment">//各自进行uv变换</span></span><br><span class="line">				float2 main_uv = TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">				float2 secondary_uv = TRANSFORM_TEX(i.uv, _SecondaryTex);</span><br><span class="line"></span><br><span class="line">				<span class="comment">//各自进行纹理采样</span></span><br><span class="line">				fixed4 main_color = tex2D(_MainTex, main_uv);</span><br><span class="line">				fixed4 secondary_color = tex2D(_SecondaryTex, secondary_uv);</span><br><span class="line"></span><br><span class="line">				<span class="comment">//线性插值</span></span><br><span class="line">				fixed4 col = lerp(main_color, secondary_color, _Blend);</span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Interpolation-based-on-a-Texture"><a href="#Interpolation-based-on-a-Texture" class="headerlink" title="Interpolation based on a Texture"></a>Interpolation based on a Texture</h2><p>前面连个的混合参数都是一个统一的变量，这样模型表面每个区域的混合权重都一样。为了达到不同权重的混合效果，最后这个版本使用纹理来作为我们的混合参数。</p>
<p>首先我们是将原先的混合变量用一个纹理变量替代。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//材质面板属性</span></span><br><span class="line">Properties&#123;</span><br><span class="line">    _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; <span class="comment">//第一张图</span></span><br><span class="line">    _SecondaryTex (<span class="string">&quot;Secondary Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;black&quot;</span> &#123;&#125; <span class="comment">//第二张图</span></span><br><span class="line">    _BlendTex (<span class="string">&quot;Blend Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;grey&quot;</span> <span class="comment">//混合权重图</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//混合权重</span></span><br><span class="line">sampler2D _BlendTex;</span><br><span class="line">float4 _BlendTex_ST;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于混合的图</span></span><br><span class="line">sampler2D _MainTex;</span><br><span class="line">float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">sampler2D _SecondaryTex;</span><br><span class="line">float4 _SecondaryTex_ST;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>同样的，我们也对权重图进行uv变换，然后再进行采样。但是纹理采样的结果还是颜色，是一个向量，而我们的插值权重是一个标量，这时候我们可以选择其中一个合适的通道值来作为我们的插值权重。和前面一样，最后我们用这个权重值进行颜色插值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//分别进行uv变换</span></span><br><span class="line">    float2 main_uv = TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">    float2 secondary_uv = TRANSFORM_TEX(i.uv, _SecondaryTex);</span><br><span class="line">    float2 blend_uv = TRANSFORM_TEX(i.uv, _BlendTex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分别进行纹理采样</span></span><br><span class="line">    fixed4 main_color = tex2D(_MainTex, main_uv);</span><br><span class="line">    fixed4 secondary_color = tex2D(_SecondaryTex, secondary_uv);</span><br><span class="line">    fixed4 blend_color = tex2D(_BlendTex, blend_uv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选其中红色通道作为混合权重</span></span><br><span class="line">    fixed blend_value = blend_color.r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最终的颜色插值</span></span><br><span class="line">    fixed4 col = lerp(main_color, secondary_color, blend_value);</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/009/BlendWithTexture.png"></p>
<p>好了，下面是完整的着色器脚本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/009_Color_Blending/TextureBasedBlending&quot;</span>&#123;</span><br><span class="line">	<span class="comment">//材质面板上的属性</span></span><br><span class="line">	Properties&#123;</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; <span class="comment">//第一张图</span></span><br><span class="line">		_SecondaryTex (<span class="string">&quot;Secondary Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;black&quot;</span> &#123;&#125; <span class="comment">//第二张图</span></span><br><span class="line">		_BlendTex (<span class="string">&quot;Blend Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;grey&quot;</span> <span class="comment">//权重图</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		<span class="comment">//渲染不透明物体</span></span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="comment">//引入内置变量和函数</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//定义着色器函数</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//混合权重图</span></span><br><span class="line">			sampler2D _BlendTex;</span><br><span class="line">			float4 _BlendTex_ST;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//用于混合的两张纹理</span></span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">			sampler2D _SecondaryTex;</span><br><span class="line">			float4 _SecondaryTex_ST;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//输入的模型数据</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//中间的插值数据</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//顶点着色器</span></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				<span class="comment">//变换到裁剪空间</span></span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				o.uv = v.uv;</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//片段着色器</span></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">				<span class="comment">//分别进行uv变换</span></span><br><span class="line">				float2 main_uv = TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">				float2 secondary_uv = TRANSFORM_TEX(i.uv, _SecondaryTex);</span><br><span class="line">				float2 blend_uv = TRANSFORM_TEX(i.uv, _BlendTex);</span><br><span class="line"></span><br><span class="line">				<span class="comment">//分别进行纹理采样</span></span><br><span class="line">				fixed4 main_color = tex2D(_MainTex, main_uv);</span><br><span class="line">				fixed4 secondary_color = tex2D(_SecondaryTex, secondary_uv);</span><br><span class="line">				fixed4 blend_color = tex2D(_BlendTex, blend_uv);</span><br><span class="line"></span><br><span class="line">				<span class="comment">//选取一个通道作为混合权重</span></span><br><span class="line">				fixed blend_value = blend_color.r;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//最终的颜色插值</span></span><br><span class="line">				fixed4 col = lerp(main_color, secondary_color, blend_value);</span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望本文能让你了解着色器中颜色的基本使用、以及插值的实际应用。</p>
<p>所有的源码都在以下链接可以找到：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/009_Color_Blending/ColorBlending_Plain.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/009_Color_Blending/ColorBlending_Plain.shader</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/009_Color_Blending/ColorBlending_Texture.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/009_Color_Blending/ColorBlending_Texture.shader</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/009_Color_Blending/ColorBlending_TextureBasedBlending.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/009_Color_Blending/ColorBlending_TextureBasedBlending.shader</a></li>
</ul>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/02/Ronja_Planar_Mapping/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/02/Ronja_Planar_Mapping/" class="post-title-link" itemprop="url">Planar Mapping</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-02 10:01:00" itemprop="dateCreated datePublished" datetime="2021-07-02T10:01:00+08:00">2021-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-02 21:04:33" itemprop="dateModified" datetime="2022-08-02T21:04:33+08:00">2022-08-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/008-planar-mapping/">Planar Mapping</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>有时候我们的网格数据中并没有UV坐标，或者说器UV坐标并不适用于将要使用的纹理，或者我们想让纹理和模型表面根据某一规则对齐。或者还有其他什么原因，我们需要动态生成UV坐标。那么接下来的教程，我们将以最简单的方法，二维平面映射，来创建我们的UV坐标。</p>
<p>本教程是在上一个<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Sprite_Shaders/">图片着色器</a>的基础上实现的。但是你也可以根据其基本思路，以表面着色器的形式重写其功能。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/008/Result.png"></p>
<h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><p>首先我们将输入结构体中的uv变量删除掉，因为我们打算通过脚本生成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">    <span class="keyword">float</span> vertex : POSITION;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为片段着色器中的输入参数是由顶点着色器中的输出参数插值而得到的，因此我们选择在顶点着色器中计算新的uv值。首先我们将其顶点UV设置为顶点在模型坐标系下的<code>x</code>和<code>z</code>的值。这样足以让纹理出现在模型表面了，并且其效果看起来就好像是图片从上往下投影到模型表面一样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.uv = v.vertex.xz;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Adjustable-Tiling"><a href="#Adjustable-Tiling" class="headerlink" title="Adjustable Tiling"></a>Adjustable Tiling</h2><p>前面并没有考虑图片的缩放，或者我们可能希望图片显示不跟随模型一起旋转。</p>
<p>图片缩放的问题可以通过<code>TRANSFORM_TEX</code>宏来执行UV变换，这样最终用于纹理采样的UV可以跟随纹理缩放而相应改变。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.uv = TRANSFORM_TEX(v.vertex.xz, _MainTex);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/008/AdjustTilingOffset.gif"></p>
<h2 id="Texture-Coordinates-based-on-World-Position"><a href="#Texture-Coordinates-based-on-World-Position" class="headerlink" title="Texture Coordinates based on World Position"></a>Texture Coordinates based on World Position</h2><p>为了消除模型位置、和旋转对UV坐标的影响，我们需要将顶点坐标转换到世界坐标系，前面的例子是使用模型坐标系中的顶点坐标来生成UV坐标的。计算世界坐标的方法很简单，只需要将顶点坐标乘以模型空间矩阵。在我们得到世界坐标后，使用其世界坐标来生成UV坐标。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">	v2f o;</span><br><span class="line">	<span class="comment">//计算裁剪空间下的顶点坐标</span></span><br><span class="line">	o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">	<span class="comment">//计算世界空间下的顶点坐标</span></span><br><span class="line">	float4 worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">	<span class="comment">//应用纹理缩放，执行UV变换</span></span><br><span class="line">	o.uv = TRANSFORM_TEX(worldPos.xz, _MainTex);</span><br><span class="line">	<span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/008/MoveSphere.gif"></p>
<p>从上面我们也可以看到基于世界坐标的二维平面映射也不完美，因为我们必须使用可重复的图片，否则无法覆盖整个空间区域。而且最终用渲染出来的纹理也会因为观察角度不同而发生扭曲。但是我们可以使用更牛的技术来改进，例如后面将会介绍的,三维平面映射。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/008_Planar_Mapping&quot;</span>&#123;</span><br><span class="line">	<span class="comment">//材质面板上显示的属性</span></span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		<span class="comment">//渲染不透明物体</span></span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//定义公共变量</span></span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">			fixed4 _Color;</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				<span class="comment">//计算裁剪空间下的坐标</span></span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				<span class="comment">//计算世界空间下的坐标</span></span><br><span class="line">				float4 worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">				<span class="comment">//执行UV变换</span></span><br><span class="line">				o.uv = TRANSFORM_TEX(worldPos.xz, _MainTex);</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">				<span class="comment">//纹理采样</span></span><br><span class="line">				fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">				<span class="comment">//多个颜色叠加</span></span><br><span class="line">				col *= _Color;</span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack <span class="string">&quot;Standard&quot;</span> <span class="comment">//当当前着色器不支持时，选择后补着色器中的功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以在以下链接找到源码：<a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/008_Planar_Mapping/planar_mapping.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/008_Planar_Mapping/planar_mapping.shader</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Sprite_Shaders/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/01/Ronja_Sprite_Shaders/" class="post-title-link" itemprop="url">Sprite Shaders</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-01 15:01:00" itemprop="dateCreated datePublished" datetime="2021-07-01T15:01:00+08:00">2021-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-02 21:04:33" itemprop="dateModified" datetime="2022-08-02T21:04:33+08:00">2022-08-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/007-sprite-shaders/">Sprite Shaders</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>在Unity中，图片的渲染和三维模型渲染非常相似。并且提供了<code>SpriteRender</code>的组件来实现图片渲染的功能。接下来我也会介绍这个组件、及其实现原理，然后通过我们的着色器来模拟这个组件的功能。</p>
<p>这个教程依赖于上一个<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Basic_Transparency/">透明着色器</a>的教程。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/007/Result.png"></p>
<h2 id="Scene-Setup"><a href="#Scene-Setup" class="headerlink" title="Scene Setup"></a>Scene Setup</h2><p>这里采用一个非常简单的场景来实验我们的图片着色器。首先，我将摄像机改为正交模式，并且将原先的小方块改成<code>sprite renderer</code>，同时将后面用到的图片格式改为<code>sprite</code>。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/007/Hierarchy.png"><br><img src="https://www.ronja-tutorials.com/assets/images/posts/007/CameraInspector.png"><br><img src="https://www.ronja-tutorials.com/assets/images/posts/007/SpriteInspector.png"><br><img src="https://www.ronja-tutorials.com/assets/images/posts/007/SpriteImporter.png"></p>
<h2 id="Changing-the-Shader"><a href="#Changing-the-Shader" class="headerlink" title="Changing the Shader"></a>Changing the Shader</h2><p>在完成以上修改后，将上一章的透明材质放到<code>SpriteRenderer</code>组件的材质属性上，一切准备就绪！</p>
<p><code>SpriteRenderer</code>组件会自动根据附加的图片自动生成一个网格数据，包括顶点、UV等。然后和普通的三维模型一样渲染到场景中。同时在<code>SpriteRenderer</code>上定义的颜色也会以顶点颜色的形式包含在网格数据中。另外还可以设置图片是否翻转。而且图片渲染和半透明渲染一样，是排在不透明渲染之后，甚至大多数渲染之后，而这个渲染队列是由<code>SpriteRenderer</code>自动帮我们设置的。</p>
<p>因为目前我们的半透明着色器还不支持翻转、和顶点颜色。所以接下来我们把这个添加上。</p>
<p>但是当我们翻转后，会发现图片不见了，然后再翻转，图片又出现了。这时因为从性能优化角度考虑，渲染单面比渲染双面更节约性能，这里叫做<code>backface culling</code>背面剔除。普通的不透明模型渲染使用背面剔除非常有效，因为其内部不可能被渲染。另外如果不使用背面剔除，在光照计算的时候会出现怪异的效果，因为参与计算的法向量只会指向正面方向，因此背面计算的结果无效。</p>
<p>在这里我们并不用考虑这个优化项，因为图片、半透明物体之类的并不存在哪个面朝内、哪个面朝外的问题，也不需要参与光照计算。因此我们这里直接关闭背面剔除公共，关闭的设置和之前混合模式、深度写入设置类似。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cull Off</span><br></pre></td></tr></table></figure>

<p>为了在最终的渲染中使用到前面说的顶点颜色数据。我们需要在半透明着色其中做一些修改。首先在输入数据结构和插值数据结构中加入一个四维向量，并标记为颜色类型。然后在顶点着色器中将输入数据结构中的顶点颜色传递给插值数据结构中的颜色值。最终在片段着色器中叠加到输出颜色上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    float2 uv : TEXCOORD0;</span><br><span class="line">    fixed4 color : COLOR;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">    float4 position : SV_POSITION;</span><br><span class="line">    float2 uv : TEXCOORD0;</span><br><span class="line">    fixed4 color : COLOR;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">    o.color = v.color;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">    col *= _Color;</span><br><span class="line">    col *= i.color;</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后的半透明材质就可以应用到<code>SpriteRenderer</code>组件上了，并且可以响应<code>SpriteRenderer</code>上的一些设置操作。在后面的教程中我们还可以在此基础上扩展出更加绚丽的效果。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/007/AdjustVariables.gif"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/007_Sprite&quot;</span>&#123;</span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		Tags&#123; </span><br><span class="line">			<span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Transparent&quot;</span> </span><br><span class="line">			<span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Transparent&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line"></span><br><span class="line">		ZWrite off</span><br><span class="line">		Cull off</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line"></span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">			fixed4 _Color;</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">				fixed4 color : COLOR;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">				fixed4 color : COLOR;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">				o.color = v.color;</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">				fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">				col *= _Color;</span><br><span class="line">				col *= i.color;</span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SpriteRenderer</code>组件还会提供各种网格数据来实现图标、多边形图形、动画效果。</p>
<p>相比于Unity内置的<code>Sprite Shader</code>，我们目前还没有实现的功能有<code>instancing</code>、像素捕捉、<code>alpha</code>通道扩展，因为这些功能比较复杂，而且很少使用，因此我现在不做介绍。</p>
<p>你可以在以下链接找到源码：<a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/007_Sprites/sprite.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/007_Sprites/sprite.shader</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Basic_Transparency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/01/Ronja_Basic_Transparency/" class="post-title-link" itemprop="url">Basic Transparency</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-01 14:01:00" itemprop="dateCreated datePublished" datetime="2021-07-01T14:01:00+08:00">2021-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-02 21:04:33" itemprop="dateModified" datetime="2022-08-02T21:04:33+08:00">2022-08-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/006-simple-transparency/">Basic Transparency</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>对于不透明物体的渲染，是直接将计算所得到的像素颜色覆盖掉原有的颜色值。而透明物体的渲染方法恰恰相反，是保留原有颜色值，然后两者通过混合后，达到一种看是半透明的效果。为了阐明关键思想，这里以最简单的不受光材质为例。</p>
<p>如果你还不知道如果编写着色器，这里建议你先阅读我之前的<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Basic_Shader/">教程</a><br><img src="https://www.ronja-tutorials.com/assets/images/posts/006/SemitransparentCube.png"></p>
<p>为了达到正确的渲染效果，首先我们需要告诉Unity：我们打算渲染一个透明物体。因此，我们可以将<code>SubShader</code>块中的<code>Tags</code>块的渲染类型改为<code>Transparent</code>，以及将其中的渲染队列改为<code>Transparent</code>。渲染队列的设置是为了保证我们的半透明物体一定是在不透明物体之后渲染。如果不这么设置，根据上面说到的不透明渲染的方法，很可能有不透明物体直接覆盖在半透明物体区域，即便我们的半透明物体在不透明物体的前方。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Transparent&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们要定义混合模式，前面提到需要将半透明的像素颜色和已经渲染的像素颜色相混合，就是通过这个混合模式来决定的。混合模式的定义由两个关键字构成，第一个和半透明颜色相乘，第二个和已有的颜色相乘，然后两者相加。</p>
<p>当我们渲染不透明物体时，我们将第一个参数设为1，第二个参数设为0，这样新的颜色值便会完全替换掉原先的颜色值。而在透明材质中，我们通常使用新颜色的透明通道作为第一个参数，而第二个参数为1减该透明通道值，这样我们就可以调整其透明通道来实现不同程度的透明效果。</p>
<p>混合模式可以定义在<code>SubShader</code>块中，也可以定义在<code>Pass</code>块中，位置的不同决定其作用域的大小。但是必须定义在<code>hlsl</code>代码以外，因为这属于<code>Shaderlab</code>拓展的特性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blend SrcAlpha OneMinusSrcAlpha</span><br></pre></td></tr></table></figure>

<p>你可以从下面网址找到更全面的混合模式设置介绍：<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/SL-Blend.html">https://docs.unity3d.com/Manual/SL-Blend.html</a></p>
<p>为了突出重点，精简逻辑，这里举两个小例子：</p>
<ul>
<li>当我们的片段着色器返回的透明通道值为<code>0.5</code>，那么根据前面设置的混合模式，将会将新的颜色值得一半和旧的颜色值得一一半进行混合。如果新颜色是白色，旧颜色是黑色，那么混合后的将是灰色；</li>
<li>当我们的片段着色器返回的透明通道值为<code>0.9</code>，那么混合后，新颜色将占有90%的比例，而旧颜色只占有%10；</li>
</ul>
<p>因此，在前面不透明着色器脚本的基础上，做以上调整，该着色器就成功变成一个半透明着色器。因为公共变量<code>_Color</code>参与了片段着色器中的颜色计算，所以我们在材质面板修改其透明度，将会影响最终的混合效果。如下：<br><img src="https://www.ronja-tutorials.com/assets/images/posts/006/AdjustTint.gif"></p>
<p>另一个需要修改的地方是关闭透明着色器的深度写入功能。一般来说，当模型被渲染到画面上是，其距离摄像机的深度信息会被记录到一张深度纹理是上。然后后面渲染的模型只需要与这张深度图相比较，就可以正确判断其相互之间的遮挡关系，其中被遮挡的部分将不会渲染到画面上。但是这并不适用于半透明物体，因为即便被遮挡也会被渲染。所以我们只能从其渲染队列方面考虑，将半透明物体限定在不透明物体之后渲染，并且半透明物体之间的渲染排序是由远及近。深度值写入的设置如下，和混合模式设置一样，都可以定义在<code>SubShader</code>或<code>Pass</code>块中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">ZWrite Off</span><br></pre></td></tr></table></figure>

<p>如果我们的纹理贴图也存在半透明通道，那么最终渲染出来的效果将是各个部位的透明程度有差异。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/006/TextureTransparentCube.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/006_Basic_Transparency&quot;</span>&#123;</span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Transparent&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">		ZWrite off</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">			fixed4 _Color;</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">				fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">				col *= _Color;</span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以在以下链接找到源码：<a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/006_Transparency/transparent.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/006_Transparency/transparent.shader</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Surface_Shader_Basics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/01/Ronja_Surface_Shader_Basics/" class="post-title-link" itemprop="url">Surface Shader Basics</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-01 13:01:00" itemprop="dateCreated datePublished" datetime="2021-07-01T13:01:00+08:00">2021-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-02 21:04:33" itemprop="dateModified" datetime="2022-08-02T21:04:33+08:00">2022-08-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/005-simple-surface/">Surface Shader Basics</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>在Unity中，我们可以创建一个空的着色器脚本，然后手动一行一行的去实现整个脚本。当然这种方式比较费时，毕竟着色器有一套固定的流程，因此可以将一部分代码复用，例如光照模型。如果能够直接配置一些参数就能自动生成相关代码，你一定会喜欢吧。Unity就是这么会投其所好，它实现了一种名叫表面着色器的东东，刚好能够满足咱懒人的需求。懒-是推动科技发展的第一生产力，至理名言啊！</p>
<p>那什么是表面作色器呢？在进入正题之前，我建议你先了解最简单的无光照的着色器，如果你不清楚，可以参考我上一个<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Basic_Shader/">教程</a>。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/005/Result.png"></p>
<h2 id="Conversion-to-simple-Surface-Shader"><a href="#Conversion-to-simple-Surface-Shader" class="headerlink" title="Conversion to simple Surface Shader"></a>Conversion to simple Surface Shader</h2><p>相比于前面介绍的着色器实现方法，表面着色器的实现就显得更加简洁，原先需要处理的很多内容都可以剔除，因为Unity会自动帮我们生成相关代码。以上一个教程的着色器脚本为例，如果我们要用表面着色器来实现，那么前面提到的什么顶点着色器都可以不要了。与之相对应的宏命令也可以删除，两者之间的插值数据也可以不要了。甚至是<code>UnityCG.cginc</code>文件也可以不要，还有<code>MainTex_ST</code>等等。这些代码最终都会由Unity自动生成。一顿大刀阔斧，来看看我们的成果吧：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/005_surface&quot;</span> &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		CGPROGRAM</span><br><span class="line"></span><br><span class="line">		sampler2D _MainTex;</span><br><span class="line">		fixed4 _Color;</span><br><span class="line"></span><br><span class="line">		<span class="function">fixed4 <span class="title">frag</span> <span class="params">(v2f i)</span> : SV_TARGET </span>&#123;</span><br><span class="line">			fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">			col *= _Color;</span><br><span class="line">			<span class="keyword">return</span> col;</span><br><span class="line">		&#125;</span><br><span class="line">		ENDCG</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack <span class="string">&quot;Standard&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简洁的令人发指！等等，先别急着感叹，还有事没做完。上面的着色器脚本并不能执行，因为表面着色器有自己的一些要求。</p>
<p>首先，我们需要添加一个新的数据类型作为片段着色器的输入。这个数据类型将会包含所有与片段着色相关的必要数据。当然，我们这个简单的不能再简单的着色器只需要传递UV坐标。UV坐标还是二维向量。但是，这里的UV变量命名有特殊的规则。因为UV坐标是用来纹理采样的，上一章讲过UV变换，每一个纹理都有自己的缩放、偏移参数，所以必须将变换后的UV和对应的纹理相关联。这里采用命名规则来实现，首先UV变量必须以<code>uv</code>开头，然后后面跟随纹理变量的名称。这样，在后面自动生成代码的时候，程序就知道谁和谁配对了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">	float2 uv_MainTex;<span class="comment">//此时配对的纹理是 _MainTex</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来我们要对之前的片段着色其进行修改，使其编程表面着色器。为了区分两者，先把函数名改为<code>surf</code>。然后表面着色器函数是没有返回值的，所以函数返回类型改为<code>void</code>。</p>
<p>然后再拓展出两个参数。第一个参数正是我们刚刚定义好的<code>Input</code>结构，通过这个参数，表面着色器可以获取所有相关的必要参数；第二个参数是一个叫做<code>SurfaceOutputStandard</code>的结构体，从字面意思可以看出，这就是表面着色器的最终输出数据。当然，在函数结束之前，必须计算好、并赋值所有需要外传的参数。除了<code>SurfaceOutputStandard</code>结构外，Unity还定义了其他类似的结构，它们之间的区别在于适用于不同的光照模型。而这些结构中的成员变量就包含了后续光照处理所必须的数据，这些数据的具体含义将在后面介绍。</p>
<p>然后是删除<code>SV_Target</code>语义标识符，因为我们的<code>surf</code>函数的返回类型是<code>void</code>。</p>
<p>最后是把<code>return</code>语句删除。然后将计算所得的数据通过<code>SurfaceOutputStandard</code>传递出去。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">	fixed4 col = tex2D(_MainTex, i.uv_MainTex);</span><br><span class="line">	col *= _Color;</span><br><span class="line">	o.Albedo = col.rgb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一步，我们需要引入光照模型，同时将写好的表面着色器函数与表面着色器相关联，这个和顶点着色器类似，都是通过<code>#pragma</code>来实现。因为我们这里的<code>surf</code>的输出结构是<code>SurfaceOutputStandard</code>，意味着我们使用标准的光照模型。所以在其后我们还得加上<code>Standard</code>来说明所用的光照模型，最后的<code>fullforwordshadows</code>是告诉Unity使用前向阴影。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/005_surface&quot;</span> &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		CGPROGRAM</span><br><span class="line"></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">pragma</span> surface surf Standard fullforwardshadows</span></span><br><span class="line"></span><br><span class="line">		sampler2D _MainTex;</span><br><span class="line">		fixed4 _Color;</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">			float2 uv_MainTex;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">			fixed4 col = tex2D(_MainTex, i.uv_MainTex);</span><br><span class="line">			col *= _Color;</span><br><span class="line">			o.Albedo = col.rgb;</span><br><span class="line">		&#125;</span><br><span class="line">		ENDCG</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/005/SimpleAlbedo.png"></p>
<h2 id="Standard-Lighting-Properties"><a href="#Standard-Lighting-Properties" class="headerlink" title="Standard Lighting Properties"></a>Standard Lighting Properties</h2><p>在<code>SurfaceOutputStandard</code>结构中包含很多材质相关的属性参数，具体如下：</p>
<ul>
<li>Albedo : 表示材质表面的颜色。而材质最终呈现的颜色受光照的影响，因为材质本身只能决定对吸收哪些波段的光。</li>
<li>Normal : 表示材质表面法向向量。法向向量一般和顶点坐标一起，存储在模型数据中，这时候法向向量所在的坐标系是切向空间。什么是切向空间呢？可以简单的理解为沿着模型表面的坐标系。而法向是指垂直与模型表面的方向。法向向量一般要变换到世界坐标系再参与计算。</li>
<li>Emission ：表示材质的自发光特性。一般的的模型渲染依赖于外部光源，如果关闭外部光源，那么模型表现为黑色。而具备自发光材质的模型即便没有外部光源也能显示出原本的颜色。一般场景中的灯具、或者熔岩会使用自发光属性。</li>
<li>Metallic ：表示材质的金属特性。现实中，金属材料和非金属材料的光学特性不一样，例如即便黑色的金属也能在阳光下反射光芒，但是黑色的非金属就表现的黯淡无光。</li>
<li>Smoothness : 表示材质的光滑度。光滑程度主要决定漫反射、和镜面反射之间的权重分布。玻璃的光滑度非常高，所以可以用来做镜子，而一般木材非常粗糙。</li>
<li>Occlusion ：表示环境遮罩特性。举个例子，平坦的桌面上，光线能够达到每个角落。而崎岖不平的背包上，那些深深的褶皱显得格外阴暗。这些因为表面相互遮挡而产生的阴影就是我们这里的环境遮罩效果。</li>
<li>Alpha : 表示材质的透明度。从字面可以很好理解，有些材质是透明的，如玻璃，有些不是，如木头。</li>
</ul>
<p>上面提到的这些参数前三个是向量，后四个是标量。这些参数有些可以直接暴露在材质面板，方便美术编辑材质效果。</p>
<h2 id="Implement-a-few-Lighting-Properties"><a href="#Implement-a-few-Lighting-Properties" class="headerlink" title="Implement a few Lighting Properties"></a>Implement a few Lighting Properties</h2><p>接下来我们把<code>emission</code>、<code>metallic</code>、<code>smoothness</code>三个参数为例，将其作为材质的可调参数。当然你也可以根据实际需求做调整。</p>
<p>首先，我们定义两个公共变量：光滑度和金属度。它们的类型我选择<code>half</code>。一般来说除了坐标采用<code>float</code>，其他的都选<code>half</code>类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">half _Smoothness;</span><br><span class="line">half _Metallic;</span><br></pre></td></tr></table></figure>

<p>然后将这些公共变量添加到<code>Properties</code>块中，将其暴露在材质面板上。但是材质面板并不知道所显示的变量的类型，所以还需要在其名称后增加类型说明，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Properties &#123;</span><br><span class="line">	_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">	_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">	_Smoothness (<span class="string">&quot;Smoothness&quot;</span>, <span class="keyword">float</span>) = <span class="number">0</span></span><br><span class="line">	_Metallic (<span class="string">&quot;Metalness&quot;</span>, <span class="keyword">float</span>) = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>surf</code>函数中，我们可以直接将这些公共变量传递给<code>SurfaceOutputStandard</code>结构体，这样在后续的光照计算中，就可以使用这些参数了，同时我们修改材质面板上的值，便能立即改变材质的表现效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">	fixed4 col = tex2D(_MainTex, i.uv_MainTex);</span><br><span class="line">	col *= _Color;</span><br><span class="line">	o.Albedo = col.rgb;</span><br><span class="line">	o.Metallic = _Metallic;</span><br><span class="line">	o.Smoothness = _Smoothness;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前为止，表面着色器已经基本完成了。但是还有些需要完善的地方，因为我们在材质面板上修改参数时，很容易设置到非法值，最终导致材质显示异常。我们可以在<code>Properties</code>做些小修改，将<code>float</code>修改为<code>Range(0,1)</code>就可以将这些参数限定在一个有效范围内。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Properties &#123;</span><br><span class="line">	_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">	_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">	_Smoothness (<span class="string">&quot;Smoothness&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">	_Metallic (<span class="string">&quot;Metalness&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/005/Inspector.png"></p>
<p>接下来我们添加自发光颜色。同样的我们也需要在公共变量、和<code>Properties</code>中加入<code>_Emission</code>的定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">_Emission (<span class="string">&quot;Emission&quot;</span>, Color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">half3 _Emission;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">o.Emission = _Emission;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/005/Emissive.png"></p>
<p>为了避免自发光材质过度曝光，我们只能将自发光颜色限定在<code>[0-1]</code>之间。当然，如果我们将自发光颜色定义为HDR类型的话，就可以不用担心过曝的问题了。如果我们使用纹理来将材质各个部位的自发光特性差别化，那么可以产生很炫的效果。例如怪兽的眼睛放光的效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[HDR] _Emission (<span class="string">&quot;Emission&quot;</span>, Color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/005/HdrInspector.png"></p>
<h2 id="Minor-Improvements"><a href="#Minor-Improvements" class="headerlink" title="Minor Improvements"></a>Minor Improvements</h2><p>最后，让我们做一些小改动，让我们的材质看起来更自然。首先，我们在着色器脚本最后面加上<code>fallback shader</code>，这样我们可以复用其他着色器中的代码。这里我将标准着色器作为我们的<code>fallback shader</code>，然后复用其中的阴影渲染部分<code>shadow pass</code>的代码，这样就可以让我们的材质也表现出阴影效果。我们使用<code>fullfowardshadows</code>参数进而获得很好的阴影效果。另外我们也可以指定当前着色器的目标平台，例如设置<code>target</code>为3.0。其中<code>target</code>的值越高，表示可以使用的特性越多，但是支持的硬件平台会越少。这里<code>target</code>为3.0，已经可以使用大多数的高级特性了，所以能够实现更好的光照效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/005_surface&quot;</span> &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">		_Smoothness (<span class="string">&quot;Smoothness&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">		_Metallic (<span class="string">&quot;Metalness&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">		[HDR] _Emission (<span class="string">&quot;Emission&quot;</span>, color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		CGPROGRAM</span><br><span class="line"></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">pragma</span> surface surf Standard fullforwardshadows</span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">pragma</span> target 3.0</span></span><br><span class="line"></span><br><span class="line">		sampler2D _MainTex;</span><br><span class="line">		fixed4 _Color;</span><br><span class="line"></span><br><span class="line">		half _Smoothness;</span><br><span class="line">		half _Metallic;</span><br><span class="line">		half3 _Emission;</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">			float2 uv_MainTex;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">			fixed4 col = tex2D(_MainTex, i.uv_MainTex);</span><br><span class="line">			col *= _Color;</span><br><span class="line">			o.Albedo = col.rgb;</span><br><span class="line">			o.Metallic = _Metallic;</span><br><span class="line">			o.Smoothness = _Smoothness;</span><br><span class="line">			o.Emission = _Emission;</span><br><span class="line">		&#125;</span><br><span class="line">		ENDCG</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack <span class="string">&quot;Standard&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/005/Result.png"></p>
<p>希望本章的介绍能让你有所收获！</p>
<p>你可以在以下链接找到源码：<a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/005_Surface_Basics/simple_surface.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/005_Surface_Basics/simple_surface.shader</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blogs/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/blogs/">1</a><a class="page-number" href="/blogs/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/blogs/page/4/">4</a><a class="page-number" href="/blogs/page/5/">5</a><a class="extend next" rel="next" href="/blogs/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Tyson Wu"
      src="/blogs/images/avatar.png">
  <p class="site-author-name" itemprop="name">Tyson Wu</p>
  <div class="site-description" itemprop="description">If you want, Just do it!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blogs/archives/">
        
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blogs/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blogs/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Tyson-Wu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Tyson-Wu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/zhao-wu-zhu-43" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;zhao-wu-zhu-43" rel="noopener" target="_blank"><i class="知乎 fa-fw"></i>知乎</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/Hi-blog/" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;Hi-blog&#x2F;" rel="noopener" target="_blank">starnight_cyber</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tyson Wu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blogs/lib/anime.min.js"></script>
  <script src="/blogs/lib/velocity/velocity.min.js"></script>
  <script src="/blogs/lib/velocity/velocity.ui.min.js"></script>

<script src="/blogs/js/utils.js"></script>

<script src="/blogs/js/motion.js"></script>


<script src="/blogs/js/schemes/pisces.js"></script>


<script src="/blogs/js/next-boot.js"></script>




  















  

  

</body>
</html>
