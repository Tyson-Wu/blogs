<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blogs/images/girl_180_0.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blogs/images/girl_32_0.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blogs/images/girl_16_0.png">
  <link rel="mask-icon" href="/blogs/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blogs/css/main.css">


<link rel="stylesheet" href="/blogs/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"tyson-wu.github.io","root":"/blogs/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="If you want, Just do it!">
<meta property="og:type" content="website">
<meta property="og:title" content="TysonWu&#39;s Blog">
<meta property="og:url" content="https://tyson-wu.github.io/blogs/page/3/index.html">
<meta property="og:site_name" content="TysonWu&#39;s Blog">
<meta property="og:description" content="If you want, Just do it!">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Tyson Wu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://tyson-wu.github.io/blogs/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>TysonWu's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blogs/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">TysonWu's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">AiCooXiao</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blogs/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blogs/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blogs/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blogs/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blogs/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/02/Ronja_Triplanar_Mapping/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/02/Ronja_Triplanar_Mapping/" class="post-title-link" itemprop="url">Triplanar Mapping</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-02 13:01:00" itemprop="dateCreated datePublished" datetime="2021-07-02T13:01:00+08:00">2021-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-16 10:27:17" itemprop="dateModified" datetime="2021-12-16T10:27:17+08:00">2021-12-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/010-triplanar-mapping/">Triplanar Mapping</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>在前面我们介绍过二维平面映射的实现方法，这里我们来讲讲三维平面的映射方法。<br>纳尼？平面本身是二维的叫二维平面还可以理解，你这来个三维平面，是欺负我读书少，想糊弄我？？？<br>稍安勿躁！首先专业名字本身依据其专业用途、含义来取的，很容易和我们习惯相冲突，比如数学领域各种眼花缭乱的术语。这里我们的三维平面更多的值得是三维空间上的平面，可以有三个维度的取值。之前提到的二维平面映射，是只从一个方向进行投影，换句话说，我们只用沿着其投影方向进行渲染，才能看到我们的纹理贴合在模型表面，如果换个角度，你可能就看不到了，即便看到了也可能是模糊不清的。而三维平面映射，是从分别从三个维度进行投影映射，然后将得到的三个纹理颜色进行混合，这样无论我们采用怎样刁钻的角度，也挑不出啥毛病。</p>
<p>当然，本文也是在之前的二维平面映射的基础上扩展的，在了解其原理后，你也可以使用表面着色器重写一遍。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/010/Result.gif"></p>
<h2 id="Calcualte-Projection-Planes"><a href="#Calcualte-Projection-Planes" class="headerlink" title="Calcualte Projection Planes"></a>Calcualte Projection Planes</h2><p>首先，为了得到三个不同方向的UV坐标，我们需要改变UV坐标的生成方式。在二维平面映射中，我们是在顶点着色器中进行UV变换。这里我们直接将顶点的世界坐标传递到片段着色器中，然后在片段着色器中进行uv变换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">    float4 position : SV_POSITION;</span><br><span class="line">    float3 worldPos : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    <span class="comment">//计算裁剪空间坐标</span></span><br><span class="line">    o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    <span class="comment">//计算世界坐标</span></span><br><span class="line">    float4 worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">    o.worldPos = worldPos.xyz;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们对三个方向投影所对应的uv坐标进行UV变换。在这里我把世界坐标的<code>y</code>轴对应uv坐标的<code>v</code>，这样渲染出来的纹理就是正的。当然，你也可以随意尝试多种对应关系，看看会有什么不一样的效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//分别计算三个投影方向的uv变换</span></span><br><span class="line">    float2 uv_front = TRANSFORM_TEX(i.worldPos.xy, _MainTex);</span><br><span class="line">    float2 uv_side = TRANSFORM_TEX(i.worldPos.zy, _MainTex);</span><br><span class="line">    float2 uv_top = TRANSFORM_TEX(i.worldPos.xz, _MainTex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用变换后的uv值进行纹理采样，并将三个不同的采样值进行平均。当然你也可以直接求和，不过最终结果会显得非常亮。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分别对三个方向进行纹理采样</span></span><br><span class="line">fixed4 col_front = tex2D(_MainTex, uv_front);</span><br><span class="line">fixed4 col_side = tex2D(_MainTex, uv_side);</span><br><span class="line">fixed4 col_top = tex2D(_MainTex, uv_top);</span><br><span class="line"></span><br><span class="line"><span class="comment">//求平均值</span></span><br><span class="line">fixed4 col = (col_front + col_side + col_top) / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//叠加材质颜色</span></span><br><span class="line">col *= _Color;</span><br><span class="line"><span class="keyword">return</span> col;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/010/AllSides.png"></p>
<h2 id="Normals"><a href="#Normals" class="headerlink" title="Normals"></a>Normals</h2><p>到目前为止，你会发现整个材质表现的非常怪异，各种重影迭起，这是因为我们只是单纯的对三个方向的采样值进行平均。为了消除这种重影，我们可以根据不同的朝向，侧重显示对应朝向的采样值。表面朝向有个专业点的名称：法向向量。在我们的网格数据中就包含法向数据。因为一些特殊考虑，网格数据中的法向和顶点是一一对应的。</p>
<p>所以，我们首先要做的是在我们的输入结构体中加入法向变量，然后在顶点着色其中将其变换到世界坐标系，并且通过插值数据传入到片段着色器中参与后续的计算。这里之所以要变换到世界坐标系，是因为我们的纹理映射是基于世界坐标系的。换句话说，我们在进行计算时，应该保证空间数据的空间一致性。</p>
<p>其中将法向从模型坐标系变换到世界坐标系有些特殊。一般的顶点在两个坐标系之间转换是直接乘以模型矩阵，但是法向是乘以模型矩阵转置的逆矩阵。当然其中的矩阵推导比较复杂，我们记住这个结论就行。如果你好奇心很强，那我这里可以先定性地给你分析一下为什么不能直接乘以模型矩阵。前面说过，法向是垂直与表面的向量，假设我们将模型沿着<code>x</code>轴正方向拉伸，这时候表面相对于<code>y</code>轴会变得越来越陡，如果我们也对法向做同样的拉伸，你会发现法向也变得越来越陡，这时候法向和表面不再是垂直关系。我们这里描述的拉伸实际上就是一个空间变换的操作，因此法向和顶点不能使用同样的空间变换，否则将会打破两者的垂直关系。而模型矩阵转置的逆矩阵正是一种相反的操作，可以始终保持两者的垂直关系。当然我们还需要将该矩阵裁剪为<code>3X3</code>的矩阵，因为<code>4x4</code>矩阵还包含了平移变换，而我们的法向量最为方向是没有位置的概念的，所以需要剔除掉矩阵中的平移部分。</p>
<p>事实上，在实际的代码中，我们可能并不会直接使用模型矩阵转置的逆矩阵，而是会采用一些小巧的方法，尽可能的减少计算量。例如世界到模型的变换矩阵刚好等于模型矩阵的逆矩阵，同时向量与矩阵乘积的顺序调转，刚好可以替代转置操作。所以实际上我们可以用法向量左乘世界到模型的变换矩阵来计算在世界坐标系下的法向量。是不是很绕、很晕？那没办法，给你一张图自己去捂捂！<br><img src="https://www.ronja-tutorials.com/assets/images/posts/010/NormalScaling.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    float3 normal : NORMAL;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">    float4 position : SV_POSITION;</span><br><span class="line">    float3 worldPos : TEXCOORD0;</span><br><span class="line">    float3 normal : NORMAL;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    <span class="comment">//计算裁剪空间下的坐标</span></span><br><span class="line">    o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    <span class="comment">//计算世界空间下的坐标</span></span><br><span class="line">    float4 worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">    o.worldPos = worldPos.xyz;</span><br><span class="line">    <span class="comment">//计算世界空间下的法向量</span></span><br><span class="line">    float3 worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);<span class="comment">//再给你点提提示，向量在左叫左乘，后面是从世界到模型空间的变换矩阵</span></span><br><span class="line">    o.normal = normalize(worldNormal);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在学习渲染的过程中，记住可视化是我们的看家本领，所以很多时候都可以通过渲染后的表现效果来分析我们的计算过程。这里可以将法向量进行可视化，很简单就是直接将法向量当成颜色返回。所谓的高大上的可视化到咱这还不算一行代码的事，实在不行就多写两行！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fixed4(i.normal.xyz, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/010/Normals.png"></p>
<p>在得到世界空间下的法向后，我们还需要对法向取绝对值才能应用到后面的权重分配部分。因为法向作为方向向量其取值是在<code>[-1,1]</code>之间，这也是为什么前面的法向可视化中，朝着负轴向的表面颜色是黑色。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float3 weights = i.normal;</span><br><span class="line">weights = <span class="built_in">abs</span>(weights);</span><br></pre></td></tr></table></figure>

<p>法向的各个轴向值得大小表明了法向与各个轴向的重合程度。所以我们将权重的各个轴向值分别乘以前面三个投影方向的采样值，例如<code>xy</code>投影平面的投影方向是<code>z</code>轴，所以将其采样值乘以<code>z</code>轴的权重值，依次类推。</p>
<p>这里我们不需要做平均，因为我们并不是简单的将三个采样值进行相加。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/010/ZPlane.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在世界坐标系下的法向量当做权重值</span></span><br><span class="line">float3 weights = i.normal;</span><br><span class="line"><span class="comment">//取其绝对值</span></span><br><span class="line">weights = <span class="built_in">abs</span>(weights);</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘以权重值</span></span><br><span class="line">col_front *= weights.z;</span><br><span class="line">col_side *= weights.x;</span><br><span class="line">col_top *= weights.y;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求和</span></span><br><span class="line">fixed4 col = col_front + col_side + col_top;</span><br><span class="line"></span><br><span class="line"><span class="comment">//叠加材质的基本颜色</span></span><br><span class="line">col *= _Color;</span><br><span class="line"><span class="keyword">return</span> col;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/010/AddPlanes.jpg"></p>
<p>上图可以看到整个模型看你来更加凝实了，少了很多眼花缭乱的重影。但是还有一个问题，前面的例子中有一个求平均的过程，但是为甚么要求平均呢，因为求平均可以保证最终混合结果不会过亮。但是我们这里使用法向权重值之和会大概率会大于1,最终导致显示过亮。所以我么可以先除以权重和。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保证权重之和为 1</span></span><br><span class="line">weights = weights / (weights.x + weights.y + weights.z);</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/010/AddPlanesNormalized.jpg"></p>
<p>现在看起来和纹理原本的亮度差不多。</p>
<p>最后一步是尽可能的提高各个投影方向纹理的权重差异。因为上图的显示效果还是有很大一部分相互叠加。这是因为即便某个投影方向有权重优势，但这种优势并不是碾压式的，不能占有绝对比重。为了使强者越强、弱者越弱，指数函数是一个很好地选择。我们先定义一个表示指数的参数。然后在权重之前，对其各个分量执行指数操作。然后在材质面板上调节这个指数参数，观察显示变化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">_Sharpness(<span class="string">&quot;Blend Sharpness&quot;</span>, Range(<span class="number">1</span>, <span class="number">64</span>)) = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> _Sharpness;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指数操作，强者越强，弱者越弱</span></span><br><span class="line">weights = <span class="built_in">pow</span>(weights, _sharpness)</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/010/BlendSharpness.gif"></p>
<p>上面的三维平面映射效果还有些问题，表面45度的地方存在明显的过渡痕迹，不过这种痕迹的出现是由于纹理上下左右边界不衔接导致的。另外三维平面映射的性能消耗要更大，因为这里执行了三次纹理采样。</p>
<p>我们可以将三维平面映射应用在表面着色器上，例如对<code>albedo</code>进行三维平面映射，或者对<code>specular</code>等纹理。但是法向纹理需要额外的操作才行，因为我们在三维平面映射的过程中使用的法向向量，这里不做深入研究了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/010_Triplanar_Mapping&quot;</span>&#123;</span><br><span class="line">	<span class="comment">//材质面板显示的属性</span></span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">		_Sharpness (<span class="string">&quot;Blend sharpness&quot;</span>, Range(<span class="number">1</span>, <span class="number">64</span>)) = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		<span class="comment">//不透明物体</span></span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//纹理数据</span></span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">			fixed4 _Color;</span><br><span class="line">			<span class="keyword">float</span> _Sharpness;</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">				float3 worldPos : TEXCOORD0;</span><br><span class="line">				float3 normal : NORMAL;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				<span class="comment">//计算裁剪空间坐标</span></span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				<span class="comment">//计算世界空间坐标</span></span><br><span class="line">				float4 worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">				o.worldPos = worldPos.xyz;</span><br><span class="line">				<span class="comment">//计算世界空间法向量</span></span><br><span class="line">				float3 worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);</span><br><span class="line">				o.normal = normalize(worldNormal);</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">				<span class="comment">//分别计算三个方向的uv变换</span></span><br><span class="line">				float2 uv_front = TRANSFORM_TEX(i.worldPos.xy, _MainTex);</span><br><span class="line">				float2 uv_side = TRANSFORM_TEX(i.worldPos.zy, _MainTex);</span><br><span class="line">				float2 uv_top = TRANSFORM_TEX(i.worldPos.xz, _MainTex);</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//分别执行三个方向的纹理采样</span></span><br><span class="line">				fixed4 col_front = tex2D(_MainTex, uv_front);</span><br><span class="line">				fixed4 col_side = tex2D(_MainTex, uv_side);</span><br><span class="line">				fixed4 col_top = tex2D(_MainTex, uv_top);</span><br><span class="line"></span><br><span class="line">				<span class="comment">//将法向量当成权重</span></span><br><span class="line">				float3 weights = i.normal;</span><br><span class="line">				<span class="comment">//绝对值</span></span><br><span class="line">				weights = <span class="built_in">abs</span>(weights);</span><br><span class="line">				<span class="comment">//求权重指数</span></span><br><span class="line">				weights = <span class="built_in">pow</span>(weights, _Sharpness);</span><br><span class="line">				<span class="comment">//权重归一</span></span><br><span class="line">				weights = weights / (weights.x + weights.y + weights.z);</span><br><span class="line"></span><br><span class="line">				<span class="comment">//权重应用</span></span><br><span class="line">				col_front *= weights.z;</span><br><span class="line">				col_side *= weights.x;</span><br><span class="line">				col_top *= weights.y;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//求和</span></span><br><span class="line">				fixed4 col = col_front + col_side + col_top;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//应用基本颜色</span></span><br><span class="line">				col *= _Color;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack <span class="string">&quot;Standard&quot;</span> <span class="comment">//当当前着色器不支持时，选择后补着色器中的功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望本文能够帮助你理解什么是三维平面映射。</p>
<p>你可以在以下链接找到源码：<a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/010_Triplanar_Mapping/triplanar_mapping.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/010_Triplanar_Mapping/triplanar_mapping.shader</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/02/Ronja_Color_Interpolation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/02/Ronja_Color_Interpolation/" class="post-title-link" itemprop="url">Color Interpolation</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-02 11:01:00" itemprop="dateCreated datePublished" datetime="2021-07-02T11:01:00+08:00">2021-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-16 10:27:17" itemprop="dateModified" datetime="2021-12-16T10:27:17+08:00">2021-12-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/009-interpolating-colors/">Color Interpolation</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>很多时候，我们的模型需要使用多张纹理，并且同时应用这些纹理，例如地形材质。这时候我们需要通过一些插值的方法将这些纹理采集的颜色进行有效融合。</p>
<p>本教程是在上一个<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Sprite_Shaders/">图片着色器</a>的基础上实现的。但是你也可以根据其基本思路，以表面着色器的形式重写其功能。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/009/Result.png"></p>
<h2 id="Interpolate-Colors"><a href="#Interpolate-Colors" class="headerlink" title="Interpolate Colors"></a>Interpolate Colors</h2><p>首先，我们颜色混合着色器的第一个版本仅仅处理两个纯色之间的混合。因为这样我们就不需要考虑什么纹理、uv之类的。我们只需在加一个颜色变量、以及一个用于混合的参数，这个参数将决定两个颜色的混合权重，这里我们把它设为<code>Range</code>类，这样方便在材质面板上调节参数，同时确保参数的有效性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//材质面板上显示的属性</span></span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color (<span class="string">&quot;Color&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) <span class="comment">//the base color</span></span><br><span class="line">		_SecondaryColor (<span class="string">&quot;Secondary Color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>) <span class="comment">//the color to blend to</span></span><br><span class="line">		_Blend (<span class="string">&quot;Blend Value&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0</span> <span class="comment">//0 is the first color, 1 the second</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//混合参数，或权重</span></span><br><span class="line"><span class="keyword">float</span> _Blend;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于混合的两个颜色</span></span><br><span class="line">fixed4 _Color;</span><br><span class="line">fixed4 _SecondaryColor;</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">虽然我们没有使用纹理的颜色，但是也可以保留顶点着色器中关于UV变换的操作，下一个版本还会用到它。而作为第一个版本，我么只修改片段着色器就可以，直接根据混合参数，将第二种颜色叠加到原先的颜色上。</span><br><span class="line">```c++</span><br><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    fixed4 col = _Color + _SecondaryColor * _Blend;</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>!()[<a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/assets/images/posts/009/BlendColorsAdd.gif]">https://www.ronja-tutorials.com/assets/images/posts/009/BlendColorsAdd.gif]</a></p>
<p>现在我们可以看到混合后颜色的变化了，但是我们始终无法将其颜色完全过度到第二种颜色。这是因为混合参数只改变第二种颜色混入的颜色，而第一种颜色依然存在。</p>
<p>为了实现两种颜色之间的过渡渐变效果，我们需要保证两种颜色的权重和为1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    fixed4 col = _Color * (<span class="number">1</span> - _Blend) + _SecondaryColor * _Blend;</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/009/BlendColors.gif"></p>
<p>这种混合操作叫做线性插值，Unity内置的<code>lerp</code>函数就是实现这个线性插值功能。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    fixed4 col = lerp(_Color, _SecondaryColor, _Blend);</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终两个颜色间的混合着色器源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/009_Color_Blending/Plain&quot;</span>&#123;</span><br><span class="line">	<span class="comment">//材质面板上显示的属性</span></span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color (<span class="string">&quot;Color&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) <span class="comment">//基础颜色</span></span><br><span class="line">		_SecondaryColor (<span class="string">&quot;Secondary Color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>) <span class="comment">//用于混合的颜色</span></span><br><span class="line">		_Blend (<span class="string">&quot;Blend Value&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0</span> <span class="comment">//混合权重，0 表示只显示基础颜色, 1 表示只显示混合颜色</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		<span class="comment">//渲染不透明物体</span></span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="comment">//引入内置变量和函数</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//定义着色器函数</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//混合参数</span></span><br><span class="line">			<span class="keyword">float</span> _Blend;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//两个用于混合的颜色</span></span><br><span class="line">			fixed4 _Color;</span><br><span class="line">			fixed4 _SecondaryColor;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//输入的网格数据</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//中间插值的变量，由顶点着色器到片段着色器</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//顶点着色器</span></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				<span class="comment">//计算裁剪空间下的坐标</span></span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//片段着色器</span></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">				fixed4 col = lerp(_Color, _SecondaryColor, _Blend);</span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Interpolate-Textures"><a href="#Interpolate-Textures" class="headerlink" title="Interpolate Textures"></a>Interpolate Textures</h2><p>我们颜色混合着色器的第二个版本将考虑混合两张纹理贴图的颜色。首先我们删掉前面两个颜色变量，改成两个纹理变量。因为涉及到纹理，所以需要uv坐标来进行纹理采样。之前的纹理采样都执行了uv变换操作，实际上这一步并不是必须的，如果我们不打算缩放纹理的话，这一步就可以省略掉，与之相关的纹理参数也可以省掉。但是我们这里有两张纹理，每张纹理都打算使用各自的缩放参数，这时候可以在顶点着色器中执行uv变换，然后在传给片段着色器，也可以直接在片段着色器中进行uv变换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//材质面板上显示的属性</span></span><br><span class="line">Properties&#123;</span><br><span class="line">    _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; <span class="comment">//基础纹理颜色</span></span><br><span class="line">    _SecondaryTex (<span class="string">&quot;Secondary Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;black&quot;</span> &#123;&#125; <span class="comment">//用于混合的纹理颜色</span></span><br><span class="line">    _Blend (<span class="string">&quot;Blend Value&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0</span> <span class="comment">//混合权重，0 表示只显示基础颜色, 1 表示只显示混合颜色</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义着色器函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输入的网格数据</span></span><br><span class="line">struct appdata&#123;</span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    float2 uv : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中间插值的变量，由顶点着色器到片段着色器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">    float4 position : SV_POSITION;</span><br><span class="line">    float2 uv : TEXCOORD0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点着色器</span></span><br><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    <span class="comment">//计算裁剪空间下的坐标</span></span><br><span class="line">    o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>这里我们是在片段着色其中进行uv变换的。并且使用各自变换后的uv进行纹理采样。在得到采样颜色后，我们就可以和上一个版本一样进行线性插值了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//分别进行uv变换</span></span><br><span class="line">    float2 main_uv = TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">    float2 secondary_uv = TRANSFORM_TEX(i.uv, _SecondaryTex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分别进行纹理采样</span></span><br><span class="line">    fixed4 main_color = tex2D(_MainTex, main_uv);</span><br><span class="line">    fixed4 secondary_color = tex2D(_SecondaryTex, secondary_uv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最终执行线性插值</span></span><br><span class="line">    fixed4 col = lerp(main_color, secondary_color, _Blend);</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/009/BlendTextures.gif"></p>
<p>下面是我们这个图片混合着色器的完整脚本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/009_Color_Blending/Texture&quot;</span>&#123;</span><br><span class="line">	<span class="comment">//材质面板属性显示</span></span><br><span class="line">	Properties&#123;</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; <span class="comment">//第一张图</span></span><br><span class="line">		_SecondaryTex (<span class="string">&quot;Secondary Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;black&quot;</span> &#123;&#125; <span class="comment">//第二张图</span></span><br><span class="line">		_Blend (<span class="string">&quot;Blend Value&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0</span> <span class="comment">//0 表示只显示第一张图, 1 只显示第二张图</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		<span class="comment">//不透明材质</span></span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="comment">//引入内置变量和函数</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//定义着色器函数</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//混合参数</span></span><br><span class="line">			<span class="keyword">float</span> _Blend;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//两张图</span></span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">			sampler2D _SecondaryTex;</span><br><span class="line">			float4 _SecondaryTex_ST;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//输入的网格数据</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//中间的插值数据</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//顶点着色器</span></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				<span class="comment">//变换到裁剪空间</span></span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				o.uv = v.uv;</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//片段着色器</span></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">				<span class="comment">//各自进行uv变换</span></span><br><span class="line">				float2 main_uv = TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">				float2 secondary_uv = TRANSFORM_TEX(i.uv, _SecondaryTex);</span><br><span class="line"></span><br><span class="line">				<span class="comment">//各自进行纹理采样</span></span><br><span class="line">				fixed4 main_color = tex2D(_MainTex, main_uv);</span><br><span class="line">				fixed4 secondary_color = tex2D(_SecondaryTex, secondary_uv);</span><br><span class="line"></span><br><span class="line">				<span class="comment">//线性插值</span></span><br><span class="line">				fixed4 col = lerp(main_color, secondary_color, _Blend);</span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Interpolation-based-on-a-Texture"><a href="#Interpolation-based-on-a-Texture" class="headerlink" title="Interpolation based on a Texture"></a>Interpolation based on a Texture</h2><p>前面连个的混合参数都是一个统一的变量，这样模型表面每个区域的混合权重都一样。为了达到不同权重的混合效果，最后这个版本使用纹理来作为我们的混合参数。</p>
<p>首先我们是将原先的混合变量用一个纹理变量替代。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//材质面板属性</span></span><br><span class="line">Properties&#123;</span><br><span class="line">    _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; <span class="comment">//第一张图</span></span><br><span class="line">    _SecondaryTex (<span class="string">&quot;Secondary Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;black&quot;</span> &#123;&#125; <span class="comment">//第二张图</span></span><br><span class="line">    _BlendTex (<span class="string">&quot;Blend Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;grey&quot;</span> <span class="comment">//混合权重图</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//混合权重</span></span><br><span class="line">sampler2D _BlendTex;</span><br><span class="line">float4 _BlendTex_ST;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于混合的图</span></span><br><span class="line">sampler2D _MainTex;</span><br><span class="line">float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">sampler2D _SecondaryTex;</span><br><span class="line">float4 _SecondaryTex_ST;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>同样的，我们也对权重图进行uv变换，然后再进行采样。但是纹理采样的结果还是颜色，是一个向量，而我们的插值权重是一个标量，这时候我们可以选择其中一个合适的通道值来作为我们的插值权重。和前面一样，最后我们用这个权重值进行颜色插值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//分别进行uv变换</span></span><br><span class="line">    float2 main_uv = TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">    float2 secondary_uv = TRANSFORM_TEX(i.uv, _SecondaryTex);</span><br><span class="line">    float2 blend_uv = TRANSFORM_TEX(i.uv, _BlendTex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分别进行纹理采样</span></span><br><span class="line">    fixed4 main_color = tex2D(_MainTex, main_uv);</span><br><span class="line">    fixed4 secondary_color = tex2D(_SecondaryTex, secondary_uv);</span><br><span class="line">    fixed4 blend_color = tex2D(_BlendTex, blend_uv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选其中红色通道作为混合权重</span></span><br><span class="line">    fixed blend_value = blend_color.r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最终的颜色插值</span></span><br><span class="line">    fixed4 col = lerp(main_color, secondary_color, blend_value);</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/009/BlendWithTexture.png"></p>
<p>好了，下面是完整的着色器脚本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/009_Color_Blending/TextureBasedBlending&quot;</span>&#123;</span><br><span class="line">	<span class="comment">//材质面板上的属性</span></span><br><span class="line">	Properties&#123;</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125; <span class="comment">//第一张图</span></span><br><span class="line">		_SecondaryTex (<span class="string">&quot;Secondary Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;black&quot;</span> &#123;&#125; <span class="comment">//第二张图</span></span><br><span class="line">		_BlendTex (<span class="string">&quot;Blend Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;grey&quot;</span> <span class="comment">//权重图</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		<span class="comment">//渲染不透明物体</span></span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="comment">//引入内置变量和函数</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//定义着色器函数</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//混合权重图</span></span><br><span class="line">			sampler2D _BlendTex;</span><br><span class="line">			float4 _BlendTex_ST;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//用于混合的两张纹理</span></span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">			sampler2D _SecondaryTex;</span><br><span class="line">			float4 _SecondaryTex_ST;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//输入的模型数据</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//中间的插值数据</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//顶点着色器</span></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				<span class="comment">//变换到裁剪空间</span></span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				o.uv = v.uv;</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//片段着色器</span></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">				<span class="comment">//分别进行uv变换</span></span><br><span class="line">				float2 main_uv = TRANSFORM_TEX(i.uv, _MainTex);</span><br><span class="line">				float2 secondary_uv = TRANSFORM_TEX(i.uv, _SecondaryTex);</span><br><span class="line">				float2 blend_uv = TRANSFORM_TEX(i.uv, _BlendTex);</span><br><span class="line"></span><br><span class="line">				<span class="comment">//分别进行纹理采样</span></span><br><span class="line">				fixed4 main_color = tex2D(_MainTex, main_uv);</span><br><span class="line">				fixed4 secondary_color = tex2D(_SecondaryTex, secondary_uv);</span><br><span class="line">				fixed4 blend_color = tex2D(_BlendTex, blend_uv);</span><br><span class="line"></span><br><span class="line">				<span class="comment">//选取一个通道作为混合权重</span></span><br><span class="line">				fixed blend_value = blend_color.r;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//最终的颜色插值</span></span><br><span class="line">				fixed4 col = lerp(main_color, secondary_color, blend_value);</span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望本文能让你了解着色器中颜色的基本使用、以及插值的实际应用。</p>
<p>所有的源码都在以下链接可以找到：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/009_Color_Blending/ColorBlending_Plain.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/009_Color_Blending/ColorBlending_Plain.shader</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/009_Color_Blending/ColorBlending_Texture.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/009_Color_Blending/ColorBlending_Texture.shader</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/009_Color_Blending/ColorBlending_TextureBasedBlending.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/009_Color_Blending/ColorBlending_TextureBasedBlending.shader</a></li>
</ul>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/02/Ronja_Planar_Mapping/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/02/Ronja_Planar_Mapping/" class="post-title-link" itemprop="url">Planar Mapping</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-02 10:01:00" itemprop="dateCreated datePublished" datetime="2021-07-02T10:01:00+08:00">2021-07-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-16 10:27:17" itemprop="dateModified" datetime="2021-12-16T10:27:17+08:00">2021-12-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/008-planar-mapping/">Planar Mapping</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>有时候我们的网格数据中并没有UV坐标，或者说器UV坐标并不适用于将要使用的纹理，或者我们想让纹理和模型表面根据某一规则对齐。或者还有其他什么原因，我们需要动态生成UV坐标。那么接下来的教程，我们将以最简单的方法，二维平面映射，来创建我们的UV坐标。</p>
<p>本教程是在上一个<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Sprite_Shaders/">图片着色器</a>的基础上实现的。但是你也可以根据其基本思路，以表面着色器的形式重写其功能。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/008/Result.png"></p>
<h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><p>首先我们将输入结构体中的uv变量删除掉，因为我们打算通过脚本生成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">    <span class="keyword">float</span> vertex : POSITION;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>因为片段着色器中的输入参数是由顶点着色器中的输出参数插值而得到的，因此我们选择在顶点着色器中计算新的uv值。首先我们将其顶点UV设置为顶点在模型坐标系下的<code>x</code>和<code>z</code>的值。这样足以让纹理出现在模型表面了，并且其效果看起来就好像是图片从上往下投影到模型表面一样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.uv = v.vertex.xz;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Adjustable-Tiling"><a href="#Adjustable-Tiling" class="headerlink" title="Adjustable Tiling"></a>Adjustable Tiling</h2><p>前面并没有考虑图片的缩放，或者我们可能希望图片显示不跟随模型一起旋转。</p>
<p>图片缩放的问题可以通过<code>TRANSFORM_TEX</code>宏来执行UV变换，这样最终用于纹理采样的UV可以跟随纹理缩放而相应改变。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.uv = TRANSFORM_TEX(v.vertex.xz, _MainTex);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/008/AdjustTilingOffset.gif"></p>
<h2 id="Texture-Coordinates-based-on-World-Position"><a href="#Texture-Coordinates-based-on-World-Position" class="headerlink" title="Texture Coordinates based on World Position"></a>Texture Coordinates based on World Position</h2><p>为了消除模型位置、和旋转对UV坐标的影响，我们需要将顶点坐标转换到世界坐标系，前面的例子是使用模型坐标系中的顶点坐标来生成UV坐标的。计算世界坐标的方法很简单，只需要将顶点坐标乘以模型空间矩阵。在我们得到世界坐标后，使用其世界坐标来生成UV坐标。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">	v2f o;</span><br><span class="line">	<span class="comment">//计算裁剪空间下的顶点坐标</span></span><br><span class="line">	o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">	<span class="comment">//计算世界空间下的顶点坐标</span></span><br><span class="line">	float4 worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">	<span class="comment">//应用纹理缩放，执行UV变换</span></span><br><span class="line">	o.uv = TRANSFORM_TEX(worldPos.xz, _MainTex);</span><br><span class="line">	<span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/008/MoveSphere.gif"></p>
<p>从上面我们也可以看到基于世界坐标的二维平面映射也不完美，因为我们必须使用可重复的图片，否则无法覆盖整个空间区域。而且最终用渲染出来的纹理也会因为观察角度不同而发生扭曲。但是我们可以使用更牛的技术来改进，例如后面将会介绍的,三维平面映射。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/008_Planar_Mapping&quot;</span>&#123;</span><br><span class="line">	<span class="comment">//材质面板上显示的属性</span></span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		<span class="comment">//渲染不透明物体</span></span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//定义公共变量</span></span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">			fixed4 _Color;</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				<span class="comment">//计算裁剪空间下的坐标</span></span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				<span class="comment">//计算世界空间下的坐标</span></span><br><span class="line">				float4 worldPos = mul(unity_ObjectToWorld, v.vertex);</span><br><span class="line">				<span class="comment">//执行UV变换</span></span><br><span class="line">				o.uv = TRANSFORM_TEX(worldPos.xz, _MainTex);</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">				<span class="comment">//纹理采样</span></span><br><span class="line">				fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">				<span class="comment">//多个颜色叠加</span></span><br><span class="line">				col *= _Color;</span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack <span class="string">&quot;Standard&quot;</span> <span class="comment">//当当前着色器不支持时，选择后补着色器中的功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以在以下链接找到源码：<a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/008_Planar_Mapping/planar_mapping.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/008_Planar_Mapping/planar_mapping.shader</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Sprite_Shaders/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/01/Ronja_Sprite_Shaders/" class="post-title-link" itemprop="url">Sprite Shaders</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-01 15:01:00" itemprop="dateCreated datePublished" datetime="2021-07-01T15:01:00+08:00">2021-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-16 10:27:17" itemprop="dateModified" datetime="2021-12-16T10:27:17+08:00">2021-12-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/007-sprite-shaders/">Sprite Shaders</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>在Unity中，图片的渲染和三维模型渲染非常相似。并且提供了<code>SpriteRender</code>的组件来实现图片渲染的功能。接下来我也会介绍这个组件、及其实现原理，然后通过我们的着色器来模拟这个组件的功能。</p>
<p>这个教程依赖于上一个<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Basic_Transparency/">透明着色器</a>的教程。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/007/Result.png"></p>
<h2 id="Scene-Setup"><a href="#Scene-Setup" class="headerlink" title="Scene Setup"></a>Scene Setup</h2><p>这里采用一个非常简单的场景来实验我们的图片着色器。首先，我将摄像机改为正交模式，并且将原先的小方块改成<code>sprite renderer</code>，同时将后面用到的图片格式改为<code>sprite</code>。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/007/Hierarchy.png"><br><img src="https://www.ronja-tutorials.com/assets/images/posts/007/CameraInspector.png"><br><img src="https://www.ronja-tutorials.com/assets/images/posts/007/SpriteInspector.png"><br><img src="https://www.ronja-tutorials.com/assets/images/posts/007/SpriteImporter.png"></p>
<h2 id="Changing-the-Shader"><a href="#Changing-the-Shader" class="headerlink" title="Changing the Shader"></a>Changing the Shader</h2><p>在完成以上修改后，将上一章的透明材质放到<code>SpriteRenderer</code>组件的材质属性上，一切准备就绪！</p>
<p><code>SpriteRenderer</code>组件会自动根据附加的图片自动生成一个网格数据，包括顶点、UV等。然后和普通的三维模型一样渲染到场景中。同时在<code>SpriteRenderer</code>上定义的颜色也会以顶点颜色的形式包含在网格数据中。另外还可以设置图片是否翻转。而且图片渲染和半透明渲染一样，是排在不透明渲染之后，甚至大多数渲染之后，而这个渲染队列是由<code>SpriteRenderer</code>自动帮我们设置的。</p>
<p>因为目前我们的半透明着色器还不支持翻转、和顶点颜色。所以接下来我们把这个添加上。</p>
<p>但是当我们翻转后，会发现图片不见了，然后再翻转，图片又出现了。这时因为从性能优化角度考虑，渲染单面比渲染双面更节约性能，这里叫做<code>backface culling</code>背面剔除。普通的不透明模型渲染使用背面剔除非常有效，因为其内部不可能被渲染。另外如果不使用背面剔除，在光照计算的时候会出现怪异的效果，因为参与计算的法向量只会指向正面方向，因此背面计算的结果无效。</p>
<p>在这里我们并不用考虑这个优化项，因为图片、半透明物体之类的并不存在哪个面朝内、哪个面朝外的问题，也不需要参与光照计算。因此我们这里直接关闭背面剔除公共，关闭的设置和之前混合模式、深度写入设置类似。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cull Off</span><br></pre></td></tr></table></figure>

<p>为了在最终的渲染中使用到前面说的顶点颜色数据。我们需要在半透明着色其中做一些修改。首先在输入数据结构和插值数据结构中加入一个四维向量，并标记为颜色类型。然后在顶点着色器中将输入数据结构中的顶点颜色传递给插值数据结构中的颜色值。最终在片段着色器中叠加到输出颜色上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    float2 uv : TEXCOORD0;</span><br><span class="line">    fixed4 color : COLOR;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">    float4 position : SV_POSITION;</span><br><span class="line">    float2 uv : TEXCOORD0;</span><br><span class="line">    fixed4 color : COLOR;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">    o.color = v.color;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">    col *= _Color;</span><br><span class="line">    col *= i.color;</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后的半透明材质就可以应用到<code>SpriteRenderer</code>组件上了，并且可以响应<code>SpriteRenderer</code>上的一些设置操作。在后面的教程中我们还可以在此基础上扩展出更加绚丽的效果。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/007/AdjustVariables.gif"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/007_Sprite&quot;</span>&#123;</span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		Tags&#123; </span><br><span class="line">			<span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Transparent&quot;</span> </span><br><span class="line">			<span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Transparent&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line"></span><br><span class="line">		ZWrite off</span><br><span class="line">		Cull off</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line"></span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">			fixed4 _Color;</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">				fixed4 color : COLOR;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">				fixed4 color : COLOR;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">				o.color = v.color;</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">				fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">				col *= _Color;</span><br><span class="line">				col *= i.color;</span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SpriteRenderer</code>组件还会提供各种网格数据来实现图标、多边形图形、动画效果。</p>
<p>相比于Unity内置的<code>Sprite Shader</code>，我们目前还没有实现的功能有<code>instancing</code>、像素捕捉、<code>alpha</code>通道扩展，因为这些功能比较复杂，而且很少使用，因此我现在不做介绍。</p>
<p>你可以在以下链接找到源码：<a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/007_Sprites/sprite.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/007_Sprites/sprite.shader</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Basic_Transparency/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/01/Ronja_Basic_Transparency/" class="post-title-link" itemprop="url">Basic Transparency</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-01 14:01:00" itemprop="dateCreated datePublished" datetime="2021-07-01T14:01:00+08:00">2021-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-16 10:27:17" itemprop="dateModified" datetime="2021-12-16T10:27:17+08:00">2021-12-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/006-simple-transparency/">Basic Transparency</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>对于不透明物体的渲染，是直接将计算所得到的像素颜色覆盖掉原有的颜色值。而透明物体的渲染方法恰恰相反，是保留原有颜色值，然后两者通过混合后，达到一种看是半透明的效果。为了阐明关键思想，这里以最简单的不受光材质为例。</p>
<p>如果你还不知道如果编写着色器，这里建议你先阅读我之前的<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Basic_Shader/">教程</a><br><img src="https://www.ronja-tutorials.com/assets/images/posts/006/SemitransparentCube.png"></p>
<p>为了达到正确的渲染效果，首先我们需要告诉Unity：我们打算渲染一个透明物体。因此，我们可以将<code>SubShader</code>块中的<code>Tags</code>块的渲染类型改为<code>Transparent</code>，以及将其中的渲染队列改为<code>Transparent</code>。渲染队列的设置是为了保证我们的半透明物体一定是在不透明物体之后渲染。如果不这么设置，根据上面说到的不透明渲染的方法，很可能有不透明物体直接覆盖在半透明物体区域，即便我们的半透明物体在不透明物体的前方。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Transparent&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们要定义混合模式，前面提到需要将半透明的像素颜色和已经渲染的像素颜色相混合，就是通过这个混合模式来决定的。混合模式的定义由两个关键字构成，第一个和半透明颜色相乘，第二个和已有的颜色相乘，然后两者相加。</p>
<p>当我们渲染不透明物体时，我们将第一个参数设为1，第二个参数设为0，这样新的颜色值便会完全替换掉原先的颜色值。而在透明材质中，我们通常使用新颜色的透明通道作为第一个参数，而第二个参数为1减该透明通道值，这样我们就可以调整其透明通道来实现不同程度的透明效果。</p>
<p>混合模式可以定义在<code>SubShader</code>块中，也可以定义在<code>Pass</code>块中，位置的不同决定其作用域的大小。但是必须定义在<code>hlsl</code>代码以外，因为这属于<code>Shaderlab</code>拓展的特性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blend SrcAlpha OneMinusSrcAlpha</span><br></pre></td></tr></table></figure>

<p>你可以从下面网址找到更全面的混合模式设置介绍：<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/SL-Blend.html">https://docs.unity3d.com/Manual/SL-Blend.html</a></p>
<p>为了突出重点，精简逻辑，这里举两个小例子：</p>
<ul>
<li>当我们的片段着色器返回的透明通道值为<code>0.5</code>，那么根据前面设置的混合模式，将会将新的颜色值得一半和旧的颜色值得一一半进行混合。如果新颜色是白色，旧颜色是黑色，那么混合后的将是灰色；</li>
<li>当我们的片段着色器返回的透明通道值为<code>0.9</code>，那么混合后，新颜色将占有90%的比例，而旧颜色只占有%10；</li>
</ul>
<p>因此，在前面不透明着色器脚本的基础上，做以上调整，该着色器就成功变成一个半透明着色器。因为公共变量<code>_Color</code>参与了片段着色器中的颜色计算，所以我们在材质面板修改其透明度，将会影响最终的混合效果。如下：<br><img src="https://www.ronja-tutorials.com/assets/images/posts/006/AdjustTint.gif"></p>
<p>另一个需要修改的地方是关闭透明着色器的深度写入功能。一般来说，当模型被渲染到画面上是，其距离摄像机的深度信息会被记录到一张深度纹理是上。然后后面渲染的模型只需要与这张深度图相比较，就可以正确判断其相互之间的遮挡关系，其中被遮挡的部分将不会渲染到画面上。但是这并不适用于半透明物体，因为即便被遮挡也会被渲染。所以我们只能从其渲染队列方面考虑，将半透明物体限定在不透明物体之后渲染，并且半透明物体之间的渲染排序是由远及近。深度值写入的设置如下，和混合模式设置一样，都可以定义在<code>SubShader</code>或<code>Pass</code>块中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">ZWrite Off</span><br></pre></td></tr></table></figure>

<p>如果我们的纹理贴图也存在半透明通道，那么最终渲染出来的效果将是各个部位的透明程度有差异。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/006/TextureTransparentCube.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/006_Basic_Transparency&quot;</span>&#123;</span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Transparent&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Transparent&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		Blend SrcAlpha OneMinusSrcAlpha</span><br><span class="line">		ZWrite off</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">			fixed4 _Color;</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">				fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">				col *= _Color;</span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可以在以下链接找到源码：<a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/006_Transparency/transparent.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/006_Transparency/transparent.shader</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Surface_Shader_Basics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/01/Ronja_Surface_Shader_Basics/" class="post-title-link" itemprop="url">Surface Shader Basics</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-01 13:01:00" itemprop="dateCreated datePublished" datetime="2021-07-01T13:01:00+08:00">2021-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-16 10:27:17" itemprop="dateModified" datetime="2021-12-16T10:27:17+08:00">2021-12-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/005-simple-surface/">Surface Shader Basics</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>在Unity中，我们可以创建一个空的着色器脚本，然后手动一行一行的去实现整个脚本。当然这种方式比较费时，毕竟着色器有一套固定的流程，因此可以将一部分代码复用，例如光照模型。如果能够直接配置一些参数就能自动生成相关代码，你一定会喜欢吧。Unity就是这么会投其所好，它实现了一种名叫表面着色器的东东，刚好能够满足咱懒人的需求。懒-是推动科技发展的第一生产力，至理名言啊！</p>
<p>那什么是表面作色器呢？在进入正题之前，我建议你先了解最简单的无光照的着色器，如果你不清楚，可以参考我上一个<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Basic_Shader/">教程</a>。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/005/Result.png"></p>
<h2 id="Conversion-to-simple-Surface-Shader"><a href="#Conversion-to-simple-Surface-Shader" class="headerlink" title="Conversion to simple Surface Shader"></a>Conversion to simple Surface Shader</h2><p>相比于前面介绍的着色器实现方法，表面着色器的实现就显得更加简洁，原先需要处理的很多内容都可以剔除，因为Unity会自动帮我们生成相关代码。以上一个教程的着色器脚本为例，如果我们要用表面着色器来实现，那么前面提到的什么顶点着色器都可以不要了。与之相对应的宏命令也可以删除，两者之间的插值数据也可以不要了。甚至是<code>UnityCG.cginc</code>文件也可以不要，还有<code>MainTex_ST</code>等等。这些代码最终都会由Unity自动生成。一顿大刀阔斧，来看看我们的成果吧：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/005_surface&quot;</span> &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		CGPROGRAM</span><br><span class="line"></span><br><span class="line">		sampler2D _MainTex;</span><br><span class="line">		fixed4 _Color;</span><br><span class="line"></span><br><span class="line">		<span class="function">fixed4 <span class="title">frag</span> <span class="params">(v2f i)</span> : SV_TARGET </span>&#123;</span><br><span class="line">			fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">			col *= _Color;</span><br><span class="line">			<span class="keyword">return</span> col;</span><br><span class="line">		&#125;</span><br><span class="line">		ENDCG</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack <span class="string">&quot;Standard&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简洁的令人发指！等等，先别急着感叹，还有事没做完。上面的着色器脚本并不能执行，因为表面着色器有自己的一些要求。</p>
<p>首先，我们需要添加一个新的数据类型作为片段着色器的输入。这个数据类型将会包含所有与片段着色相关的必要数据。当然，我们这个简单的不能再简单的着色器只需要传递UV坐标。UV坐标还是二维向量。但是，这里的UV变量命名有特殊的规则。因为UV坐标是用来纹理采样的，上一章讲过UV变换，每一个纹理都有自己的缩放、偏移参数，所以必须将变换后的UV和对应的纹理相关联。这里采用命名规则来实现，首先UV变量必须以<code>uv</code>开头，然后后面跟随纹理变量的名称。这样，在后面自动生成代码的时候，程序就知道谁和谁配对了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">	float2 uv_MainTex;<span class="comment">//此时配对的纹理是 _MainTex</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来我们要对之前的片段着色其进行修改，使其编程表面着色器。为了区分两者，先把函数名改为<code>surf</code>。然后表面着色器函数是没有返回值的，所以函数返回类型改为<code>void</code>。</p>
<p>然后再拓展出两个参数。第一个参数正是我们刚刚定义好的<code>Input</code>结构，通过这个参数，表面着色器可以获取所有相关的必要参数；第二个参数是一个叫做<code>SurfaceOutputStandard</code>的结构体，从字面意思可以看出，这就是表面着色器的最终输出数据。当然，在函数结束之前，必须计算好、并赋值所有需要外传的参数。除了<code>SurfaceOutputStandard</code>结构外，Unity还定义了其他类似的结构，它们之间的区别在于适用于不同的光照模型。而这些结构中的成员变量就包含了后续光照处理所必须的数据，这些数据的具体含义将在后面介绍。</p>
<p>然后是删除<code>SV_Target</code>语义标识符，因为我们的<code>surf</code>函数的返回类型是<code>void</code>。</p>
<p>最后是把<code>return</code>语句删除。然后将计算所得的数据通过<code>SurfaceOutputStandard</code>传递出去。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">	fixed4 col = tex2D(_MainTex, i.uv_MainTex);</span><br><span class="line">	col *= _Color;</span><br><span class="line">	o.Albedo = col.rgb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一步，我们需要引入光照模型，同时将写好的表面着色器函数与表面着色器相关联，这个和顶点着色器类似，都是通过<code>#pragma</code>来实现。因为我们这里的<code>surf</code>的输出结构是<code>SurfaceOutputStandard</code>，意味着我们使用标准的光照模型。所以在其后我们还得加上<code>Standard</code>来说明所用的光照模型，最后的<code>fullforwordshadows</code>是告诉Unity使用前向阴影。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/005_surface&quot;</span> &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		CGPROGRAM</span><br><span class="line"></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">pragma</span> surface surf Standard fullforwardshadows</span></span><br><span class="line"></span><br><span class="line">		sampler2D _MainTex;</span><br><span class="line">		fixed4 _Color;</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">			float2 uv_MainTex;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">			fixed4 col = tex2D(_MainTex, i.uv_MainTex);</span><br><span class="line">			col *= _Color;</span><br><span class="line">			o.Albedo = col.rgb;</span><br><span class="line">		&#125;</span><br><span class="line">		ENDCG</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/005/SimpleAlbedo.png"></p>
<h2 id="Standard-Lighting-Properties"><a href="#Standard-Lighting-Properties" class="headerlink" title="Standard Lighting Properties"></a>Standard Lighting Properties</h2><p>在<code>SurfaceOutputStandard</code>结构中包含很多材质相关的属性参数，具体如下：</p>
<ul>
<li>Albedo : 表示材质表面的颜色。而材质最终呈现的颜色受光照的影响，因为材质本身只能决定对吸收哪些波段的光。</li>
<li>Normal : 表示材质表面法向向量。法向向量一般和顶点坐标一起，存储在模型数据中，这时候法向向量所在的坐标系是切向空间。什么是切向空间呢？可以简单的理解为沿着模型表面的坐标系。而法向是指垂直与模型表面的方向。法向向量一般要变换到世界坐标系再参与计算。</li>
<li>Emission ：表示材质的自发光特性。一般的的模型渲染依赖于外部光源，如果关闭外部光源，那么模型表现为黑色。而具备自发光材质的模型即便没有外部光源也能显示出原本的颜色。一般场景中的灯具、或者熔岩会使用自发光属性。</li>
<li>Metallic ：表示材质的金属特性。现实中，金属材料和非金属材料的光学特性不一样，例如即便黑色的金属也能在阳光下反射光芒，但是黑色的非金属就表现的黯淡无光。</li>
<li>Smoothness : 表示材质的光滑度。光滑程度主要决定漫反射、和镜面反射之间的权重分布。玻璃的光滑度非常高，所以可以用来做镜子，而一般木材非常粗糙。</li>
<li>Occlusion ：表示环境遮罩特性。举个例子，平坦的桌面上，光线能够达到每个角落。而崎岖不平的背包上，那些深深的褶皱显得格外阴暗。这些因为表面相互遮挡而产生的阴影就是我们这里的环境遮罩效果。</li>
<li>Alpha : 表示材质的透明度。从字面可以很好理解，有些材质是透明的，如玻璃，有些不是，如木头。</li>
</ul>
<p>上面提到的这些参数前三个是向量，后四个是标量。这些参数有些可以直接暴露在材质面板，方便美术编辑材质效果。</p>
<h2 id="Implement-a-few-Lighting-Properties"><a href="#Implement-a-few-Lighting-Properties" class="headerlink" title="Implement a few Lighting Properties"></a>Implement a few Lighting Properties</h2><p>接下来我们把<code>emission</code>、<code>metallic</code>、<code>smoothness</code>三个参数为例，将其作为材质的可调参数。当然你也可以根据实际需求做调整。</p>
<p>首先，我们定义两个公共变量：光滑度和金属度。它们的类型我选择<code>half</code>。一般来说除了坐标采用<code>float</code>，其他的都选<code>half</code>类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">half _Smoothness;</span><br><span class="line">half _Metallic;</span><br></pre></td></tr></table></figure>

<p>然后将这些公共变量添加到<code>Properties</code>块中，将其暴露在材质面板上。但是材质面板并不知道所显示的变量的类型，所以还需要在其名称后增加类型说明，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Properties &#123;</span><br><span class="line">	_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">	_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">	_Smoothness (<span class="string">&quot;Smoothness&quot;</span>, <span class="keyword">float</span>) = <span class="number">0</span></span><br><span class="line">	_Metallic (<span class="string">&quot;Metalness&quot;</span>, <span class="keyword">float</span>) = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>surf</code>函数中，我们可以直接将这些公共变量传递给<code>SurfaceOutputStandard</code>结构体，这样在后续的光照计算中，就可以使用这些参数了，同时我们修改材质面板上的值，便能立即改变材质的表现效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">	fixed4 col = tex2D(_MainTex, i.uv_MainTex);</span><br><span class="line">	col *= _Color;</span><br><span class="line">	o.Albedo = col.rgb;</span><br><span class="line">	o.Metallic = _Metallic;</span><br><span class="line">	o.Smoothness = _Smoothness;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前为止，表面着色器已经基本完成了。但是还有些需要完善的地方，因为我们在材质面板上修改参数时，很容易设置到非法值，最终导致材质显示异常。我们可以在<code>Properties</code>做些小修改，将<code>float</code>修改为<code>Range(0,1)</code>就可以将这些参数限定在一个有效范围内。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Properties &#123;</span><br><span class="line">	_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">	_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">	_Smoothness (<span class="string">&quot;Smoothness&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">	_Metallic (<span class="string">&quot;Metalness&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/005/Inspector.png"></p>
<p>接下来我们添加自发光颜色。同样的我们也需要在公共变量、和<code>Properties</code>中加入<code>_Emission</code>的定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">_Emission (<span class="string">&quot;Emission&quot;</span>, Color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">half3 _Emission;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">o.Emission = _Emission;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/005/Emissive.png"></p>
<p>为了避免自发光材质过度曝光，我们只能将自发光颜色限定在<code>[0-1]</code>之间。当然，如果我们将自发光颜色定义为HDR类型的话，就可以不用担心过曝的问题了。如果我们使用纹理来将材质各个部位的自发光特性差别化，那么可以产生很炫的效果。例如怪兽的眼睛放光的效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[HDR] _Emission (<span class="string">&quot;Emission&quot;</span>, Color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/005/HdrInspector.png"></p>
<h2 id="Minor-Improvements"><a href="#Minor-Improvements" class="headerlink" title="Minor Improvements"></a>Minor Improvements</h2><p>最后，让我们做一些小改动，让我们的材质看起来更自然。首先，我们在着色器脚本最后面加上<code>fallback shader</code>，这样我们可以复用其他着色器中的代码。这里我将标准着色器作为我们的<code>fallback shader</code>，然后复用其中的阴影渲染部分<code>shadow pass</code>的代码，这样就可以让我们的材质也表现出阴影效果。我们使用<code>fullfowardshadows</code>参数进而获得很好的阴影效果。另外我们也可以指定当前着色器的目标平台，例如设置<code>target</code>为3.0。其中<code>target</code>的值越高，表示可以使用的特性越多，但是支持的硬件平台会越少。这里<code>target</code>为3.0，已经可以使用大多数的高级特性了，所以能够实现更好的光照效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/005_surface&quot;</span> &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">		_Smoothness (<span class="string">&quot;Smoothness&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">		_Metallic (<span class="string">&quot;Metalness&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">		[HDR] _Emission (<span class="string">&quot;Emission&quot;</span>, color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		CGPROGRAM</span><br><span class="line"></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">pragma</span> surface surf Standard fullforwardshadows</span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">pragma</span> target 3.0</span></span><br><span class="line"></span><br><span class="line">		sampler2D _MainTex;</span><br><span class="line">		fixed4 _Color;</span><br><span class="line"></span><br><span class="line">		half _Smoothness;</span><br><span class="line">		half _Metallic;</span><br><span class="line">		half3 _Emission;</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">			float2 uv_MainTex;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">			fixed4 col = tex2D(_MainTex, i.uv_MainTex);</span><br><span class="line">			col *= _Color;</span><br><span class="line">			o.Albedo = col.rgb;</span><br><span class="line">			o.Metallic = _Metallic;</span><br><span class="line">			o.Smoothness = _Smoothness;</span><br><span class="line">			o.Emission = _Emission;</span><br><span class="line">		&#125;</span><br><span class="line">		ENDCG</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack <span class="string">&quot;Standard&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/005/Result.png"></p>
<p>希望本章的介绍能让你有所收获！</p>
<p>你可以在以下链接找到源码：<a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/005_Surface_Basics/simple_surface.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/005_Surface_Basics/simple_surface.shader</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Basic_Shader/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/01/Ronja_Basic_Shader/" class="post-title-link" itemprop="url">Basic Shader</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-01 12:01:00" itemprop="dateCreated datePublished" datetime="2021-07-01T12:01:00+08:00">2021-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-16 10:27:17" itemprop="dateModified" datetime="2021-12-16T10:27:17+08:00">2021-12-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/004-basic/">Basic Shader</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>在前面三个教程中，我介绍了着色器工作的基本原理、与结构。接下来我进一步介绍如何修改其中的内容。</p>
<p>在此之前，我并没有介绍着色器的执行代码部分。因为作为入门介绍，我们需要从结构框架入手，而不应该拘泥于细节。在大致了解着色器的实现流程后，接下来让我们来发现更有趣的细节。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/004/Result.png"></p>
<h2 id="What-we-have-so-far"><a href="#What-we-have-so-far" class="headerlink" title="What we have so far"></a>What we have so far</h2><p>下面的着色器脚本，如果你觉得有前三章没有阐述到位的地方，都可以告诉我。我必将事事有会响！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/001-004_Basic_Unlit&quot;</span>&#123;</span><br><span class="line">	<span class="comment">//这些值将会显示在材质面板上</span></span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		<span class="comment">//当前的标签设置表示的是：不透明渲染，和其他不透明物体处以同一渲染队列</span></span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="comment">//这里包括一些工具函数、以及内置变量</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//定义顶点、片段着色函数</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//材质所用的纹理、以及缩放偏移量</span></span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//材质的颜色，具体一点是：当纹理为白色图片时，材质的颜色</span></span><br><span class="line">			fixed4 _Color;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//模型网格、UI等输入数据，基本代表了模型内在属性</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//当经过顶点着色器处理后，处理的数据经过栅格化插值，然后传入片段着色器</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//顶点着色器函数，主要执行坐标的空间变换</span></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				<span class="comment">//将模型各顶点坐标，转换到裁剪空间</span></span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				<span class="comment">//基于图片的缩放偏移参数，对UV进行变换</span></span><br><span class="line">				o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//片段作色器，主要是计算像素点的颜色</span></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">			    <span class="comment">//基于UV坐标，进行纹理采样</span></span><br><span class="line">				fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">				<span class="comment">//将纹理颜色和材质颜色相乘</span></span><br><span class="line">				col *= _Color;</span><br><span class="line">				<span class="comment">//返回最终的像素点颜色</span></span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Fallback <span class="string">&quot;VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Setting-up-the-shader-stages"><a href="#Setting-up-the-shader-stages" class="headerlink" title="Setting up the shader stages"></a>Setting up the shader stages</h2><p>之前提到的顶点着色器、片段着色器，在着色器脚本中实际上就是<code>HLSL</code>函数。只不过，这些函数对应这渲染管线中的特定阶段。为了将这些函数关联到指定阶段，我们可以使用<code>#pragma</code>关键字来说明。前面经常谈到的顶点着色器、和片段着色器是非常重要的两个阶段。因为顶点着色器负责将模型数据转换到裁剪空间，然后经由栅格化处理，进入到片段着色器，最终有片段着色器计算出像素颜色，并写入渲染对象。可以说这两个着色器代表了渲染的基本流程。其中关联函数的操作如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义顶点、片段着色函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点着色器函数，主要执行坐标的空间变换</span></span><br><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//片段作色器，主要是计算像素点的颜色</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Vertex-stage"><a href="#Vertex-stage" class="headerlink" title="Vertex stage"></a>Vertex stage</h2><p>在实现顶点着色器函数之前，我满需要定义好插值数据类型，前面提到过，这类数据是在顶点着色器中计算好，然后传递给片段着色器的。</p>
<p>顶点着色器的主要功能就是执行空间变换，将顶点数据从模型坐标系转换到裁剪坐标系。空间转换可以借助矩阵乘法来实现。但是，很多时候我们并不需要知道乘法的具体实现，因为Unity为我们提供了很多矩阵变换相关的函数。我们可以使用宏命令来引入Unity预先编写好的工具函数。例如<code>#include UnityCG.cginc</code>。其中<code>UnityObjectToClipPos</code>便是实现模型坐标系到裁剪坐标系的工具函数。而<code>UnityCG.cginc</code>文件中处了定义了很多常用的工具函数外，还定义了很多宏操作。宏操作的使用方法和函数的使用类似。例如，用于UV转换的宏<code>TRANSFORM_TEX</code>，使用顶点UV，以及纹理变量为参数，最终得到转换后的UV坐标。</p>
<p>编写好的顶点着色器函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶点着色器函数，主要执行坐标的空间变换</span></span><br><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    <span class="comment">//将模型各顶点坐标，转换到裁剪空间</span></span><br><span class="line">    o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">    <span class="comment">//基于图片的缩放偏移参数，对UV进行变换</span></span><br><span class="line">    o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Fragment-stage"><a href="#Fragment-stage" class="headerlink" title="Fragment stage"></a>Fragment stage</h2><p>在片段着色器中，我们使用由顶点着色器传来的插值数据、以及公共的纹理数据等，来进一步计算每个像素点的颜色。当然，我们可以直接返回白色，如<code>return float4(1,1,1,1);</code>。但是更实际的情况是，我们结合前面提到的数据，通过一些简单、或复杂的计算，来得到比较自然的颜色值。</p>
<p>我们把使用纹理数据的过程叫做纹理采样。因为纹理数据是一整张包含无数像素点的图片，而我们的片段着色器计算的是一个单独像素的颜色。因此我们只需要纹理中的一个像素值。采样的方法也很简单，直接使用<code>tex2D</code>函数就可以，当然还有其他一些复杂一点的采样函数。这里我们以<code>tex2D</code>为例，需要两个参数，第一个是纹理变量，第二个是UV坐标。下面我们除了使用采样后的像素颜色，同时也叠加了公共变量<code>_Color</code>的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段作色器，主要是计算像素点的颜色</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//基于UV坐标，进行纹理采样</span></span><br><span class="line">    fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">    <span class="comment">//将纹理颜色和材质颜色相乘</span></span><br><span class="line">    col *= _Color;</span><br><span class="line">    <span class="comment">//返回最终的像素点颜色</span></span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把上面的各个步骤组合起来，恭喜你，创建了属于你自己的着色器脚本。</p>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/001-004_basic_unlit/basic_unlit.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/001-004_basic_unlit/basic_unlit.shader</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/001-004_Basic_Unlit&quot;</span>&#123;</span><br><span class="line">	<span class="comment">//这些值将会显示在材质面板上</span></span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		<span class="comment">//当前的标签设置表示的是：不透明渲染，和其他不透明物体处以同一渲染队列</span></span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="comment">//这里包括一些工具函数、以及内置变量</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//定义顶点、片段着色函数</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//材质所用的纹理、以及缩放偏移量</span></span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//材质的颜色，具体一点是：当纹理为白色图片时，材质的颜色</span></span><br><span class="line">			fixed4 _Color;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//模型网格、UI等输入数据，基本代表了模型内在属性</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//当经过顶点着色器处理后，处理的数据经过栅格化插值，然后传入片段着色器</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//顶点着色器函数，主要执行坐标的空间变换</span></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				<span class="comment">//将模型各顶点坐标，转换到裁剪空间</span></span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				<span class="comment">//基于图片的缩放偏移参数，对UV进行变换</span></span><br><span class="line">				o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//片段作色器，主要是计算像素点的颜色</span></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">			    <span class="comment">//基于UV坐标，进行纹理采样</span></span><br><span class="line">				fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">				<span class="comment">//将纹理颜色和材质颜色相乘</span></span><br><span class="line">				col *= _Color;</span><br><span class="line">				<span class="comment">//返回最终的像素点颜色</span></span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Fallback <span class="string">&quot;VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Variables/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/01/Ronja_Variables/" class="post-title-link" itemprop="url">Variables</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-01 11:01:00" itemprop="dateCreated datePublished" datetime="2021-07-01T11:01:00+08:00">2021-07-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-16 10:27:17" itemprop="dateModified" datetime="2021-12-16T10:27:17+08:00">2021-12-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/003-variables/">Variables</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>在了解<code>Shaderlab</code>语言的基本结构，以及着色器各个阶段的功能划分，接下来，让我们来学习一下着色器中所用到的变量，以及如何在代码中使用它们。在着色器中，变量可以分为材质变量、模型网格变量、以及各个着色阶段数值传递的中间变量。</p>
<h2 id="Object-Data"><a href="#Object-Data" class="headerlink" title="Object Data"></a>Object Data</h2><p>模型数据。在介绍渲染过程的时候，我所提到的模型数据，实际上就是模型上面的网格数据。从底层角度来看，这些数据定义了模型的几何形状，决定了模型最终显示的形状。不过为了方便描述，我们直接将其归纳为模型数据、或者网格数据。通常情况下，模型数据包含模型中各个顶点的位置、以及三角面片序列。当然有些模型数据还包含的顶点法向、UV、颜色等数据。除了三角面片序列，其他的数据都是逐(个)顶点数据，也就是说顶点法向、UV、颜色、和顶点位置一一对应，具有相同的个数。因为顶点的位置数据是基于模型坐标系，所以，无论模型位置、朝向如何，都不会影响模型数据。所以对于同一种模型，我们可以使用同一个模型数据，然后通过对模型的缩放来实现一定的差异化。</p>
<p>在Unity着色器中， 模型数据首先是传递给顶点着色器，而模型数据通常也是以自定义数据类型表示，Unity也预先帮我们定义了一些类型，例如<code>struct appdata</code>。当然我们也可以按需自定义，类型的名字可以任意，只要不要和已有的重名就行。当然，因为着色器在执行的过程中有一套固定的流程，包括在各个节点使用什么样的数据。而我们定义的类型并不能传达这些信息，因此，需要在自定义类型的成员变量后面加上语义标识。如下所示,通过<code>POSITION</code>来表示我们的<code>vertex</code>是顶点坐标。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">  float4 vertex : POSITION;<span class="comment">//顶点坐标</span></span><br><span class="line">  float2 uv : TEXCOORD0;<span class="comment">//UV坐标</span></span><br><span class="line">&#125;;<span class="comment">//别忘了加分号</span></span><br></pre></td></tr></table></figure>

<p>关于其他定义的语义标识符，可以参考以下链接：<br><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/SL-VertexProgramInputs.html">https://docs.unity3d.com/Manual/SL-VertexProgramInputs.html</a></p>
<h2 id="Interpolators"><a href="#Interpolators" class="headerlink" title="Interpolators"></a>Interpolators</h2><p>插值数据。当顶点着色器将模型数据从模型空间转换到裁剪空间时，顶点着色阶段的任务就已经结束了。这时候需要将处理好的数据传递給下一个阶段，通常情况下是片段着色阶段。但是顶点着色器输出的结果是基于顶点的，但是片段着色器是基于像素点的，例如渲染一个三角形，顶点作色器只处理三个顶点，但是这个三角形投影到屏幕上就不止三个点了，一般会有更多的像素点构成。所以从顶点着色器到片段作色器，前后输出和输入参数个数不对对等，所以需要通过插值的方式来生成其他可能的像素点数据。</p>
<p>这里的插值过程又叫做栅格化处理，因为我们的屏幕是由一格一格的光栅构成，所以有此得名。栅格化处理是由硬件完成的，虽然这一步也属于整个渲染管线的一步，但是我们却不能对其进行修改。所以我们也需要通过语义标识符来告诉硬件，各个数据的用途。例如<code>SV_POSITION</code>就表示投影变换后的顶点坐标，后面也是根据它来进行插值操作，最终得到屏幕像素点。当然还有其他可选的语义标识符可以使用，例如顶点颜色、UV等，用法基本类似。</p>
<p>在习惯上人们通常会将插值数据命名为<code>v2f</code>，也就是<code>vertex to fragment</code>的缩写，表示是从顶点到像素片段的中间变量。具体例子如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该数据是从顶点着色器，经过栅格化处理，传入到片段着色器中</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">  float4 position : SV_POSITION;</span><br><span class="line">  float2 uv : TEXCOORD0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Output-color"><a href="#Output-color" class="headerlink" title="Output color"></a>Output color</h2><p>最终输出的颜色值。片段着色器主要用于计算像素点的颜色，通常计算的颜色值由4维向量表示，分别对应红、绿、蓝、透明四个通道。这里也有一个语义标识符来表示输出的颜色<code>SV_Target</code>。</p>
<h2 id="Uniform-data"><a href="#Uniform-data" class="headerlink" title="Uniform data"></a>Uniform data</h2><p>公共数据。因为GPU的渲染过程是一个并行过程，模型数据传入后，在顶点着色器中，顶点之间属于并列关系，同一时间有多个顶点同时执行顶点着色器的逻辑。可以想象成一个军队，每个士兵拿着自己的武器在战场上做着同样的事情。但是这些数据有一些共性，它们同属于一个模型、引用同一张纹理贴图、受同一个光照影响。但是我们不可能为每一个顶点配置一份相同的数据。因此把这些数据抽象出来，形成一个公共部分，所有顶点都可以共享这些数据。在片段着色器中也类似，每个像素也都可以对同一张纹理进行采样。公共数据有很多，除了前面提到的，还有各种空间矩阵、以及一些自定义需求引入的数据。庆幸的是，大部分公共数据Unity都已经为我们定义好了，并且在程序执行时，会对其自动赋值。只有少数我们自己定义的公共数据需要我们初始化。</p>
<p>定义公共数据也很简单，直接向当前着色器代码中定义变量，不过这些变量必须定义在函数体外部。如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//材质所用的纹理、以及缩放偏移量</span></span><br><span class="line">sampler2D _MainTex;</span><br><span class="line">float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line"><span class="comment">//材质的颜色，具体一点是：当纹理为白色图片时，材质的颜色</span></span><br><span class="line">fixed4 _Color;</span><br></pre></td></tr></table></figure>

<p>只要定义了这些公共变量，那么就可以在<code>C#</code>程序中使用<code>Material.Set[Type]</code>接口来对其进行赋值。很多使用我们希望直接在材质面板上设置这些量，这时候只需要将需要暴露在材质面板的变量，在<code>Properties</code>块中重新声明一下，格式为<code>_Variable(&quot;材质面板上显示的名称&quot;, Type) = DefaultValue</code>。材质面板的显示也可以自定义，功能复杂点的需要重写编辑器脚本，简单点的也可以直接在着色器脚本中实现，只需要在<code>Properties</code>块中的变量前增加相应的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/MaterialPropertyDrawer.html">显示设置</a>。一般的来说，<code>Properties</code>块中的变量和公共变量是一对一的关系，但是纹理比较特殊，因为纹理数据比较复杂，除了纹理本身的数据外，还有纹理的缩放、偏移等参数。这时候公共变量中的纹理除了要声明纹理本身外，还要声明这些缩放、偏移参数。和纹理相关的参数的命名有一个规则，必须是纹理名称加相关参数的缩写符。如这里的缩放、偏移参数的缩写符就是<code>_ST</code>，<code>S</code>表示缩放，<code>T</code>表示偏移。例如下面例子中的<code>Properteis</code>块就和上面的公共变量相对应。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Properties&#123;</span><br><span class="line">  _Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">  _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spaces"><a href="#Spaces" class="headerlink" title="Spaces?"></a>Spaces?</h2><p>在着色器中，我们提到位置坐标，就一定会涉及模型、世界、观察、屏幕、裁剪坐标系。这时候，我们说的坐标，必须联系使用场景，来判断当前坐标是处以哪个坐标系。抛开坐标系谈坐标就是无根之木、无水之源。</p>
<p>模型空间坐标系，是以模型为中心，以模型自身为参考的坐标系。<code>(0,0,0)</code>在模型坐标系中表示的是模型的原点。如果我们旋转模型，那么模型坐标系也会跟着旋转，换句话说，我们对模型的空间操作，实际上是对模型坐标系的空间操作。我们的模型文件中存储的顶点坐标实际上就是模型空间坐标系的。在渲染时，传入顶点着色器的顶点坐标也是模型空间坐标系上的坐标。</p>
<p>世界空间坐标系，是一个绝对空间坐标系，有一个固定的参考点，不会因为某个局部影响而改变。世界空间坐标系也是所有模型的空间纽带。现实中我们描述我们的位置，大概率使用的就是世界坐标系。</p>
<p>观察坐标系是以摄像机为参考的坐标系。裁剪坐标系是在观察坐标系的基础上，经过投影变换后的坐标系。如果我们使用的是透视投影，那么模型在摄像机上的投影将会产生近大远小的效果。屏幕坐标系是在裁剪坐标系的基础上，进一步除处理得到的，其中需要经过栅格化处理、视口变换等，这一系列操作就是方便后面的渲染。而在片段着色器上处理的便是屏幕坐标系下的数据，因此我们很多时候可以忽略掉观察坐标系、和裁剪坐标系，同时，Unity也提供了很多工具函数来处理坐标系变换。</p>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p>所有的教程都有配套源码，可以在教程结尾找到相关链接。因为目前我只是做了一些简单的分析介绍，所有源码在上面已经出现过了，这里直接简单的整理一下。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/001-004_basic_unlit/basic_unlit.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/001-004_basic_unlit/basic_unlit.shader</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/001-004_Basic_Unlit&quot;</span>&#123;</span><br><span class="line">	<span class="comment">//这些值将会显示在材质面板上</span></span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		<span class="comment">//当前的标签设置表示的是：不透明渲染，和其他不透明物体处以同一渲染队列</span></span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="comment">//这里包括一些工具函数、以及内置变量</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//定义顶点、片段着色函数</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//材质所用的纹理、以及缩放偏移量</span></span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//材质的颜色，具体一点是：当纹理为白色图片时，材质的颜色</span></span><br><span class="line">			fixed4 _Color;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//模型网格、UI等输入数据，基本代表了模型内在属性</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//当经过顶点着色器处理后，处理的数据经过栅格化插值，然后传入片段着色器</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//顶点着色器函数，主要执行坐标的空间变换</span></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				<span class="comment">//将模型各顶点坐标，转换到裁剪空间</span></span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				<span class="comment">//基于图片的缩放偏移参数，对UV进行变换</span></span><br><span class="line">				o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//片段作色器，主要是计算像素点的颜色</span></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">			    <span class="comment">//基于UV坐标，进行纹理采样</span></span><br><span class="line">				fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">				<span class="comment">//将纹理颜色和材质颜色相乘</span></span><br><span class="line">				col *= _Color;</span><br><span class="line">				<span class="comment">//返回最终的像素点颜色</span></span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Fallback <span class="string">&quot;VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/06/29/Ronja_HLSL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/06/29/Ronja_HLSL/" class="post-title-link" itemprop="url">HLSL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-29 11:01:00" itemprop="dateCreated datePublished" datetime="2021-06-29T11:01:00+08:00">2021-06-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-16 10:27:17" itemprop="dateModified" datetime="2021-12-16T10:27:17+08:00">2021-12-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/002-hlsl/">HLSL</a></p>
<h2 id="HLSL？"><a href="#HLSL？" class="headerlink" title="HLSL？"></a>HLSL？</h2><p>HLSL是Unity着色器中所使用的一种语言，可以通过HLSL来实现渲染逻辑。HLSL语言是微软设计的、面向D3D的GPU编程语言。严格的说，网络上现有的大多数Unity着色器脚本是通过CG语言编写的，CG是C for Graphics的简写，也就是为图形编辑而设计的C语言。但是CG语法和HLSL有很多共性，同时CG语言在2012年便不再维护，而我们很容易把两者混淆，不过这并不影响我们进一步的学习。理论上，Unity也支持GLSL语言，GLSL是为OpenGL设计的编程语言，也是类C的编程语言。由于HLSL的例子在网络上随处可见，同时Unity会根据平台不同，自动会将着色器脚本翻译为对应的语言，所以我们不必纠结使用哪种语言。为了方便，这里建议直接使用HLSL语言。</p>
<p>因为着色器编程难度较大，所以建议初学者在系统学习过基本的编程，再考虑学习着色器编程。因为着色器脚本是在GPU中运行的，而一般的编辑软件是在CPU中运行，所以在着色器编程过程中，很难进行异常分析。因此这也导致我们开发过程中有很多限制，另外，和普通的软件开发相比，我们需要从不同的角度来思考问题。如果你已经具备了基本的编程素养，知道什么是数据类型、类、函数、循环、条件语句等，也大概知道CPU和GPU的区别、串行与并行的区别，那么欢迎你阅读下面的内容。</p>
<h2 id="Builting-Types"><a href="#Builting-Types" class="headerlink" title="Builting Types"></a>Builting Types</h2><p>首先，我们需要知道在着色器编写过程中，有哪些可以使用的内置数据类型。</p>
<h3 id="Scalar-Values"><a href="#Scalar-Values" class="headerlink" title="Scalar Values"></a>Scalar Values</h3><p>标量。在Unity的hlsl语言中，小数的类型有<code>fixed</code>、<code>half</code>、以及<code>float</code>，整形的类型有<code>int</code>、<code>uint</code>。需要指出的是，在最新的URP渲染管线中，小数的类型只支持<code>half</code>、和<code>float</code>。</p>
<p>在移动端的GPU中，<code>fixed</code>的数据范围为<code>[-2, 2]</code>，其精度为<code>1/256</code>。而<code>half</code>和<code>float</code>分别是16位和32位的浮点数。在PC端的GPU中，这三类都是32位浮点数。所以在后面的内容中，你将会看到我基本上都是使用<code>float</code>来表示小数，当然，后面有工具可以对此进行优化。</p>
<p>整形，也就是我们所知的整数，其中<code>int</code>可以是正数也可以是负数，而<code>uint</code>只能是正数，这两者之间合理的选择，也能达到细微的优化作用。</p>
<p>另外，还支持<code>bool</code>类型，布尔类型数据用于表示是与否的两种状态。如果我们强行将布尔和数值进行加减乘除运算时，那么实际的布尔值的是就变成1、而否就变成0参与计算。</p>
<h3 id="Vector-Values"><a href="#Vector-Values" class="headerlink" title="Vector Values"></a>Vector Values</h3><p>向量。向量在空间上表示的是一个方向，由各个维度的投影分量构成。上提到的标量，从广义上来说是一维向量。向量在HLSL中的表示很简单，只要在上面对应标量的后面加上维度。例如上面的<code>fixed</code>、<code>half</code>、<code>float</code>的四维向量分别是<code>fixed4</code>、<code>half4</code>、<code>float4</code>。向量的使用很常见，例如记录纹理坐标、颜色、位置等信息。</p>
<p>当然，我们也可以访问向量中特定维度的分量。以4维向量v为例，向量数据是一个长度为4的数组，起始索引为0。也就是说v[0]实际上就是访问的第一个维度的值。另外，向量在着色器中主要用于表示空间、和颜色。所以为了方便，可以直接通过维度名称来索引，例如获取x轴的分量可以表示为v.x，获取红色通道的值可以表示为v.r。这些维度、通道的数据就是存储在前面所说的数组中，其顺序为xyzw、和rgba。换句话说，v[0]、v.x、v.r访问的是同一个值。</p>
<p>另外，在实际使用中，我们可能经常遇到需要从一个向量中选取部分值，来重新构成一个新的向量。因此HLSL在语言设计时就引入了这种通过维度、或通道混合的方式来实现向量重构。举个例子：</p>
<ul>
<li>v.xy  ： 选取原向量中的前两个维度，构成一个新的二维向量；</li>
<li>v.zyx ： 选取原向量中的前三个维度，并且调换顺序，构成一个新的三维向量；</li>
<li>v.xxxx:  选取原向量中的第一个维度，构成一个四维向量，新构成的四维向量的各个维度的值都等于原向量中的第一个维度的值；</li>
</ul>
<h3 id="Matrix-Values"><a href="#Matrix-Values" class="headerlink" title="Matrix Values"></a>Matrix Values</h3><p>矩阵。如果说前面的向量是在标量的基础上，朝着一个方向扩展。那么矩阵就是朝着两个方向扩展，分别是横向r、和纵向c。因此矩阵的数据结构是一个二维数组，与标量对应的表示有<code>fixedrxc</code>、<code>halfrxc</code>、<code>floatrxc</code>，其中的r和c表示的是行数和列数。例如<code>float4x4</code>、<code>half3x2</code>、<code>bool2x4</code>。和向量类型，矩阵也可以使用二维数组的方式进行访问，例如<code>matrix[3][2]</code>，访问的是矩阵中第3行、第2列的元素，注意，这里的行号和列号都是从0开始的。除了二维数组的访问方式，还可以使用元素名称进行访问，例如_m32是第3行、第2列的名称。还可以使用名称混合的方式，实现向量重构。例如matrix._m03_m13_m23，是选取矩阵最后一列的前三个元素构成一个三维向量。如果我们采用二维数组的访问方式，但是只传入一个索引号，那么这个索引号表示的是行号，得到的是该行的向量。例如matrix[0]表示的是获取第0行的向量。</p>
<p>矩阵处理非常繁琐，庆幸的是我们很少会需要去单独处理其中的元素，因此可以直接调用现有的辅助函数来实现矩阵运算。</p>
<h3 id="Textures"><a href="#Textures" class="headerlink" title="Textures"></a>Textures</h3><p>HLSL同时也定义了纹理类型。纹理类型比较特殊，这里不做过多讲述，只需要知道，我们可以通过<code>tex2D(texture, coordinate)</code>来对纹理进行采样。当然，在后面的内容我们会了解跟多，I Promise!</p>
<h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p>在数学计算方面，HLSL提供基本的操作方法，例如<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>，可以执行基本的数值计算，而<code>&lt;</code>、<code>&gt;</code>、<code>==</code>、<code>!=</code>、<code>!</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>&amp;&amp;</code>、<code>||</code>可以用于条件比较。除此之外，HLSL还集成了像<code>abs</code>、<code>dot</code>、<code>lerp</code>、<code>pow</code>、<code>min</code>、<code>atan2</code>等常用函数，详情可参考<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-intrinsic-functions">这里</a>。</p>
<p>同时，HLSL也提供一些快捷操作符，例如<code>+=</code>、<code>*=</code>、<code>-=</code>、<code>/=</code>，这些在将操作符左右两边的数据除了后，复值给左边的数据。还有<code>++</code>、<code>--</code>可以用于自增、自减一个单位。</p>
<p>需要注意的是，标量和向量的乘法，是标量乘以向量中的每一个元素，然后生成一个同维度的向量。例如<code>float2(2,7) * 3 == float2(6, 21)</code>。</p>
<p>而矩阵与向量的乘积相对复杂点，在矩阵分析中有介绍，不过直观的理解就是矩阵表示空间坐标系之间的关系，而向量表示空间坐标系中的点、或方向，两者乘积的结果表示向量从一个空间变换到另一个空间。在应用过程中，我们并不太关系该操作的具体实现。初学者可以基于这种直观理解，然后参考模仿现有的应用案例，或者直接从中复制过来，久而久之就知道怎么用了。矩阵向量的乘积使用的函数是<code>mul</code>，具体可以参考<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-mul">这里</a>。</p>
<h2 id="Custom-Types"><a href="#Custom-Types" class="headerlink" title="Custom Types"></a>Custom Types</h2><p>除了内置类型，我们还可以添加一些自定义类型。自定义类型的语法和类C语言的结构体很像，但是需要注意的是，必须在自定义类型后面加上分号<code>;</code>。如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">typeName</span>&#123;</span></span><br><span class="line">  <span class="keyword">float</span> variable;</span><br><span class="line">  float2 otherVariable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>理论上来说，我们也可以使用<code>class</code>关键字、继承、成员函数、甚至是接口类型。但是，目前为止，我只看到使用<code>struct</code>的情况，所以我们依照祖传习惯就好。如果你想做第一个吃螃蟹的人，那么你可以试着将<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/overviews-direct3d-11-hlsl-dynamic-linking-class">这些</a>类C的语法应用上去，能不能正常使用，就全看天意了:-&gt;!</p>
<p>和向量类似，如果我们想访问自定义结构中的成员变量，同样是采用<code>.</code>连接符。例如，instance.variable，或者可以访问成员的成员，如，instance.otherVariable.x。</p>
<h2 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h2><p>变量。在HLSL中，所有的数据都是值类型，这意味着所有操作，都是直接作用在变量上，而不是变量的引用。同时，我们也不需要使用<code>new</code>之类的关键字来创建变量。</p>
<p>当我们希望创建一个向量时，只需要把向量类型当做普通函数调用就可以。例如创建四维向量<code>float4()</code>、<code>float4(1,1,1,1)</code>。在这种情况下，创建向量的所有参数的维度总和，必须等于目标向量的维度。例如创建一个四维向量，可以传入四个标量，也可以传入两个二维向量，还可以传入两个标量加一个二维向量，或者直接传入一个四维向量。如下，以上面的自定义结构为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeName instance;</span><br><span class="line">instance.variable = <span class="number">3.14</span>;</span><br><span class="line">instance.otherVariable = float2(<span class="number">3</span>, <span class="number">1.4</span>);</span><br></pre></td></tr></table></figure>

<p>另外，变量可以声明在函数内、和函数外。如果定义在函数内，那么能在函数内可以使用，并且使用的位置必须在定义之后。如果定义在函数外面，那么所有的函数都可以使用这个变量，不受顺序的影响，但是习惯上我们会将变量统一定义在函数之前。</p>
<h2 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h2><p>在HLSL中，大多是函数都是全局函数。这意味着它们不属于任何数据结构，并且我们可以在任何位置调用它们。这些函数可以传入一个或多个参数，还可以返回计算结果。如果你不希望函数返回任何值，那么你可以在前面声明为<code>viod</code>。如下是一个函数范例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">returnType <span class="title">functionName</span><span class="params">(argType arg1, otherArgType arg2)</span></span>&#123;</span><br><span class="line">  <span class="comment">//在这里实现函数功能逻辑</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们调用函数的时候，只需要写下函数名，以及后面跟的括号。如果函数接受传参的话，直接将所需参数以逗号分隔，依次写在括号内。这里的函数支持重载，函数和其参数共同构成了该函数的唯一标识，所以我们可以定义多个同名、但不同参的函数体。在调用时，程序会自动根据传入参数来判断所调用的函数。</p>
<h2 id="Control-Flow"><a href="#Control-Flow" class="headerlink" title="Control Flow"></a>Control Flow</h2><p>对于大多是着色器，我们只需要一行接一行的执行相关逻辑，就可以实现我们想要的功能。但是有些复杂点的需求，我们可能需要重复执行某些命令，或者需要丢弃某些命令，这就涉及到代码执行路径选择的问题。在程序上这叫分支语句、或者叫条件语句，还有循环语句。很多人认为，使用分支语句会影响着色器的执行效率，尤其是移动端，所以应该使用<code>step</code>来代替分支语句。这中说法显然不对，因为在<code>step</code>这类函数中本身就是基于分支语句实现的。而且使用<code>step</code>这些函数会使我们程序在逻辑上变得复杂，不利于阅读。当然，上面关于执行效率的说法并不是完全没有依据，假如我们使用分支语句，刚好GPU会执行所有路径，然后丢弃其中一条路径的计算结果，这时候确实存着资源浪费。但是这并不能通过其他技术来避免，毕竟有些逻辑本身就存在分支，所以不要下意识的排斥使用条件语句，而应该多考虑代码的整体结构，是否美观、是否易于阅读。</p>
<h3 id="if-statements"><a href="#if-statements" class="headerlink" title="if statements"></a>if statements</h3><p>如下所示的<code>if</code>语句，如果条件为<code>true</code>，那么执行上半部分的逻辑，否则，执行下半部分的逻辑。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">  <span class="comment">//条件为true，执行这里</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">//条件为false，执行这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的<code>else&#123;...&#125;</code>部分是可选的。花括号中的逻辑相当于一个整体。如果我们不使用花括号，那么上面的条件语句只会将其后的一行逻辑代码当成它的分支。上面的<code>condition</code>值可以是<code>bool</code>、或<code>int</code>，也可以是一条语句，但是这条语句的结果必须是前面两者之一。另外，<code>!</code>可以用于逻辑取反，假设我们希望条件为<code>false</code>时执行<code>if</code>后的分支，那么只需要在条件之前加<code>!</code>。</p>
<h3 id="Loops"><a href="#Loops" class="headerlink" title="Loops"></a>Loops</h3><p>除了分支语句，还有另外一种常见的控制流-循环语句。<code>While</code>循环是最简单的循环语句，如果条件为<code>ture</code>时，它将会一直循环下去，直到条件为<code>false</code>为止。如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)&#123;</span><br><span class="line">  <span class="comment">//执行循环逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一点要记住，在<code>while</code>循环语句中，必须要有某一段可执行代码来将条件置为<code>false</code>，如果没有这种代码，那么该循环将会一直执行下去，这是非常严重的问题。</p>
<p>另一种循环叫做<code>for</code>循环，在<code>for</code>循环中可以假如控制循环次数的变量。如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(beforeLoopLogic; condition; inLoopLogic)&#123;</span><br><span class="line">  <span class="comment">//执行循环逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>for</code>循环下循环次数控制方便面，显得更加简单明了。比如从0开始到最大次数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(uint index=<span class="number">0</span>;index&lt;maxValue;index++)&#123;</span><br><span class="line">  <span class="comment">//执行循环逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，我们也可以使<code>while</code>循环来实现同样的功能，但是看起来就没有<code>for</code>循环那么整洁了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">uint index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(index &lt; maxValue)&#123;</span><br><span class="line">  <span class="comment">//执行循环逻辑</span></span><br><span class="line"></span><br><span class="line">  index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的循环语句中都支持<code>break</code>和<code>continue</code>关键字。其中<code>break</code>用于中断循环语句，直接跳出循环。而<code>continue</code>是跳过本次循环，但是会继续执行后续的循环。</p>
<p>好了，本篇终结！希望你能喜欢我的教程。如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/06/25/Ronja_Structure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/06/25/Ronja_Structure/" class="post-title-link" itemprop="url">Structure of Shader</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-25 11:01:00" itemprop="dateCreated datePublished" datetime="2021-06-25T11:01:00+08:00">2021-06-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-16 10:27:17" itemprop="dateModified" datetime="2021-12-16T10:27:17+08:00">2021-12-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/001-structure/">Structure</a></p>
<h2 id="Shader-Structure"><a href="#Shader-Structure" class="headerlink" title="Shader Structure"></a>Shader Structure</h2><p>着色器编程难度较大，在学习初期阶段，我们首先需要学习它的基本结构，以便于后面灵活的修改、应用它们。</p>
<p>现代着色器采用的是可变渲染管线，其中顶点着色器、和片段着色器是其基本组成。除此之外，还有可选部分，几何着色器、曲面细分着色器，但是它们的应用场景比较少。顶点着色器的作用是将模型网格，通过矩阵变换，投影到屏幕(实际是投影到裁剪空间)。同时，顶点着色器的一个非常有用的操作是，执行顶点动画。当顶点坐标变换到屏幕空间后，其所构成的三角面片将被栅格化。为了保证三角面片能够正确显示，从顶点着色器到片段着色器的过程中，需要对顶点进行插值，从而得到三角面片中各个片段的位置、颜色值等。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/001/pipeline.png"></p>
<p>上面简单介绍了着色器的基本流程。接下来我将阐述如何编写着色器、这些“空间坐标系”的具体含义、不同着色器之间的数据传递。但是，我相信了解其基本流程，有助于我们对着色器不同阶段之间的关系有一个直观的理解。因为，在大多数着色器语言中，基本采用了这种基本流程。即便是那些更为高级的、可以通过节点拼接的着色器语言，最终也是将其翻译为这种基本流程。</p>
<h2 id="ShaderLab"><a href="#ShaderLab" class="headerlink" title="ShaderLab"></a>ShaderLab</h2><p>在Unity中，着色器实际上就是一个以<code>.shader</code>结尾的文本文件。我们可以在资源面板下，依次选择<code>Create &gt; Shader &gt;</code>中的着色器模板，当然模板中的内容可能并不是我们想要的，不过没关系，下面我将介绍如何自定义着色器。为了易于上手，这里我以模板着色器<code>Create &gt; Shader &gt; Unlit</code>为参考，编写我们自己的着色器。当然这里我写的和<code>Unlit</code>之间最大的区别在于，我们这个是不会处理雾效，同时又增加了一个颜色属性，这样可以从整体对模型颜色进行调整。接下来我也会一步一步的讲解其实现逻辑。本教程目标是着色器小白，所以你如果有哪里不理解的地方，可以告诉我，促使我对其进行调整，以便于后续学习者能够更加顺畅。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/001-004_Basic_Unlit&quot;</span>&#123;</span><br><span class="line">	<span class="comment">//这些值将会显示在材质面板上</span></span><br><span class="line">	Properties&#123;</span><br><span class="line">		_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		<span class="comment">//当前的标签设置表示的是：不透明渲染，和其他不透明物体处以同一渲染队列</span></span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line"></span><br><span class="line">			<span class="comment">//这里包括一些工具函数、以及内置变量</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//定义顶点、片段着色函数</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//材质所用的纹理、以及缩放偏移量</span></span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//材质的颜色，具体一点是：当纹理为白色图片时，材质的颜色</span></span><br><span class="line">			fixed4 _Color;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//模型网格、UI等输入数据，基本代表了模型内在属性</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//当经过顶点着色器处理后，处理的数据经过栅格化插值，然后传入片段着色器</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//顶点着色器函数，主要执行坐标的空间变换</span></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				<span class="comment">//将模型各顶点坐标，转换到裁剪空间</span></span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				<span class="comment">//基于图片的缩放偏移参数，对UV进行变换</span></span><br><span class="line">				o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//片段作色器，主要是计算像素点的颜色</span></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">			    <span class="comment">//基于UV坐标，进行纹理采样</span></span><br><span class="line">				fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">				<span class="comment">//将纹理颜色和材质颜色相乘</span></span><br><span class="line">				col *= _Color;</span><br><span class="line">				<span class="comment">//返回最终的像素点颜色</span></span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Fallback <span class="string">&quot;VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Whats-ShaderLab"><a href="#Whats-ShaderLab" class="headerlink" title="Whats ShaderLab?"></a>Whats ShaderLab?</h2><p><code>Shaderlab</code>是Unity内置的着色器语言，其中定义了绝大多数渲染模型所需的数据。但是着色器执行渲染逻辑的部分，实际上是采用<code>hlsl</code>、<code>glsl</code>、<code>CG</code>这三种着色语言中的一种。这里<code>hlsl</code>是微软开发的底层着色器语言，<code>glsl</code>是英伟达开发的底层着色器语言，<code>CG</code>是更为高级的作色器语言。而这些执行部分在<code>Shaderlab</code>中占有一个独立的区域。具体一点，<code>Shaderlab</code>是在执行<code>hlsl</code>、<code>glsl</code>、<code>CG</code>的基础上，扩展了一些属于自身的语法，其中包括<code>Properties</code>属性块，用来关联外部输入参数。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/002/LanguageAreas.png"></p>
<p>从上图可以看到，实际<code>ShaderLab</code>扩展的仅占着色器很小区域。其中一部分原因是：<code>Shaderlab</code>不是可执行语言，而是一种抽象的描述性语言，定义了着色器有哪些输入参数、需要执行哪些渲染操作。而Unity便会识别这些描述性语言，然后将其翻译为GPU可执行的作色器语言，同时关联渲染所需的数据。对于一些简单的渲染需求，参考上图的例子，然后对<code>CG</code>部分进行简单的调整就行了。</p>
<h2 id="Shader-SubShader-Pass"><a href="#Shader-SubShader-Pass" class="headerlink" title="Shader/SubShader/Pass"></a>Shader/SubShader/Pass</h2><p>在上图中，你可能也发现了，其中有很多个<code>&#123;&#125;</code>花括号，将程序分为很多个块。下面我们来看看，这些块到底是干嘛的。</p>
<p>首先，最外层的<code>Shader</code>块，代表了整个作色器。在我们创建材质球后，需要在材质球面板上选择所需的着色器，从而得到我们所需的材质球。那些在材质面板上的着色器名称，实际上就是紧跟在<code>Shader</code>块后面的字符串。在这个字符串中，我们可以使用<code>/</code>反斜杠来对着色器进行有效的组织分类，这很像我们文件目录的组织形式。在本教程中，我将所有的着色器划分到<code>Tutorial</code>这个大类中，其中还会细分出一些小类。当然，这些分类可以根据需要随意改动，只要达到有效组织的目的就行。<br>可以看到，所谓的着色器，实际上也就是一连串描述的文本文件。需要注意的是，一个文本文件，只能定义一个着色器。但是，一个着色器却可以复用另一个着色器的功能。例如，在<code>Shader</code>块中，也就是最外层花括号中，我们可以定义<code>fallback shader</code>，当Unity将其翻译为更底层的着色器代码时，会将<code>fallback shader</code>中的<code>SubShader</code>块复制过来。</p>
<p>在<code>Shader</code>块中，可以定义多个<code>SubShader</code>块。在模型渲染时，只会从中选择一个<code>SubShader</code>来执行，而具体选择哪个，依赖于实际运行的平台。可惜的是，关于如何定义<code>SubShader</code>的说明文档极其匮乏，根据我多年的经验，在很多情况下，一个<code>Shader</code>块中只定义一个<code>SubShader</code>能满足基本需求，减少很多不必要的麻烦。凡事皆有特例，当我们想实现阴影效果时，需要在当前<code>SubShader</code>块中实现相应的<code>ShadowPass</code>，每次都实现一遍很麻烦。因为阴影着色流程基本固定，所以Unity提供的现成的便可以使用，这时候，我们可以使用包含阴影着色逻辑的<code>fallback shader</code>，当渲染时，从该<code>SubShader</code>中未找到可以使用的<code>ShadowPadd</code>时，便会从<code>fallback shader</code>中去查找。大多数情况下，我们使用<code>VertexLit</code>着色器，来作为我们的<code>fallback shader</code>，因为<code>VertexLit</code>中的逻辑简单、性能消耗低、基本上能够兼容所有的显卡，也可能是大家相互Copy，从而形成<code>VertexLit</code>流行的假象:-)。另外，在<code>SubShader</code>块中，我们可以定义<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/SL-SubShaderTags.html">Subshader tags</a>；还可以定义多个<code>Pass</code>，例如前面说的<code>Shadow pass</code>；以及属性，在<code>SubShader</code>块中定义的属性是由所有<code>Pass</code>共享的。</p>
<p>一个<code>Pass</code>包含一套完整的渲染流程，从底层着色语言的角度来看，一个<code>Pass</code>才是实际上的着色器，它将模型数据转换为五彩斑斓的画面。在内置渲染管线中，如果我们在<code>SubShader</code>块中定义了多个<code>Pass</code>，当该<code>SubShader</code>被平台选定时，其中的<code>Pass</code>将会被一个接着一个的执行(而最新的URP渲染管线，目前仅支持单个光照<code>Pass</code>)。对于具有多个<code>Pass</code>的<code>SubShader</code>，我们可以将其公共属性等数据定义在<code>SubShader</code>中，而<code>Pass</code>中定义一些独有的数据或逻辑。</p>
<h2 id="Properties-and-Tags"><a href="#Properties-and-Tags" class="headerlink" title="Properties and Tags"></a>Properties and Tags</h2><p>你们可能注意到，在上图中还有两个块<code>Properties</code>、<code>Tags</code>未被提及，那我们继续吧。</p>
<p>在很多编程语言中有字典的概念，顾名思义，就是类似汉语字典一样，可以通过拼音、笔画等关键信息进行快速检索。这里的<code>Tags</code>就可以类比到字典，在<code>Tags</code>中可以定义多个关键字，以及关键字所对应的值，它们公共构成了着色器的配置参数。其中关键字表示了参数的类型，值表示了参数的实际设置。在<code>SubShader</code>中，可以通过<code>Tags</code>定义着色器的材质表现、渲染顺序、以及其他操作；而<code>Pass</code>中的<code>Tags</code>主要定义了光照模式。详细的说明可以参考<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/SL-SubShaderTags.html">SubShader Tags</a>和<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/SL-PassTags.html">Pass Tags</a>。</p>
<p><code>Properties</code>属性块，主要用来定义材质面板中的属性显示。通过材质面板来调整材质参数具有一定的局限性，因为整个调整是以材质球为单位，也就是说，如果多个模型使用同一个材质球，那么就无法做到材质差异化。这时候需要创建多个材质球，分别对应于不同的模型。在接下来得教程中我也会详细讨论<code>Properties</code>的使用。</p>
<p>下面我们对<code>Shaderlab</code>的基本结构进行一个总结：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Category/Name&quot;</span>&#123;</span><br><span class="line">	Properties&#123;</span><br><span class="line">		<span class="comment">//用于材质面板显示、与配置的属性</span></span><br><span class="line">	&#125;</span><br><span class="line">	Subshader&#123;</span><br><span class="line">		Tags&#123;</span><br><span class="line">			<span class="comment">//一些公共配置，涉及渲染类型、渲染顺序等设置</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//公共设置、属性、方法可以写在Subshader中</span></span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			Tags&#123;</span><br><span class="line">				<span class="comment">//主要是光照模式的配置</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//单个Pass的设置， 例如剔除、模板等</span></span><br><span class="line"></span><br><span class="line">			CGPROGRAM</span><br><span class="line">			<span class="comment">//实际执行的渲染程序、以及所用到的属性参数</span></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><p>所有的教程都有配套源码，可以在教程结尾找到相关链接。因为目前我只是做了一些简单的分析介绍，所有源码在上面已经出现过了，这里直接简单的整理一下。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/001-004_basic_unlit/basic_unlit.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/001-004_basic_unlit/basic_unlit.shader</a></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/001-004_Basic_Unlit&quot;</span>&#123;</span><br><span class="line">	<span class="comment">//这些值将会显示在材质面板上</span></span><br><span class="line">	Properties&#123;</span><br><span class="line"><span class="comment">//	_Color (&quot;Tint&quot;, Color) = (0, 0, 0, 1)</span></span><br><span class="line"><span class="comment">//	_MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		<span class="comment">//当前的标签设置表示的是：不透明渲染，和其他不透明物体处以同一渲染队列</span></span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//		//这里包括一些工具函数、以及内置变量</span></span><br><span class="line"><span class="comment">//		#include &quot;UnityCG.cginc&quot;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//		//定义顶点、片段着色函数</span></span><br><span class="line"><span class="comment">//		#pragma vertex vert</span></span><br><span class="line"><span class="comment">//		#pragma fragment frag</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//		//材质所用的纹理、以及缩放偏移量</span></span><br><span class="line"><span class="comment">//		sampler2D _MainTex;</span></span><br><span class="line"><span class="comment">//		float4 _MainTex_ST;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//		//材质的颜色，具体一点是：当纹理为白色图片时，材质的颜色</span></span><br><span class="line"><span class="comment">//		fixed4 _Color;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//		//模型网格、UI等输入数据，基本代表了模型内在属性</span></span><br><span class="line"><span class="comment">//		struct appdata&#123;</span></span><br><span class="line"><span class="comment">//			float4 vertex : POSITION;</span></span><br><span class="line"><span class="comment">//			float2 uv : TEXCOORD0;</span></span><br><span class="line"><span class="comment">//		&#125;;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//		//当经过顶点着色器处理后，处理的数据经过栅格化插值，然后传入片段着色器</span></span><br><span class="line"><span class="comment">//		struct v2f&#123;</span></span><br><span class="line"><span class="comment">//			float4 position : SV_POSITION;</span></span><br><span class="line"><span class="comment">//			float2 uv : TEXCOORD0;</span></span><br><span class="line"><span class="comment">//		&#125;;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//		//顶点着色器函数，主要执行坐标的空间变换</span></span><br><span class="line"><span class="comment">//		v2f vert(appdata v)&#123;</span></span><br><span class="line"><span class="comment">//			v2f o;</span></span><br><span class="line"><span class="comment">//			//将模型各顶点坐标，转换到裁剪空间</span></span><br><span class="line"><span class="comment">//			o.position = UnityObjectToClipPos(v.vertex);</span></span><br><span class="line"><span class="comment">//			//基于图片的缩放偏移参数，对UV进行变换</span></span><br><span class="line"><span class="comment">//			o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span></span><br><span class="line"><span class="comment">//			return o;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//		//片段作色器，主要是计算像素点的颜色</span></span><br><span class="line"><span class="comment">//		fixed4 frag(v2f i) : SV_TARGET&#123;</span></span><br><span class="line"><span class="comment">//			//基于UV坐标，进行纹理采样</span></span><br><span class="line"><span class="comment">//			fixed4 col = tex2D(_MainTex, i.uv);</span></span><br><span class="line"><span class="comment">//			//将纹理颜色和材质颜色相乘</span></span><br><span class="line"><span class="comment">//			col *= _Color;</span></span><br><span class="line"><span class="comment">//			//返回最终的像素点颜色</span></span><br><span class="line"><span class="comment">//			return col;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Fallback <span class="string">&quot;VertexLit&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blogs/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/blogs/">1</a><a class="page-number" href="/blogs/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/blogs/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/blogs/page/6/">6</a><a class="extend next" rel="next" href="/blogs/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Tyson Wu"
      src="/blogs/images/avatar.png">
  <p class="site-author-name" itemprop="name">Tyson Wu</p>
  <div class="site-description" itemprop="description">If you want, Just do it!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blogs/archives/">
        
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blogs/categories/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blogs/tags/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Tyson-Wu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Tyson-Wu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/zhao-wu-zhu-43" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;zhao-wu-zhu-43" rel="noopener" target="_blank"><i class="知乎 fa-fw"></i>知乎</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/Hi-blog/" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;Hi-blog&#x2F;" rel="noopener" target="_blank">starnight_cyber</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tyson Wu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blogs/lib/anime.min.js"></script>
  <script src="/blogs/lib/velocity/velocity.min.js"></script>
  <script src="/blogs/lib/velocity/velocity.ui.min.js"></script>

<script src="/blogs/js/utils.js"></script>

<script src="/blogs/js/motion.js"></script>


<script src="/blogs/js/schemes/pisces.js"></script>


<script src="/blogs/js/next-boot.js"></script>




  















  

  

</body>
</html>
