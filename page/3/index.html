<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blogs/images/girl_180_0.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blogs/images/girl_32_0.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blogs/images/girl_16_0.png">
  <link rel="mask-icon" href="/blogs/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blogs/css/main.css">


<link rel="stylesheet" href="/blogs/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"tyson-wu.github.io","root":"/blogs/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="If you want, Just do it!">
<meta property="og:type" content="website">
<meta property="og:title" content="TysonWu&#39;s Blog">
<meta property="og:url" content="https://tyson-wu.github.io/blogs/page/3/index.html">
<meta property="og:site_name" content="TysonWu&#39;s Blog">
<meta property="og:description" content="If you want, Just do it!">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Tyson Wu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://tyson-wu.github.io/blogs/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>TysonWu's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blogs/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">TysonWu's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">AiCooXiao</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blogs/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blogs/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blogs/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blogs/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blogs/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/08/Ronja_Value_Noise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/08/Ronja_Value_Noise/" class="post-title-link" itemprop="url">Value Noise</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-08 19:01:00" itemprop="dateCreated datePublished" datetime="2021-07-08T19:01:00+08:00">2021-07-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-30 00:35:25" itemprop="dateModified" datetime="2022-08-30T00:35:25+08:00">2022-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/025-value-noise/">Value Noise</a></p>
<p><a href="https://tyson-wu.github.io/blogs/2021/07/08/Ronja_White_Noise/">上一篇</a>文章介绍了如何在着色器中生成随机数。这里我想对前面生成的随机噪声图进行插值，得到一个光滑、渐变的噪声图。因为我们需要事先生成好的噪声图来进行插值，所以建议你先阅读<a href="https://tyson-wu.github.io/blogs/2021/07/08/Ronja_White_Noise/">上一篇</a>来实现噪声图。本篇讲的值噪声和泊林噪声有点区别，首先两者都是在上一篇生成的随机噪声的基础上进一步平滑得到的，区别在于，本篇将上一篇得到的噪声当做值来处理，而泊林噪声则将其当做方向来处理。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/025/Result.gif"></p>
<h2 id="Show-a-Line"><a href="#Show-a-Line" class="headerlink" title="Show a Line"></a>Show a Line</h2><p>首先我们来实现一个简单的一维噪声可视化显示，这个是以<a href="https://tyson-wu.github.io/blogs/2021/07/08/Ronja_White_Noise/">上一篇</a>中的噪声块为起点，然后改变这个色块的尺寸变量为标量，因为我们将处理的是一维数据。然后我们只通过世界坐标的<code>x</code>值来生成一维噪声。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Properties &#123;</span><br><span class="line">    _CellSize (<span class="string">&quot;Cell Size&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> _CellSize;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> value = <span class="built_in">floor</span>(i.worldPos.x / _CellSize);</span><br><span class="line">    o.Albedo = rand1dTo1d(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/025/1dValues.png"></p>
<p>这样我们可以看到我们的噪声图沿着<code>x</code>方向分布。接下来我们将这个分布图改为曲线表示，这样我们可以清楚地看到噪声的变化情况。首先我们将像素点的<code>y</code>坐标减去该像素的噪声值，然后取绝对值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> value = <span class="built_in">floor</span>(i.worldPos.x / _CellSize);</span><br><span class="line">    <span class="keyword">float</span> noise = rand1dTo1d(value);</span><br><span class="line">    <span class="keyword">float</span> dist = <span class="built_in">abs</span>(noise - i.worldPos.y);</span><br><span class="line">    o.Albedo = dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/025/CellDistance.png"></p>
<p>然后我们使用这个差值，并且设定一个阈值来剔除远离噪声值得点，这样我们就得到一根细细的线，不过这个阈值不好选定，线的粗细也不好控制。这里有一个更好的方法，通过计算像素值之间的梯度值，我们可以精确的到宽度为1个像素的细线。需要用到的函数就是<code>fwidth</code>，这个函数会自动比较相邻像素之间的值，然后返回梯度值。这里我们对世界坐标点的<code>y</code>求梯度，其物理含义是像素点的单位长度。所以用像素点的单位长度来作为阈值，就可以控制线的粗细了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> value = <span class="built_in">floor</span>(i.worldPos.x / _CellSize);</span><br><span class="line">    <span class="keyword">float</span> noise = rand1dTo1d(value);</span><br><span class="line">    <span class="keyword">float</span> dist = <span class="built_in">abs</span>(noise - i.worldPos.y);</span><br><span class="line">    <span class="keyword">float</span> pixelHeight = fwidth(i.worldPos.y);</span><br><span class="line">    <span class="keyword">float</span> lineIntensity = smoothstep(<span class="number">0</span>, pixelHeight, dist);</span><br><span class="line">    o.Albedo = lineIntensity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/025/CellLine.png"></p>
<h2 id="Interpolate-Cells-in-one-Dimension"><a href="#Interpolate-Cells-in-one-Dimension" class="headerlink" title="Interpolate Cells in one Dimension"></a>Interpolate Cells in one Dimension</h2><p>为了实现色块之间插值功能，首先我们需要在片段着色器中执行两次噪声采样，分别是当前色块，和上一个色块。我们可以用<code>floor</code>和<code>ceil</code>两个函数，来计算上下两个色块的值。这里我们还可以直接使用坐标的小数部分作为插值位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> value = i.worldPos.x / _CellSize;</span><br><span class="line"><span class="keyword">float</span> previousCellNoise = rand1dTo1d(<span class="built_in">floor</span>(value));</span><br><span class="line"><span class="keyword">float</span> nextCellNoise = rand1dTo1d(<span class="built_in">ceil</span>(value));</span><br><span class="line"><span class="keyword">float</span> noise = lerp(previousCellNoise, nextCellNoise, frac(value));</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/025/LinearLine.png"></p>
<p>插值后得到一根连续的曲线，不过我希望曲线更光滑一点。因此，我们可以实现简单的缓动函数，后面我们还会深入的介绍缓动函数，不过这里使用简单的几种就够了。首先我们实现名为<code>easeIn</code>的缓入函数，这里我们执行平方操作，这样插值的边界值还是0-1，但是在接近0的时候变化更缓慢。然后我们将缓入函数应用到我们的插值中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">float</span> <span class="title">easeIn</span><span class="params">(<span class="keyword">float</span> interpolator)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> interpolator * interpolator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> interpolator = frac(value);</span><br><span class="line">interpolator = easeIn(interpolator);</span><br><span class="line"><span class="keyword">float</span> noise = lerp(previousCellNoise, nextCellNoise, interpolator);</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/025/EaseIn.png"></p>
<p>使用缓入函数后，我们发现色块的开头位置更加平缓。下面我们再实现一个名为<code>EaseOut</code>的缓出函数，使得色块结尾位置更加平缓。在实现缓出函数时，我们利用了前面的缓入函数，不过将插值翻了个个，这样就是1附近的值变化更缓慢。然后我们还要将结果翻转一遍，这样可以保证缓入缓出同时应用的时候，连接部位是光滑的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">easeOut</span><span class="params">(<span class="keyword">float</span> interpolator)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> - easeIn(<span class="number">1</span> - interpolator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一步是将两者结合，实现缓入缓出的效果。这里我们还是使用线性插值函数，当插值接近0时，我们倾向于使用缓入效果，当插值接近1时，我们倾向于使用缓出效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">easeInOut</span><span class="params">(<span class="keyword">float</span> interpolator)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> easeInValue = easeIn(interpolator);</span><br><span class="line">    <span class="keyword">float</span> easeOutValue = easeOut(interpolator);</span><br><span class="line">    <span class="keyword">return</span> lerp(easeInValue, easeOutValue, interpolator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> interpolator = frac(value);</span><br><span class="line">interpolator = easeInOut(interpolator);</span><br><span class="line"><span class="keyword">float</span> noise = lerp(previousCellNoise, nextCellNoise, interpolator);</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/025/SmoothLine.png"></p>
<p>有了缓入缓出函数，我们就可以对我们的一维噪声色块进行平滑处理了。</p>
<h2 id="Interpolate-Cells-in-two-Dimensions"><a href="#Interpolate-Cells-in-two-Dimensions" class="headerlink" title="Interpolate Cells in two Dimensions"></a>Interpolate Cells in two Dimensions</h2><p>实现两个维度的插值，我们可以选择相邻的四个色块。然后沿着<code>x</code>轴进行平滑处理、再沿着<code>y</code>轴进行平滑处理。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/025/2dInterpolationRules.png"></p>
<p>现在代码量比较多，所以我们单独封装一个函数来执行者两个维度的插值逻辑。这里我们使用<code>rand2dTo1d</code>分别计算四个色块的噪声值，然后分别计算<code>x</code>、<code>y</code>轴方向的缓入缓出插值，首先沿着<code>x</code>方向计算两两之间的插值，然后将结果沿着<code>y</code>方向计算最终的插值结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">ValueNoise2d</span><span class="params">(float2 value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> upperLeftCell = rand2dTo1d(float2(<span class="built_in">floor</span>(value.x), <span class="built_in">ceil</span>(value.y)));</span><br><span class="line">    <span class="keyword">float</span> upperRightCell = rand2dTo1d(float2(<span class="built_in">ceil</span>(value.x), <span class="built_in">ceil</span>(value.y)));</span><br><span class="line">    <span class="keyword">float</span> lowerLeftCell = rand2dTo1d(float2(<span class="built_in">floor</span>(value.x), <span class="built_in">floor</span>(value.y)));</span><br><span class="line">    <span class="keyword">float</span> lowerRightCell = rand2dTo1d(float2(<span class="built_in">ceil</span>(value.x), <span class="built_in">floor</span>(value.y)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> interpolatorX = easeInOut(frac(value.x));</span><br><span class="line">    <span class="keyword">float</span> interpolatorY = easeInOut(frac(value.y));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> upperCells = lerp(upperLeftCell, upperRightCell, interpolatorX);</span><br><span class="line">    <span class="keyword">float</span> lowerCells = lerp(lowerLeftCell, lowerRightCell, interpolatorX);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> noise = lerp(lowerCells, upperCells, interpolatorY);</span><br><span class="line">    <span class="keyword">return</span> noise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">    float2 value = i.worldPos.xy / _CellSize;</span><br><span class="line">    <span class="keyword">float</span> noise = ValueNoise2d(value);</span><br><span class="line"></span><br><span class="line">    o.Albedo = noise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/025/Grey2dNoise.png"></p>
<h2 id="Interpolate-Cells-in-Three-Dimensions-and-Loops"><a href="#Interpolate-Cells-in-Three-Dimensions-and-Loops" class="headerlink" title="Interpolate Cells in Three Dimensions and Loops"></a>Interpolate Cells in Three Dimensions and Loops</h2><p>三个维度的插值方法和两个维度的方法基本一致。首先需要选择八个相邻的色块，然后沿着<code>x</code>轴进行两两插值，其结果再沿着<code>y</code>轴进行两两插值，其结果再沿着<code>z</code>轴两两插值，得到最终的插值结果。</p>
<p>但是为三维插值重写上面的方法，会产生很多行代码，不利于理解和管理。所以我们使用循环语句来避免这个问题。这里每个循环迭代两次，分别计算相邻两个需要插值的量。而最内层的循环将计算<code>x</code>方向相邻色块的值，然后存入临时数组中，待执行完后，计算<code>x</code>方向的插值。这里我们在循环语句前加<code>[unroll]</code>，表示我们的循环在编译时会被展开。因为GPU执行循环语句比较慢，而展开后便不再是循环语句了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> interpolatorX = easeInOut(frac(value.x));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> y = <span class="number">0</span>, z = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> cellNoiseX[<span class="number">2</span>];</span><br><span class="line">[unroll]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;=<span class="number">1</span>;x++)&#123;</span><br><span class="line">    float3 cell = <span class="built_in">floor</span>(value) + float3(x, y, z);</span><br><span class="line">    cellNoiseX[x] = rand3dTo1d(cell);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">float</span> interpolatedX = lerp(cellNoiseX[<span class="number">0</span>], cellNoiseX[<span class="number">1</span>], interpolatorX);</span><br></pre></td></tr></table></figure>
<p>然后在外层再套一个循环，这个循环也会执行两次，然后将上一个循环中的插值结果存入临时数组，待结束后进行插值。这个操作和前面的二维插值效果基本一致。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> interpolatorX = easeInOut(frac(value.x));</span><br><span class="line"><span class="keyword">float</span> interpolatorY = easeInOut(frac(value.y));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> z = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> cellNoiseY[<span class="number">2</span>];</span><br><span class="line">[unroll]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;=<span class="number">1</span>;y++)&#123;</span><br><span class="line">    <span class="keyword">float</span> cellNoiseX[<span class="number">2</span>];</span><br><span class="line">    [unroll]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;=<span class="number">1</span>;x++)&#123;</span><br><span class="line">        float3 cell = <span class="built_in">floor</span>(value) + float3(x, y, z);</span><br><span class="line">        cellNoiseX[x] = rand3dTo1d(cell);</span><br><span class="line">    &#125;</span><br><span class="line">    cellNoiseY[y] = lerp(cellNoiseX[<span class="number">0</span>], cellNoiseX[<span class="number">1</span>], interpolatorX);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">float</span> interpolatedXY = lerp(cellNoiseY[<span class="number">0</span>], cellNoiseY[<span class="number">1</span>], interpolatorY);</span><br></pre></td></tr></table></figure>

<p>最后在外层再套一个循环，和上一层循环类似，会将上一层循环执行两遍，在一个临时数组中记录上一层的插值结果。然后在循环结束后，对临时数组中的结果进行插值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">ValueNoise3d</span><span class="params">(float3 value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> interpolatorX = easeInOut(frac(value.x));</span><br><span class="line">    <span class="keyword">float</span> interpolatorY = easeInOut(frac(value.y));</span><br><span class="line">    <span class="keyword">float</span> interpolatorZ = easeInOut(frac(value.z));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> cellNoiseZ[<span class="number">2</span>];</span><br><span class="line">    [unroll]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> z=<span class="number">0</span>;z&lt;=<span class="number">1</span>;z++)&#123;</span><br><span class="line">        <span class="keyword">float</span> cellNoiseY[<span class="number">2</span>];</span><br><span class="line">        [unroll]</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;=<span class="number">1</span>;y++)&#123;</span><br><span class="line">            <span class="keyword">float</span> cellNoiseX[<span class="number">2</span>];</span><br><span class="line">            [unroll]</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;=<span class="number">1</span>;x++)&#123;</span><br><span class="line">                float3 cell = <span class="built_in">floor</span>(value) + float3(x, y, z);</span><br><span class="line">                cellNoiseX[x] = rand3dTo1d(cell);</span><br><span class="line">            &#125;</span><br><span class="line">            cellNoiseY[y] = lerp(cellNoiseX[<span class="number">0</span>], cellNoiseX[<span class="number">1</span>], interpolatorX);</span><br><span class="line">        &#125;</span><br><span class="line">        cellNoiseZ[z] = lerp(cellNoiseY[<span class="number">0</span>], cellNoiseY[<span class="number">1</span>], interpolatorY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">float</span> noise = lerp(cellNoiseZ[<span class="number">0</span>], cellNoiseZ[<span class="number">1</span>], interpolatorZ);</span><br><span class="line">    <span class="keyword">return</span> noise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">    float3 value = i.worldPos.xyz / _CellSize;</span><br><span class="line">    <span class="keyword">float</span> noise = ValueNoise3d(value);</span><br><span class="line"></span><br><span class="line">    o.Albedo = noise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/025/Grey3dNoise.png"></p>
<h2 id="3d-Output-Values"><a href="#3d-Output-Values" class="headerlink" title="3d Output Values"></a>3d Output Values</h2><p>上面实现了一维噪声值得平滑处理，把它改成三维噪声的平滑处理非常简单。只需要把随机函数从一维改为三维。然后将所有与噪声值相关的数据类型都改为三维。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">float3 <span class="title">ValueNoise3d</span><span class="params">(float3 value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> interpolatorX = easeInOut(frac(value.x));</span><br><span class="line">    <span class="keyword">float</span> interpolatorY = easeInOut(frac(value.y));</span><br><span class="line">    <span class="keyword">float</span> interpolatorZ = easeInOut(frac(value.z));</span><br><span class="line"></span><br><span class="line">    float3 cellNoiseZ[<span class="number">2</span>];</span><br><span class="line">    [unroll]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> z=<span class="number">0</span>;z&lt;=<span class="number">1</span>;z++)&#123;</span><br><span class="line">        float3 cellNoiseY[<span class="number">2</span>];</span><br><span class="line">        [unroll]</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;=<span class="number">1</span>;y++)&#123;</span><br><span class="line">            float3 cellNoiseX[<span class="number">2</span>];</span><br><span class="line">            [unroll]</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;=<span class="number">1</span>;x++)&#123;</span><br><span class="line">                float3 cell = <span class="built_in">floor</span>(value) + float3(x, y, z);</span><br><span class="line">                cellNoiseX[x] = rand3dTo3d(cell);</span><br><span class="line">            &#125;</span><br><span class="line">            cellNoiseY[y] = lerp(cellNoiseX[<span class="number">0</span>], cellNoiseX[<span class="number">1</span>], interpolatorX);</span><br><span class="line">        &#125;</span><br><span class="line">        cellNoiseZ[z] = lerp(cellNoiseY[<span class="number">0</span>], cellNoiseY[<span class="number">1</span>], interpolatorY);</span><br><span class="line">    &#125;</span><br><span class="line">    float3 noise = lerp(cellNoiseZ[<span class="number">0</span>], cellNoiseZ[<span class="number">1</span>], interpolatorZ);</span><br><span class="line">    <span class="keyword">return</span> noise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">    float3 value = i.worldPos.xyz / _CellSize;</span><br><span class="line">    float3 noise = ValueNoise3d(value);</span><br><span class="line"></span><br><span class="line">    o.Albedo = noise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/025/Colorful3dNoise.png"></p>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/025_value_noise/1d&quot;</span> &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_CellSize (<span class="string">&quot;Cell Size&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		CGPROGRAM</span><br><span class="line"></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">pragma</span> surface surf Standard fullforwardshadows</span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">pragma</span> target 3.0</span></span><br><span class="line"></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Random.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">float</span> _CellSize;</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">			float3 worldPos;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">float</span> <span class="title">easeIn</span><span class="params">(<span class="keyword">float</span> interpolator)</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> interpolator * interpolator;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">float</span> <span class="title">easeOut</span><span class="params">(<span class="keyword">float</span> interpolator)</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span> - easeIn(<span class="number">1</span> - interpolator);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">float</span> <span class="title">easeInOut</span><span class="params">(<span class="keyword">float</span> interpolator)</span></span>&#123;</span><br><span class="line">			<span class="keyword">float</span> easeInValue = easeIn(interpolator);</span><br><span class="line">			<span class="keyword">float</span> easeOutValue = easeOut(interpolator);</span><br><span class="line">			<span class="keyword">return</span> lerp(easeInValue, easeOutValue, interpolator);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">float</span> value = i.worldPos.x / _CellSize;</span><br><span class="line">			<span class="keyword">float</span> previousCellNoise = rand1dTo1d(<span class="built_in">floor</span>(value));</span><br><span class="line">			<span class="keyword">float</span> nextCellNoise = rand1dTo1d(<span class="built_in">ceil</span>(value));</span><br><span class="line">			<span class="keyword">float</span> interpolator = frac(value);</span><br><span class="line">			interpolator = easeInOut(interpolator);</span><br><span class="line">			<span class="keyword">float</span> noise = lerp(previousCellNoise, nextCellNoise, interpolator);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">float</span> dist = <span class="built_in">abs</span>(noise - i.worldPos.y);</span><br><span class="line">			<span class="keyword">float</span> pixelHeight = fwidth(i.worldPos.y);</span><br><span class="line">			<span class="keyword">float</span> lineIntensity = smoothstep(<span class="number">0</span>, pixelHeight, dist);</span><br><span class="line">			o.Albedo = lineIntensity;</span><br><span class="line">		&#125;</span><br><span class="line">		ENDCG</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack <span class="string">&quot;Standard&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/025_value_noise/2d&quot;</span> &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_CellSize (<span class="string">&quot;Cell Size&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		CGPROGRAM</span><br><span class="line"></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">pragma</span> surface surf Standard fullforwardshadows</span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">pragma</span> target 3.0</span></span><br><span class="line"></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Random.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">float</span> _CellSize;</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">			float3 worldPos;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">float</span> <span class="title">easeIn</span><span class="params">(<span class="keyword">float</span> interpolator)</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> interpolator * interpolator;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">float</span> <span class="title">easeOut</span><span class="params">(<span class="keyword">float</span> interpolator)</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span> - easeIn(<span class="number">1</span> - interpolator);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">float</span> <span class="title">easeInOut</span><span class="params">(<span class="keyword">float</span> interpolator)</span></span>&#123;</span><br><span class="line">			<span class="keyword">float</span> easeInValue = easeIn(interpolator);</span><br><span class="line">			<span class="keyword">float</span> easeOutValue = easeOut(interpolator);</span><br><span class="line">			<span class="keyword">return</span> lerp(easeInValue, easeOutValue, interpolator);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">float</span> <span class="title">ValueNoise2d</span><span class="params">(float2 value)</span></span>&#123;</span><br><span class="line">			<span class="keyword">float</span> upperLeftCell = rand2dTo1d(float2(<span class="built_in">floor</span>(value.x), <span class="built_in">ceil</span>(value.y)));</span><br><span class="line">			<span class="keyword">float</span> upperRightCell = rand2dTo1d(float2(<span class="built_in">ceil</span>(value.x), <span class="built_in">ceil</span>(value.y)));</span><br><span class="line">			<span class="keyword">float</span> lowerLeftCell = rand2dTo1d(float2(<span class="built_in">floor</span>(value.x), <span class="built_in">floor</span>(value.y)));</span><br><span class="line">			<span class="keyword">float</span> lowerRightCell = rand2dTo1d(float2(<span class="built_in">ceil</span>(value.x), <span class="built_in">floor</span>(value.y)));</span><br><span class="line"></span><br><span class="line">			<span class="keyword">float</span> interpolatorX = easeInOut(frac(value.x));</span><br><span class="line">			<span class="keyword">float</span> interpolatorY = easeInOut(frac(value.y));</span><br><span class="line"></span><br><span class="line">			<span class="keyword">float</span> upperCells = lerp(upperLeftCell, upperRightCell, interpolatorX);</span><br><span class="line">			<span class="keyword">float</span> lowerCells = lerp(lowerLeftCell, lowerRightCell, interpolatorX);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">float</span> noise = lerp(lowerCells, upperCells, interpolatorY);</span><br><span class="line">			<span class="keyword">return</span> noise;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">			float2 value = i.worldPos.xy / _CellSize;</span><br><span class="line">			<span class="keyword">float</span> noise = ValueNoise2d(value);</span><br><span class="line"></span><br><span class="line">			o.Albedo = noise;</span><br><span class="line">		&#125;</span><br><span class="line">		ENDCG</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack <span class="string">&quot;Standard&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/025_value_noise/3d&quot;</span> &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_CellSize (<span class="string">&quot;Cell Size&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		CGPROGRAM</span><br><span class="line"></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">pragma</span> surface surf Standard fullforwardshadows</span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">pragma</span> target 3.0</span></span><br><span class="line"></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;Random.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">float</span> _CellSize;</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">			float3 worldPos;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">float</span> <span class="title">easeIn</span><span class="params">(<span class="keyword">float</span> interpolator)</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> interpolator * interpolator;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">float</span> <span class="title">easeOut</span><span class="params">(<span class="keyword">float</span> interpolator)</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span> - easeIn(<span class="number">1</span> - interpolator);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">float</span> <span class="title">easeInOut</span><span class="params">(<span class="keyword">float</span> interpolator)</span></span>&#123;</span><br><span class="line">			<span class="keyword">float</span> easeInValue = easeIn(interpolator);</span><br><span class="line">			<span class="keyword">float</span> easeOutValue = easeOut(interpolator);</span><br><span class="line">			<span class="keyword">return</span> lerp(easeInValue, easeOutValue, interpolator);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">float3 <span class="title">ValueNoise3d</span><span class="params">(float3 value)</span></span>&#123;</span><br><span class="line">			<span class="keyword">float</span> interpolatorX = easeInOut(frac(value.x));</span><br><span class="line">			<span class="keyword">float</span> interpolatorY = easeInOut(frac(value.y));</span><br><span class="line">			<span class="keyword">float</span> interpolatorZ = easeInOut(frac(value.z));</span><br><span class="line"></span><br><span class="line">			float3 cellNoiseZ[<span class="number">2</span>];</span><br><span class="line">			[unroll]</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> z=<span class="number">0</span>;z&lt;=<span class="number">1</span>;z++)&#123;</span><br><span class="line">				float3 cellNoiseY[<span class="number">2</span>];</span><br><span class="line">				[unroll]</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;=<span class="number">1</span>;y++)&#123;</span><br><span class="line">					float3 cellNoiseX[<span class="number">2</span>];</span><br><span class="line">					[unroll]</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;=<span class="number">1</span>;x++)&#123;</span><br><span class="line">						float3 cell = <span class="built_in">floor</span>(value) + float3(x, y, z);</span><br><span class="line">						cellNoiseX[x] = rand3dTo3d(cell);</span><br><span class="line">					&#125;</span><br><span class="line">					cellNoiseY[y] = lerp(cellNoiseX[<span class="number">0</span>], cellNoiseX[<span class="number">1</span>], interpolatorX);</span><br><span class="line">				&#125;</span><br><span class="line">				cellNoiseZ[z] = lerp(cellNoiseY[<span class="number">0</span>], cellNoiseY[<span class="number">1</span>], interpolatorY);</span><br><span class="line">			&#125;</span><br><span class="line">			float3 noise = lerp(cellNoiseZ[<span class="number">0</span>], cellNoiseZ[<span class="number">1</span>], interpolatorZ);</span><br><span class="line">			<span class="keyword">return</span> noise;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">			float3 value = i.worldPos.xyz / _CellSize;</span><br><span class="line">			float3 noise = ValueNoise3d(value);</span><br><span class="line"></span><br><span class="line">			o.Albedo = noise;</span><br><span class="line">		&#125;</span><br><span class="line">		ENDCG</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack <span class="string">&quot;Standard&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本篇主要讲了使用线性插值来实现噪声图的平滑处理，希望能对你有所帮助。</p>
<p>你可以在以下链接找到源码：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/025_Value_Noise/value_noise_1d.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/025_Value_Noise/value_noise_1d.shader</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/025_Value_Noise/value_noise_2d.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/025_Value_Noise/value_noise_2d.shader</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/025_Value_Noise/value_noise_3d.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/025_Value_Noise/value_noise_3d.shader</a></li>
</ul>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.febucci.com/2018/08/easing-functions/">Easing Functions for Animations</a></li>
<li><a target="_blank" rel="noopener" href="https://easings.net/">Easing functions</a></li>
</ul>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/08/Ronja_White_Noise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/08/Ronja_White_Noise/" class="post-title-link" itemprop="url">White Noise</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-08 18:01:00" itemprop="dateCreated datePublished" datetime="2021-07-08T18:01:00+08:00">2021-07-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-30 00:35:25" itemprop="dateModified" datetime="2022-08-30T00:35:25+08:00">2022-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/024-white-noise/">White Noise</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>在很多效果中需要用到随机数来生成纹理图案、又或者其他东西。下面我们以白色噪声图为例，来展示随机数用途。后面我们还会介绍其他使用随机数生成的具有一定组织结构的图案，例如泊林噪声图、和<code>vornoi</code>噪声图。本文是采用表面着色器来实现的，所以建议你先阅读我关于<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Surface_Shader_Basics/">表面着色器</a>的介绍。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/024/Result.png"></p>
<h2 id="Scalar-noise-from-3d-Input"><a href="#Scalar-noise-from-3d-Input" class="headerlink" title="Scalar noise from 3d Input"></a>Scalar noise from 3d Input</h2><p>在着色器中，我们很难将上一帧画面的数据保存到下一帧，因此我们的随机数必须依赖于着色器中可访问的参数，这样无论什么时候我们都可以得到固定的随机值。这里我们使用世界坐标来生成随机值。当然如果你想让你的噪声图动起来，可以引入时间变量。</p>
<p>因此我们需要在表面着色器的输入结构中加入世界坐标。另外因为我们打算通过随机数生成纹理图案，所以我们不需要纹理变量，相应的UV坐标也可以删除了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">    float3 worldPos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来我们将实现随机噪声值生成函数，这样我们可以通过该函数很方便的制造随机数。首先我们的函数接收三维坐标参数，然后返回一个0-1之间的小数。将向量转换为标量最简单的方法就是点乘，但是点乘的结果可能非常大，所以我们使用<code>frac</code>函数只截取其中的小数部分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">rand</span><span class="params">(float3 vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> random = dot(vec, float3(<span class="number">12.9898</span>, <span class="number">78.233</span>, <span class="number">37.719</span>));</span><br><span class="line">    random = frac(random);</span><br><span class="line">    <span class="keyword">return</span> random;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们在表面着色器函数中使用我们的随机函数，并以世界坐标为参数，将结果写入<code>Albedo</code>参数中，那么我们可以立马看到我们的随机值遍布在模型表面。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">    o.Albedo = rand(i.worldPos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/024/DotFrac.png"><br><img src="https://www.ronja-tutorials.com/assets/images/posts/024/DotFracClose.png"></p>
<p>上面生成的噪声图有一个问题，就是看起来并不是那么随机，我们可以看到有很多条纹图案。虽然这个”随机函数“是我随便写的，但是它执行很快，也能满足我们当前一些简单的随机需求。我们再将上面的伪随机值乘以一个非常大的值，然后截取结果的小数部分，这样可以产生非常细的条纹，几乎观察不到。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">rand</span><span class="params">(float3 vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> random = dot(vec, float3(<span class="number">12.9898</span>, <span class="number">78.233</span>, <span class="number">37.719</span>));</span><br><span class="line">    random = frac(random * <span class="number">143758.5453</span>);</span><br><span class="line">    <span class="keyword">return</span> random;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/024/SimpleRandom.png"></p>
<p>但是又有一个问题，就是乘以一个非常大的数，其结果很容易超出浮点数表示范围，例如我们的模型离世界原点非常远。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/024/FloatRange.png"></p>
<p>为了修复这个问题，我们可以在乘积之前，将点乘结果限定在非常小的范围，这里我使用三角函数。因为三角函数是在特殊的计算单元中执行，所以其性能消耗只比加减乘除高点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于向量计算随机值</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">rand</span><span class="params">(float3 value)</span></span>&#123;</span><br><span class="line">    <span class="comment">//限制向量大小</span></span><br><span class="line">    float3 smallValue = <span class="built_in">sin</span>(value);</span><br><span class="line">    <span class="comment">//计算随机值</span></span><br><span class="line">    <span class="keyword">float</span> random = dot(smallValue, float3(<span class="number">12.9898</span>, <span class="number">78.233</span>, <span class="number">37.719</span>));</span><br><span class="line">    <span class="comment">//防止超出范围</span></span><br><span class="line">    random = frac(<span class="built_in">sin</span>(random) * <span class="number">143758.5453</span>);</span><br><span class="line">    <span class="keyword">return</span> random;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Different-Input-and-Output"><a href="#Different-Input-and-Output" class="headerlink" title="Different Input and Output"></a>Different Input and Output</h2><p>为了产生多维随机向量，我们可以沿着不同方向生成随机数，然后将结果合并成向量。但是不同方向的随机参数必须不同，这样不同方向的随机值才能不同。最简单的方法是将上面的固定向量改成变量，然后不同方向的随机值需要传入不同的向量。我们可以将上面的固定向量作为我们这个向量变量的默认参数，这样还可以以上面的方式调用。因为现在有一维、和三维随机数生成函数，所以我们需要给他们分别命名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成一维随机数</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">rand3dTo1d</span><span class="params">(float3 value, float3 dotDir = float3(<span class="number">12.9898</span>, <span class="number">78.233</span>, <span class="number">37.719</span>))</span></span>&#123;</span><br><span class="line">    <span class="comment">//限制向量大小</span></span><br><span class="line">    float3 smallValue = <span class="built_in">sin</span>(value);</span><br><span class="line">    <span class="comment">//计算随机值</span></span><br><span class="line">    <span class="keyword">float</span> random = dot(smallValue, dotDir);</span><br><span class="line">    <span class="comment">//防止超出范围</span></span><br><span class="line">    random = frac(<span class="built_in">sin</span>(random) * <span class="number">143758.5453</span>);</span><br><span class="line">    <span class="keyword">return</span> random;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要生成三维随机数，我们可以将上面的方法调用三次。每次得到向量的一个维度值，每个维度使用不同的方向向量。这样我们可以得到一个彩色的随机噪声图。之所以将上面的方法执行三遍，而不是另外写一个直接生成三维向量的随机方法，是因为我们想让生成的随机向量的三个维度的值相互独立。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成三维随机向量</span></span><br><span class="line"><span class="function">float3 <span class="title">rand3dTo3d</span><span class="params">(float3 value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> float3(</span><br><span class="line">        rand3dTo1d(value, float3(<span class="number">12.989</span>, <span class="number">78.233</span>, <span class="number">37.719</span>)),</span><br><span class="line">        rand3dTo1d(value, float3(<span class="number">39.346</span>, <span class="number">11.135</span>, <span class="number">83.155</span>)),</span><br><span class="line">        rand3dTo1d(value, float3(<span class="number">73.156</span>, <span class="number">52.235</span>, <span class="number">09.151</span>))</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">    o.Albedo = rand3dTo3d(i.worldPos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/024/ColorfulWhiteNoise.png"></p>
<p>上面是使用三维向量来生成随机数，我们也可以使用二维向量，只要把前面的三维向量改成二维向量就行。还可以使用标量，不过原先的点乘操作就用不上了。我们可以一次性将这些函数都实现，然后放在一个<code>include</code>文件中，这样以后都不用再重写这些方法了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维随机数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用三维向量计算一维随机数</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">rand3dTo1d</span><span class="params">(float3 value, float3 dotDir = float3(<span class="number">12.9898</span>, <span class="number">78.233</span>, <span class="number">37.719</span>))</span></span>&#123;</span><br><span class="line">    <span class="comment">//限制向量大小</span></span><br><span class="line">    float3 smallValue = <span class="built_in">sin</span>(value);</span><br><span class="line">    <span class="comment">//计算随机值</span></span><br><span class="line">    <span class="keyword">float</span> random = dot(smallValue, dotDir);</span><br><span class="line">    <span class="comment">//防止超出范围</span></span><br><span class="line">    random = frac(<span class="built_in">sin</span>(random) * <span class="number">143758.5453</span>);</span><br><span class="line">    <span class="keyword">return</span> random;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">rand2dTo1d</span><span class="params">(float2 value, float2 dotDir = float2(<span class="number">12.9898</span>, <span class="number">78.233</span>))</span></span>&#123;</span><br><span class="line">    float2 smallValue = <span class="built_in">sin</span>(value);</span><br><span class="line">    <span class="keyword">float</span> random = dot(smallValue, dotDir);</span><br><span class="line">    random = frac(<span class="built_in">sin</span>(random) * <span class="number">143758.5453</span>);</span><br><span class="line">    <span class="keyword">return</span> random;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">rand1dTo1d</span><span class="params">(float3 value, <span class="keyword">float</span> mutator = <span class="number">0.546</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> random = frac(<span class="built_in">sin</span>(value + mutator) * <span class="number">143758.5453</span>);</span><br><span class="line">	<span class="keyword">return</span> random;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维随机数</span></span><br><span class="line"></span><br><span class="line"><span class="function">float2 <span class="title">rand3dTo2d</span><span class="params">(float3 value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> float2(</span><br><span class="line">        rand3dTo1d(value, float3(<span class="number">12.989</span>, <span class="number">78.233</span>, <span class="number">37.719</span>)),</span><br><span class="line">        rand3dTo1d(value, float3(<span class="number">39.346</span>, <span class="number">11.135</span>, <span class="number">83.155</span>))</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">float2 <span class="title">rand2dTo2d</span><span class="params">(float2 value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> float2(</span><br><span class="line">        rand2dTo1d(value, float2(<span class="number">12.989</span>, <span class="number">78.233</span>)),</span><br><span class="line">        rand2dTo1d(value, float2(<span class="number">39.346</span>, <span class="number">11.135</span>))</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">float2 <span class="title">rand1dTo2d</span><span class="params">(<span class="keyword">float</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> float2(</span><br><span class="line">        rand2dTo1d(value, <span class="number">3.9812</span>),</span><br><span class="line">        rand2dTo1d(value, <span class="number">7.1536</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三维随机数</span></span><br><span class="line"></span><br><span class="line"><span class="function">float3 <span class="title">rand3dTo3d</span><span class="params">(float3 value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> float3(</span><br><span class="line">        rand3dTo1d(value, float3(<span class="number">12.989</span>, <span class="number">78.233</span>, <span class="number">37.719</span>)),</span><br><span class="line">        rand3dTo1d(value, float3(<span class="number">39.346</span>, <span class="number">11.135</span>, <span class="number">83.155</span>)),</span><br><span class="line">        rand3dTo1d(value, float3(<span class="number">73.156</span>, <span class="number">52.235</span>, <span class="number">09.151</span>))</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">float3 <span class="title">rand2dTo3d</span><span class="params">(float2 value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> float3(</span><br><span class="line">        rand2dTo1d(value, float2(<span class="number">12.989</span>, <span class="number">78.233</span>)),</span><br><span class="line">        rand2dTo1d(value, float2(<span class="number">39.346</span>, <span class="number">11.135</span>)),</span><br><span class="line">        rand2dTo1d(value, float2(<span class="number">73.156</span>, <span class="number">52.235</span>))</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">float3 <span class="title">rand1dTo3d</span><span class="params">(<span class="keyword">float</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> float3(</span><br><span class="line">        rand1dTo1d(value, <span class="number">3.9812</span>),</span><br><span class="line">        rand1dTo1d(value, <span class="number">7.1536</span>),</span><br><span class="line">        rand1dTo1d(value, <span class="number">5.7241</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们将上面的随机生成的函数都放到一个叫<code>WhiteNoise.cginc</code>的文件中。并且在我们的着色器中引用它。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;WhiteNoise.cginc&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>为了防止我们多次误引用同一个文件，我们可以使用宏命令来规避这个问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WHITE_NOISE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WHITE_NOISE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们的包含库内容</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Cells"><a href="#Cells" class="headerlink" title="Cells"></a>Cells</h2><p>现在我们实现了通过世界坐标来生成随机颜色，这些颜色块非常小，当我们移动物体时，颜色也会快速变化。如果我们想让颜色块变大，我们可以将空间进行划分，所有处在同一块中的点使用同一个随机值。我们这里可以使用取整的方法，这样所有整数之间的小数对应的点都将使用同一随机值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">    float3 value = <span class="built_in">floor</span>(i.worldPos);</span><br><span class="line">    o.Albedo = rand3dTo3d(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/024/1Cells.png"></p>
<p>现在我们得到泾渭分明的色块，然后我们可以修改色块的大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Properties &#123;</span><br><span class="line">    _CellSize (<span class="string">&quot;Cell Size&quot;</span>, Vector) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float3 _CellSize;</span><br></pre></td></tr></table></figure>

<p>我们这将世界坐标除以色块尺寸。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">    float3 value = <span class="built_in">floor</span>(i.worldPos / _CellSize);</span><br><span class="line">    o.Albedo = rand3dTo3d(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/024/Cells.png"></p>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/024_white_noise/random&quot;</span> &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		CGPROGRAM</span><br><span class="line"></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">pragma</span> surface surf Standard fullforwardshadows</span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">pragma</span> target 3.0</span></span><br><span class="line"></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;WhiteNoise.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">		struct Input &#123;</span><br><span class="line">			float3 worldPos;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">			float3 value = i.worldPos;</span><br><span class="line">			o.Albedo = rand3dTo3d(value);</span><br><span class="line">		&#125;</span><br><span class="line">		ENDCG</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack <span class="string">&quot;Standard&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/024_white_noise/cells&quot;</span> &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_CellSize (<span class="string">&quot;Cell Size&quot;</span>, Vector) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">		CGPROGRAM</span><br><span class="line"></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">pragma</span> surface surf Standard fullforwardshadows</span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">pragma</span> target 3.0</span></span><br><span class="line"></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;WhiteNoise.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">		float3 _CellSize;</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">			float3 worldPos;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">			float3 value = <span class="built_in">floor</span>(i.worldPos / _CellSize);</span><br><span class="line">			o.Albedo = rand3dTo3d(value);</span><br><span class="line">		&#125;</span><br><span class="line">		ENDCG</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack <span class="string">&quot;Standard&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WHITE_NOISE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WHITE_NOISE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//to 1d functions</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//get a scalar random value from a 3d value</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">rand3dTo1d</span><span class="params">(float3 value, float3 dotDir = float3(<span class="number">12.9898</span>, <span class="number">78.233</span>, <span class="number">37.719</span>))</span></span>&#123;</span><br><span class="line">	<span class="comment">//make value smaller to avoid artefacts</span></span><br><span class="line">	float3 smallValue = <span class="built_in">sin</span>(value);</span><br><span class="line">	<span class="comment">//get scalar value from 3d vector</span></span><br><span class="line">	<span class="keyword">float</span> random = dot(smallValue, dotDir);</span><br><span class="line">	<span class="comment">//make value more random by making it bigger and then taking the factional part</span></span><br><span class="line">	random = frac(<span class="built_in">sin</span>(random) * <span class="number">143758.5453</span>);</span><br><span class="line">	<span class="keyword">return</span> random;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">rand2dTo1d</span><span class="params">(float2 value, float2 dotDir = float2(<span class="number">12.9898</span>, <span class="number">78.233</span>))</span></span>&#123;</span><br><span class="line">	float2 smallValue = <span class="built_in">sin</span>(value);</span><br><span class="line">	<span class="keyword">float</span> random = dot(smallValue, dotDir);</span><br><span class="line">	random = frac(<span class="built_in">sin</span>(random) * <span class="number">143758.5453</span>);</span><br><span class="line">	<span class="keyword">return</span> random;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">rand1dTo1d</span><span class="params">(float3 value, <span class="keyword">float</span> mutator = <span class="number">0.546</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> random = frac(<span class="built_in">sin</span>(value + mutator) * <span class="number">143758.5453</span>);</span><br><span class="line">	<span class="keyword">return</span> random;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//to 2d functions</span></span><br><span class="line"></span><br><span class="line"><span class="function">float2 <span class="title">rand3dTo2d</span><span class="params">(float3 value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> float2(</span><br><span class="line">		rand3dTo1d(value, float3(<span class="number">12.989</span>, <span class="number">78.233</span>, <span class="number">37.719</span>)),</span><br><span class="line">		rand3dTo1d(value, float3(<span class="number">39.346</span>, <span class="number">11.135</span>, <span class="number">83.155</span>))</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">float2 <span class="title">rand2dTo2d</span><span class="params">(float2 value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> float2(</span><br><span class="line">		rand2dTo1d(value, float2(<span class="number">12.989</span>, <span class="number">78.233</span>)),</span><br><span class="line">		rand2dTo1d(value, float2(<span class="number">39.346</span>, <span class="number">11.135</span>))</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">float2 <span class="title">rand1dTo2d</span><span class="params">(<span class="keyword">float</span> value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> float2(</span><br><span class="line">		rand2dTo1d(value, <span class="number">3.9812</span>),</span><br><span class="line">		rand2dTo1d(value, <span class="number">7.1536</span>)</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//to 3d functions</span></span><br><span class="line"></span><br><span class="line"><span class="function">float3 <span class="title">rand3dTo3d</span><span class="params">(float3 value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> float3(</span><br><span class="line">		rand3dTo1d(value, float3(<span class="number">12.989</span>, <span class="number">78.233</span>, <span class="number">37.719</span>)),</span><br><span class="line">		rand3dTo1d(value, float3(<span class="number">39.346</span>, <span class="number">11.135</span>, <span class="number">83.155</span>)),</span><br><span class="line">		rand3dTo1d(value, float3(<span class="number">73.156</span>, <span class="number">52.235</span>, <span class="number">09.151</span>))</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">float3 <span class="title">rand2dTo3d</span><span class="params">(float2 value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> float3(</span><br><span class="line">		rand2dTo1d(value, float2(<span class="number">12.989</span>, <span class="number">78.233</span>)),</span><br><span class="line">		rand2dTo1d(value, float2(<span class="number">39.346</span>, <span class="number">11.135</span>)),</span><br><span class="line">		rand2dTo1d(value, float2(<span class="number">73.156</span>, <span class="number">52.235</span>))</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">float3 <span class="title">rand1dTo3d</span><span class="params">(<span class="keyword">float</span> value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> float3(</span><br><span class="line">		rand1dTo1d(value, <span class="number">3.9812</span>),</span><br><span class="line">		rand1dTo1d(value, <span class="number">7.1536</span>),</span><br><span class="line">		rand1dTo1d(value, <span class="number">5.7241</span>)</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>希望我的教程能够对你有所帮助。</p>
<p>你可以在以下链接找到源码：<br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/024_White_Noise/WhiteNoise.cginc">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/024_White_Noise/WhiteNoise.cginc</a><br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/024_White_Noise/white_noise_random.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/024_White_Noise/white_noise_random.shader</a><br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/024_White_Noise/white_noise_cells.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/024_White_Noise/white_noise_cells.shader</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/08/Ronja_Blur_Postprocessing_Effect/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/08/Ronja_Blur_Postprocessing_Effect/" class="post-title-link" itemprop="url">Blur Postprocessing Effect (Box and Gauss)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-08 10:01:00" itemprop="dateCreated datePublished" datetime="2021-07-08T10:01:00+08:00">2021-07-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-30 00:35:25" itemprop="dateModified" datetime="2022-08-30T00:35:25+08:00">2022-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/023-postprocessing-blur/">Blur Postprocessing Effect (Box and Gauss)</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>模糊效果是一个非常有用的效果，可以用来表现角色虚弱时的视线模糊，也可以用来作为过场动画。我们是通过平均屏幕局部区域的像素值来实现画面模糊的。模糊处理可以应用在很多方面，但是最常用的就是实现后处理效果。因此你可能需要提前阅读我之前的<a href="https://tyson-wu.github.io/blogs/2021/07/06/Ronja_Postprocessing_Basics/">后处理</a>教程。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/023/Result.gif"></p>
<h2 id="Boxblur"><a href="#Boxblur" class="headerlink" title="Boxblur"></a>Boxblur</h2><p>块模糊是最简单的一种模糊，只要才将局部方块区域进行采样平均就行。为了连续对局部区域采样，我们需要使用<code>for</code>循环。然后将所有采样值求和，再除以采样个数，得到局部平均值。</p>
<p>我们可以在前面的简单后处理脚本中做如下修改。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//起始值</span></span><br><span class="line">    float4 col = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">float</span> index=<span class="number">0</span>;index&lt;<span class="number">10</span>;index++)&#123;</span><br><span class="line">        <span class="comment">//将采样值叠加</span></span><br><span class="line">        col += tex2D(_MainTex, i.uv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求平均</span></span><br><span class="line">    col = col / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1D-Blur"><a href="#1D-Blur" class="headerlink" title="1D Blur"></a>1D Blur</h3><p>因为我们上面是连续对同一个点采样求平均，所以最终结果并没有什么变化。接下来我们将改为对不同位置进行采样。然后我们需要创建一个公共变量，来控制采样块的大小，采样块的大小是一个相对值而不是实际的像素个数，这样可以保证相同的参数对不同分辨率的图片效果一样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//材质面板</span></span><br><span class="line">Properties&#123;</span><br><span class="line">    [HideInInspector]_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    _BlurSize(<span class="string">&quot;Blur Size&quot;</span>, Range(<span class="number">0</span>,<span class="number">0.1</span>)) = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> _BlurSize;</span><br></pre></td></tr></table></figure>

<p>有个模糊尺寸，我们可以在每次采样中计算不同的采样点。我们将循环次数映射为0-1之间，然后减去0.5，这样得到的采样点刚好是围绕当前点。最后我们乘以模糊尺寸，就可以动态控制模糊块的大小了。<br>这里我们只处理<code>y</code>方向的采样点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环采样</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">float</span> index=<span class="number">0</span>;index&lt;<span class="number">10</span>;index++)&#123;</span><br><span class="line">    <span class="comment">//计算y方向上不同的采样点坐标</span></span><br><span class="line">    float2 uv = i.uv + float2(<span class="number">0</span>, (index/<span class="number">9</span> - <span class="number">0.5</span>) * _BlurSize);</span><br><span class="line">    <span class="comment">//采样值叠加</span></span><br><span class="line">    col += tex2D(_MainTex, uv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/023/VerticalBlur.gif"></p>
<p>上面的采样点是沿着<code>y</code>方向的，所以模糊效果也是沿着<code>y</code>方向，但是我们希望<code>x</code>方向也模糊。我们可以在上面那个循环内再套一个循环，但是这并不是最好的方法。我们可以先执行<code>y</code>方向的模糊，然后再将模糊后的图片执行<code>x</code>方向的模糊。这样两次模糊后，就得到模糊块的平均值。</p>
<h3 id="2D-Blur"><a href="#2D-Blur" class="headerlink" title="2D Blur"></a>2D Blur</h3><p>为了执行第二次模糊，我们重新实现一个<code>Pass</code>，我们可以将原来的代码复制过来，然后将偏移值改为沿着<code>x</code>方向。还有就是我们的模糊尺寸需要修改，如果不修改，模糊块的形状将和图片保持一致，这样就不能保证模糊块是一个方形。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//计算图片横纵比</span></span><br><span class="line">    <span class="keyword">float</span> invAspect = _ScreenParams.y / _ScreenParams.x;</span><br><span class="line">    <span class="comment">//用于累计的颜色变量</span></span><br><span class="line">    float4 col = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//循环采样</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">float</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++)&#123;</span><br><span class="line">        <span class="comment">//计算x方向的偏移，保证x、y两个方向的偏移像素个数相同</span></span><br><span class="line">        float2 uv = i.uv + float2((index/<span class="number">9</span> - <span class="number">0.5</span>) * _BlurSize * invAspect, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//采样值累加</span></span><br><span class="line">        col += tex2D(_MainTex, uv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求平均</span></span><br><span class="line">    col = col / <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了在后处理中连续使用两次<code>Pass</code>，我们需要对后处理脚本做一些修改。从前面的流程上来说，我们是先对原图进行纵向模糊，将结果存在一张临时纹理上，然后对这张临时纹理进行横向模糊，最终将结果写入目标图中。所以我们需要一张临时纹理，我们可以通过<code>RenderTexture.GetTemporary</code>函数来获取临时纹理。该函数是从纹理缓存池中获取，如果没有就会新建，然后释放该临时纹理，会将其放回纹理缓存池，以待下次使用。在执行纵向模糊时，我们要告诉Unity执行第一个<code>Pass</code>，因此可以向<code>blit</code>函数中的第四个参数传入0,表示执行第一个<code>Pass</code>，而目标图传入的是临时纹理。然后在执行横向模糊时，原图是临时纹理，目标图是最终的效果图，第四个参数传入1,表示执行第二个<code>Pass</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//场景渲染完后执行该函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span><span class="params">(RenderTexture source, RenderTexture destination)</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建临时纹理，并执行两次模糊操作，然后释放临时纹理</span></span><br><span class="line">    var temporaryTexture = RenderTexture.GetTemporary(source.width, source.height);</span><br><span class="line">    Graphics.Blit(source, temporaryTexture, postprocessMaterial, <span class="number">0</span>);</span><br><span class="line">    Graphics.Blit(temporaryTexture, destination, postprocessMaterial, <span class="number">1</span>);</span><br><span class="line">    RenderTexture.ReleaseTemporary(temporaryTexture);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/023/BoxBlur.gif"></p>
<h3 id="Customize-Sample-Amount"><a href="#Customize-Sample-Amount" class="headerlink" title="Customize Sample Amount"></a>Customize Sample Amount</h3><p>上面实现基本的模糊效果，但是我们可能希望控制采样个数，也就是循环次数。但是我们不能简单的将循环次数声明到公共变量，因为Unity在编译时必须确定到底采样几次，而变量是无法在编译时确定的。因为不能在循环语句中执行纹理采样，实际上前面循环在编译时就已经展开了，循环次数在编译时确定的。</p>
<p>那么我们可以通过宏命令来定义变量，这样在编译时就是确定的了。我们在上面两个<code>Pass</code>中加入一下宏定义，然后将所有与采样次数相关的全部替换掉。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SAMPLES 10</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line"></span><br><span class="line">    float4 col = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//循环采样，在编译时该循环会被展开</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">float</span> index = <span class="number">0</span>; index &lt; SAMPLES; index++)&#123;</span><br><span class="line">        <span class="comment">//计算UV偏移</span></span><br><span class="line">        float2 uv = i.uv + float2(<span class="number">0</span>, (index/(SAMPLES<span class="number">-1</span>) - <span class="number">0.5</span>) * _BlurSize);</span><br><span class="line">        <span class="comment">//采样值叠加</span></span><br><span class="line">        col += tex2D(_MainTex, uv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//平均</span></span><br><span class="line">    col = col / SAMPLES;</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就可以在代码中快速修改采样次数了。这里我们还可以进一步改进，将循环次数暴露在材质面板上，这样我们可以通过材质面板来快速修改采样次数。首先我们添加一个<code>KeywordEnum</code>属性，这个属性在材质面板上显示的是枚举变量，同时在着色器中定义相应的关键字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//材质面板</span></span><br><span class="line">Properties&#123;</span><br><span class="line">    [HideInInspector]_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    _BlurSize(<span class="string">&quot;Blur Size&quot;</span>, Range(<span class="number">0</span>,<span class="number">0.1</span>)) = <span class="number">0</span></span><br><span class="line">    [KeywordEnum(Low, Medium, High)] _Samples (<span class="string">&quot;Sample amount&quot;</span>, Float) = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在着色器代码中声明这些关键字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> multi_compile _SAMPLES_LOW _SAMPLES_MEDIUM _SAMPLES_HIGH</span></span><br></pre></td></tr></table></figure>

<p>着色器会根据这些关键字编译出不同的版本，也就是所谓的变体。当我们在材质面板上选择不同的关键字时，实际上就是切换不同的变体。然后我们针对不同的变体设置不同的采样次数。这样我们就可以通过材质面板来控制采样次数了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> _SAMPLES_LOW</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> SAMPLES 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> _SAMPLES_MEDIUM</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> SAMPLES 30</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> SAMPLES 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/023/QualitySettings.gif"></p>
<h2 id="Gaussian-Blur"><a href="#Gaussian-Blur" class="headerlink" title="Gaussian Blur"></a>Gaussian Blur</h2><p>再复杂一点，我们可以使用高斯模糊。前面将的模糊是计算局部平均值，而高斯模糊将中心点的权重增加，其权重分布符合高斯分布。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/023/Gauss.svg"></p>
<p>这个函数需要两个参数，一个是离中心点的距离，一个是标准差。在上一个模糊方法中我们已经计算了离中心点的距离，这里需要增加一个变量来控制标准差。另外还需要一个变量来选择使用普通的模糊还是高斯模糊。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//材质面板</span></span><br><span class="line">Properties&#123;</span><br><span class="line">    [HideInInspector]_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    _BlurSize(<span class="string">&quot;Blur Size&quot;</span>, Range(<span class="number">0</span>,<span class="number">0.1</span>)) = <span class="number">0</span></span><br><span class="line">    [KeywordEnum(BoxLow, BoxMedium, BoxHigh, GaussLow, GaussHigh)] _Samples (<span class="string">&quot;Sample amount&quot;</span>, Float) = <span class="number">0</span></span><br><span class="line">    [Toggle(GAUSS)] _Gauss (<span class="string">&quot;Gaussian Blur&quot;</span>, <span class="keyword">float</span>) = <span class="number">0</span></span><br><span class="line">    _StandardDeviation(<span class="string">&quot;Standard Deviation (Gauss only)&quot;</span>, Range(<span class="number">0</span>, <span class="number">0.1</span>)) = <span class="number">0.02</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> shader_feature GAUSS</span></span><br></pre></td></tr></table></figure>

<p>高斯函数中还需要的东西有圆周率和自然数，这里我一并定义了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159265359</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E 2.71828182846</span></span><br></pre></td></tr></table></figure>

<p>当使用高斯函数时，我们无法确定其总的权重，所以这里引入一个新的变量<code>sum</code>，当我们使用高斯模糊时，我们将其初始化为0，然后在后面累计计算高斯的总权重，在使用普通模糊时，因为每个点的权重都是1，所以总权重就是点的个数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> GAUSS</span></span><br><span class="line">    <span class="keyword">float</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">float</span> sum = SAMPLES;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>然后我们来修改片段着色器中的循环采样部分。首先我们计算采样点离中心点的偏移值，这个在高斯模糊中会用到。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">float</span> index = <span class="number">0</span>; index &lt; SAMPLES; index++)&#123;</span><br><span class="line">    <span class="keyword">float</span> offset = (index/(SAMPLES<span class="number">-1</span>) - <span class="number">0.5</span>) * _BlurSize;</span><br><span class="line">    <span class="comment">//计算采样点的坐标</span></span><br><span class="line">    float2 uv = i.uv + float2(<span class="number">0</span>, offset);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !GAUSS</span></span><br><span class="line">    col += tex2D(_MainTex, uv);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">//计算高斯权重</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们实现高斯模糊部分，首先我们计算标准差的平方，因为在高斯函数中用到两次了。然后根据高斯函数编写表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算高斯权重</span></span><br><span class="line"><span class="keyword">float</span> stDevSquared = _StandardDeviation*_StandardDeviation;</span><br><span class="line"><span class="keyword">float</span> gauss = (<span class="number">1</span> / <span class="built_in">sqrt</span>(<span class="number">2</span>*PI*stDevSquared)) * <span class="built_in">pow</span>(E, -((offset*offset)/(<span class="number">2</span>*stDevSquared)));</span><br></pre></td></tr></table></figure>

<p>我们将计算好的高斯权重累计到<code>sum</code>变量中，并且将其与纹理采样结果进行加权平均。</p>
<p>最后还有一个问题是标准差不能为零，所以我们加一个段保护代码，如果为零则不执行高斯模糊。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> GAUSS</span></span><br><span class="line">    <span class="comment">//当标准差为0时，不执行高斯模糊</span></span><br><span class="line">    <span class="keyword">if</span>(_StandardDeviation == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> tex2D(_MainTex, i.uv);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//颜色累计</span></span><br><span class="line">    float4 col = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> GAUSS</span></span><br><span class="line">    <span class="keyword">float</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">float</span> sum = SAMPLES;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//循环采样</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">float</span> index = <span class="number">0</span>; index &lt; SAMPLES; index++)&#123;</span><br><span class="line">        <span class="comment">//计算离中心点的偏移</span></span><br><span class="line">        <span class="keyword">float</span> offset = (index/(SAMPLES<span class="number">-1</span>) - <span class="number">0.5</span>) * _BlurSize;</span><br><span class="line">        <span class="comment">//计算采样点坐标</span></span><br><span class="line">        float2 uv = i.uv + float2(<span class="number">0</span>, offset);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> !GAUSS</span></span><br><span class="line">        <span class="comment">//采样值累加</span></span><br><span class="line">        col += tex2D(_MainTex, uv);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="comment">//计算高斯权重</span></span><br><span class="line">        <span class="keyword">float</span> stDevSquared = _StandardDeviation*_StandardDeviation;</span><br><span class="line">        <span class="keyword">float</span> gauss = (<span class="number">1</span> / <span class="built_in">sqrt</span>(<span class="number">2</span>*PI*stDevSquared)) * <span class="built_in">pow</span>(E, -((offset*offset)/(<span class="number">2</span>*stDevSquared)));</span><br><span class="line">        <span class="comment">//计算总权重</span></span><br><span class="line">        sum += gauss;</span><br><span class="line">        <span class="comment">//加权</span></span><br><span class="line">        col += tex2D(_MainTex, uv) * gauss;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//平均</span></span><br><span class="line">    col = col / sum;</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/023/Result.gif"></p>
<p>上面这个模糊我想有两点可以优化，一是使用<code>include</code>文件，将公用代码写入其中，然后可以在多处进行引用，实现代码复用。另一个是将高斯权重计算转移到<code>C#</code>代码中，然后将结果传入着色器，因为在着色器中计算高斯函数非常浪费。</p>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">//必须挂载到后处理摄像机上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PostprocessingBlur</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">	<span class="comment">//后处理材质</span></span><br><span class="line">	[<span class="meta">SerializeField</span>]</span><br><span class="line">	<span class="keyword">private</span> Material postprocessMaterial;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//场景渲染完成后，执行该函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture source, RenderTexture destination</span>)</span>&#123;</span><br><span class="line">		<span class="comment">//新建临时纹理，执行模糊处理，然后回收临时纹理</span></span><br><span class="line">		<span class="keyword">var</span> temporaryTexture = RenderTexture.GetTemporary(source.width, source.height);</span><br><span class="line">		Graphics.Blit(source, temporaryTexture, postprocessMaterial, <span class="number">0</span>);</span><br><span class="line">		Graphics.Blit(temporaryTexture, destination, postprocessMaterial, <span class="number">1</span>);</span><br><span class="line">		RenderTexture.ReleaseTemporary(temporaryTexture);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/023_Postprocessing_Blur&quot;</span>&#123;</span><br><span class="line">	<span class="comment">//材质面板</span></span><br><span class="line">	Properties&#123;</span><br><span class="line">		[HideInInspector]_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">		_BlurSize(<span class="string">&quot;Blur Size&quot;</span>, Range(<span class="number">0</span>,<span class="number">0.5</span>)) = <span class="number">0</span></span><br><span class="line">		[KeywordEnum(Low, Medium, High)] _Samples (<span class="string">&quot;Sample amount&quot;</span>, Float) = <span class="number">0</span></span><br><span class="line">		[Toggle(GAUSS)] _Gauss (<span class="string">&quot;Gaussian Blur&quot;</span>, <span class="keyword">float</span>) = <span class="number">0</span></span><br><span class="line">		[PowerSlider(<span class="number">3</span>)]_StandardDeviation(<span class="string">&quot;Standard Deviation (Gauss only)&quot;</span>, Range(<span class="number">0.00</span>, <span class="number">0.3</span>)) = <span class="number">0.02</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		<span class="comment">// 双面渲染</span></span><br><span class="line">		<span class="comment">// 禁用深度缓存</span></span><br><span class="line">		Cull Off</span><br><span class="line">		ZWrite Off </span><br><span class="line">		ZTest Always</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">//纵向模糊</span></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			<span class="comment">//引入内置函数和变量</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//声明顶点着色器和片段着色器</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> multi_compile _SAMPLES_LOW _SAMPLES_MEDIUM _SAMPLES_HIGH</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> shader_feature GAUSS</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//模糊处理的原图、以及模糊参数</span></span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			<span class="keyword">float</span> _BlurSize;</span><br><span class="line">			<span class="keyword">float</span> _StandardDeviation;</span><br><span class="line"></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">define</span> PI 3.14159265359</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">define</span> E 2.71828182846</span></span><br><span class="line"></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">if</span> _SAMPLES_LOW</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">define</span> SAMPLES 10</span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">elif</span> _SAMPLES_MEDIUM</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">define</span> SAMPLES 30</span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">define</span> SAMPLES 100</span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//模型网格数据</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//中间插值数据</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//顶点着色器</span></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				<span class="comment">//变换到参见坐标系</span></span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				o.uv = v.uv;</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//片段着色器</span></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">if</span> GAUSS</span></span><br><span class="line">				<span class="comment">//当标准差为0时，不执行模糊操作</span></span><br><span class="line">				<span class="keyword">if</span>(_StandardDeviation == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> tex2D(_MainTex, i.uv);</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">				</span><br><span class="line">				float4 col = <span class="number">0</span>;</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">if</span> GAUSS</span></span><br><span class="line">				<span class="keyword">float</span> sum = <span class="number">0</span>;</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">				<span class="keyword">float</span> sum = SAMPLES;</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">				<span class="comment">//循环执行采样</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">float</span> index = <span class="number">0</span>; index &lt; SAMPLES; index++)&#123;</span><br><span class="line">					<span class="comment">//获取采样点到中心点的距离</span></span><br><span class="line">					<span class="keyword">float</span> offset = (index/(SAMPLES<span class="number">-1</span>) - <span class="number">0.5</span>) * _BlurSize;</span><br><span class="line">					<span class="comment">//计算采样点的坐标</span></span><br><span class="line">					float2 uv = i.uv + float2(<span class="number">0</span>, offset);</span><br><span class="line">				<span class="meta">#<span class="meta-keyword">if</span> !GAUSS</span></span><br><span class="line">					<span class="comment">//采样值累加</span></span><br><span class="line">					col += tex2D(_MainTex, uv);</span><br><span class="line">				<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">					<span class="comment">//计算高斯权重</span></span><br><span class="line">					<span class="keyword">float</span> stDevSquared = _StandardDeviation*_StandardDeviation;</span><br><span class="line">					<span class="keyword">float</span> gauss = (<span class="number">1</span> / <span class="built_in">sqrt</span>(<span class="number">2</span>*PI*stDevSquared)) * <span class="built_in">pow</span>(E, -((offset*offset)/(<span class="number">2</span>*stDevSquared)));</span><br><span class="line">					<span class="comment">//总权重</span></span><br><span class="line">					sum += gauss;</span><br><span class="line">					<span class="comment">//加权</span></span><br><span class="line">					col += tex2D(_MainTex, uv) * gauss;</span><br><span class="line">				<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//平均</span></span><br><span class="line">				col = col / sum;</span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//横向模糊</span></span><br><span class="line">		Pass&#123;</span><br><span class="line">			CGPROGRAM</span><br><span class="line">			<span class="comment">//引入内置函数和变量</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> multi_compile _SAMPLES_LOW _SAMPLES_MEDIUM _SAMPLES_HIGH</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> shader_feature GAUSS</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//声明顶点、片段着色器</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//用于模糊的原图、以及模糊参数</span></span><br><span class="line">			sampler2D _MainTex;</span><br><span class="line">			<span class="keyword">float</span> _BlurSize;</span><br><span class="line">			<span class="keyword">float</span> _StandardDeviation;</span><br><span class="line"></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">define</span> PI 3.14159265359</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">define</span> E 2.71828182846</span></span><br><span class="line"></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">if</span> _SAMPLES_LOW</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">define</span> SAMPLES 10</span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">elif</span> _SAMPLES_MEDIUM</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">define</span> SAMPLES 30</span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">define</span> SAMPLES 100</span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//模型网格数据</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//中间插值数据</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">				float2 uv : TEXCOORD0;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//顶点着色器</span></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				<span class="comment">//计算裁剪坐标</span></span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				o.uv = v.uv;</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//片段着色器</span></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">if</span> GAUSS</span></span><br><span class="line">				<span class="comment">//当标准差为0时，不执行模糊处理</span></span><br><span class="line">				<span class="keyword">if</span>(_StandardDeviation == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">return</span> tex2D(_MainTex, i.uv);</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">				<span class="comment">//计算横纵比</span></span><br><span class="line">				<span class="keyword">float</span> invAspect = _ScreenParams.y / _ScreenParams.x;</span><br><span class="line">				</span><br><span class="line">				float4 col = <span class="number">0</span>;</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">if</span> GAUSS</span></span><br><span class="line">				<span class="keyword">float</span> sum = <span class="number">0</span>;</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">				<span class="keyword">float</span> sum = SAMPLES;</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">				<span class="comment">//循环采样</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">float</span> index = <span class="number">0</span>; index &lt; SAMPLES; index++)&#123;</span><br><span class="line">					<span class="comment">//获取横向偏移值</span></span><br><span class="line">					<span class="keyword">float</span> offset = (index/(SAMPLES<span class="number">-1</span>) - <span class="number">0.5</span>) * _BlurSize * invAspect;</span><br><span class="line">					<span class="comment">//计算采样坐标</span></span><br><span class="line">					float2 uv = i.uv + float2(offset, <span class="number">0</span>);</span><br><span class="line">				<span class="meta">#<span class="meta-keyword">if</span> !GAUSS</span></span><br><span class="line">					<span class="comment">//采样值累加</span></span><br><span class="line">					col += tex2D(_MainTex, uv);</span><br><span class="line">				<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">					<span class="comment">//计算高斯权重</span></span><br><span class="line">					<span class="keyword">float</span> stDevSquared = _StandardDeviation*_StandardDeviation;</span><br><span class="line">					<span class="keyword">float</span> gauss = (<span class="number">1</span> / <span class="built_in">sqrt</span>(<span class="number">2</span>*PI*stDevSquared)) * <span class="built_in">pow</span>(E, -((offset*offset)/(<span class="number">2</span>*stDevSquared)));</span><br><span class="line">					<span class="comment">//总权重</span></span><br><span class="line">					sum += gauss;</span><br><span class="line">					<span class="comment">//加权</span></span><br><span class="line">					col += tex2D(_MainTex, uv) * gauss;</span><br><span class="line">				<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//平均</span></span><br><span class="line">				col = col / sum;</span><br><span class="line">				<span class="keyword">return</span> col;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以在以下链接找到源码：<br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/023_PostprocessingBlur/PostprocessingBlur.cs">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/023_PostprocessingBlur/PostprocessingBlur.cs</a><br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/023_PostprocessingBlur/PostprocessingBlur.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/023_PostprocessingBlur/PostprocessingBlur.shader</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/07/Ronja_Stencil_Buffers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/07/Ronja_Stencil_Buffers/" class="post-title-link" itemprop="url">Stencil Buffers</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-07 20:01:00" itemprop="dateCreated datePublished" datetime="2021-07-07T20:01:00+08:00">2021-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-30 00:35:25" itemprop="dateModified" datetime="2022-08-30T00:35:25+08:00">2022-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/022-stencil-buffers/">Stencil Buffers</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>深度缓存可以帮助我们对比模型之间的深度关系，确保模型之间正确遮挡。还有另一部分缓存用于模板操作，这个缓存叫做模板缓存。模板缓存就像一个印刷版，只有部分区域允许渲染到屏幕上。</p>
<p>Unity也有用到模板缓存来实现延迟渲染，所以如果你在执行延迟渲染时，会有一些限制。你可以阅读<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/SL-Stencil.html">官方文档</a>去了解这些具体的限制，深入了解如何使用模板。</p>
<p>本教程将会介绍模板缓存的基本使用，包括模板读写操作。这里也从<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Surface_Shader_Basics/">表面着色器</a>中的着色器脚本开始，来实现模板缓存案例。当然使用方法适用于其他着色器，包括后处理操作。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/022/Result.gif"></p>
<h2 id="Reading-form-the-Stencil-Buffer"><a href="#Reading-form-the-Stencil-Buffer" class="headerlink" title="Reading form the Stencil Buffer"></a>Reading form the Stencil Buffer</h2><p>在使用模板的着色器中，着色器会读取模板中的值，然后以这个值按照一定条件来进行判断当前像素是否可以写入到帧缓存中，如果可以，那么再按一定条件刷新当前模板缓存值，如果不行，那么放弃后面所有操作。</p>
<p>所有的模板操作都是集中在一个叫做<code>Stencil</code>的块中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SubShader &#123;</span><br><span class="line">    Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    Stencil&#123;</span><br><span class="line">        <span class="comment">//模板操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表面着色器代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在模板参数中最重要的是<code>Ref</code>，这个参数是我们模板操作的参考值。在模板写入之前，模板缓存中的默认值是0。一般在所以操作之前我都会手动初始化模板缓存为0，这样可以让代码看起来逻辑更清晰。</p>
<p>下一个参数叫做<code>Comp</code>，定义了模板比较方法，什么情况下可以通过模板，什么时候不行，其默认值为<code>Always</code>，表示所有都无条件通过。在本文实现的着色器中，我们使用<code>Equal</code>这个比较方法，这意味着只有模板值等于参考值时，才能通过模板。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stencil&#123;</span><br><span class="line">    Ref <span class="number">0</span></span><br><span class="line">    Comp Equal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/022/NormalMaterial.png"></p>
<p>上面的模板设置并不会影响原本模型的显示，这是因为模板初始值为0，而参考值也为0，刚好所有值都通过模板。如果我们将参考值改为其他值，这时候模型会消失，因为所有模板值都未通过。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stencil&#123;</span><br><span class="line">    Ref <span class="number">1</span></span><br><span class="line">    Comp Equal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/022/Invisible.png"></p>
<p>为了方便后面调整，这里我将模板参考值暴露在材质面板上，这样我们可以通过材质面板来修改模板参考值。这里<code>IntRange</code>表示我们的滑块刻度是取整的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Properties &#123;</span><br><span class="line">    _Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    _Smoothness (<span class="string">&quot;Smoothness&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">    _Metallic (<span class="string">&quot;Metalness&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">    [HDR] _Emission (<span class="string">&quot;Emission&quot;</span>, color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    [IntRange] _StencilRef (<span class="string">&quot;Stencil Reference Value&quot;</span>, Range(<span class="number">0</span>,<span class="number">255</span>)) = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们将模板操作中的参考值改为<code>_StancilRef</code>，这里将其放在中括号里面，表示我们这个值是属性块中的值，着色器会进行关联。这样修改之后好像我们的模型也还是只有显示我不显示两个状态，但是，使用材质面板上的滑块可以在两者之间进行快速切换。</p>
<h2 id="Writing-to-the-Stencil-Buffer"><a href="#Writing-to-the-Stencil-Buffer" class="headerlink" title="Writing to the Stencil Buffer"></a>Writing to the Stencil Buffer</h2><p>在实际应用中，我们除了需要根据模板来绝对哪些需要渲染，哪些不渲染，还要有能够向模板中写入新的数值得着色器。上面实现的是读取模板的着色器，下面我们实现第二个写入模板的着色器。第二个着色器的主要功能是对模板进行操作，所以不需要写入到帧缓存。这样在第一个着色器执行的时候，就可以使用第二个着色器写入的模板值进行渲染判断。</p>
<p>第二个着色器我们使用最<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Basic_Shader/">简单的着色器</a>，因为我们只想对模板进行操作，不打算渲染其他东西。</p>
<p>那么对于第二个写入模板的着色器，我们将其片段着色器的返回值直接写为0，因为我们不想渲染它。然后设置混合模式为<code>Zero One</code>，这表示不会影响之前绘制好的像素。还有就是需要关闭深度写入功能，因为这个模型不渲染，说过写入深度的话，那么可能会遮挡后面的模型，这就会显得很诡异。最后是要保证第二个着色器比第一个着色器先执行，也就是先写后读，我们可以设置渲染队列顺序来实现。<br>同时我们还删除颜色变量，因为我们不需要。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Blend Zero One</span><br><span class="line">ZWrite Off</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry-1&quot;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清空材质面板</span></span><br><span class="line">Properties&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/022/Invisible.png"></p>
<p>这样我们实现了一个完全不显示的着色器，这个着色器相比第一个着色器的优势是，它完全不受模板值得影响。因为不管模板值什么，它都不会显示出来。</p>
<p>然后我们将第一个着色器中的模板设置拷贝过来。然后将比较方法设置为<code>Always</code>，这表第二个着色器无条件通过模板。然后在加入一个<code>Pass</code>属性，它定义了当通过深度检测后，模板值将会如何。这里我们将它设为<code>Replace</code>，这表示当深度检测通过后，使用参考值替代原本的模板值。这里还有一个<code>Fail</code>的属性，是当检测失败后应该执行什么操作，默认是不做任何操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stencil&#123;</span><br><span class="line">    Ref [_StencilRef]</span><br><span class="line">    Comp Always</span><br><span class="line">    Pass Replace</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/022/SphereAndQuad.png"></p>
<p>现在我们可以看到，当它们的参考值相同时，第一个材质物体和第二个材质物体重叠部分可见。</p>
<p>实现这两个着色器的过程中，我们已经知道了模板的基本用法。如果你想了解更多，你可以参考Unity的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/SL-Stencil.html">官方文档</a>。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/022/WrongStencil.png"></p>
<p>在不断尝试后，我遇到一个问题。当有多个模板在对同一个像素点进行读写操作时，后面的(离摄像机更远)模板可能比前一个模板更晚执行，这样可能会覆盖原先的模板值。如果你也遇到类似的问题，那么你可以通过调整它们的渲染队列来保证它们的执行顺序。Unity中，当渲染队列值大于2500时，模型是从后往前渲染的。这样做的目的是为了保证透明物体正确渲染。所以我们同样可以通过渲染队列来控制模板的顺序。在我的例子中，我使用2501来作为写模板队列，而2052最为读渲染队列，这样保证写模板在读模板之前执行。还有一点就是我们的模板队列不要超过3000，因为超过3000为半透明物体的可用渲染队列值，它们的队列值混在一起可能会出问题。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/022/ReadInspector.png"><br><img src="https://www.ronja-tutorials.com/assets/images/posts/022/Result.gif"></p>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/022_stencil_buffer/read&quot;</span> &#123;</span><br><span class="line">	Properties &#123;</span><br><span class="line">		_Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">		_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">		_Smoothness (<span class="string">&quot;Smoothness&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">		_Metallic (<span class="string">&quot;Metalness&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">		[HDR] _Emission (<span class="string">&quot;Emission&quot;</span>, color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">		[IntRange] _StencilRef (<span class="string">&quot;Stencil Reference Value&quot;</span>, Range(<span class="number">0</span>,<span class="number">255</span>)) = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	SubShader &#123;</span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模板操作</span></span><br><span class="line">		Stencil&#123;</span><br><span class="line">			Ref [_StencilRef]</span><br><span class="line">			Comp Equal</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		CGPROGRAM</span><br><span class="line"></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">pragma</span> surface surf Standard fullforwardshadows</span></span><br><span class="line">		<span class="meta">#<span class="meta-keyword">pragma</span> target 3.0</span></span><br><span class="line"></span><br><span class="line">		sampler2D _MainTex;</span><br><span class="line">		fixed4 _Color;</span><br><span class="line"></span><br><span class="line">		half _Smoothness;</span><br><span class="line">		half _Metallic;</span><br><span class="line">		half3 _Emission;</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">			float2 uv_MainTex;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">			fixed4 col = tex2D(_MainTex, i.uv_MainTex);</span><br><span class="line">			col *= _Color;</span><br><span class="line">			o.Albedo = col.rgb;</span><br><span class="line">			o.Metallic = _Metallic;</span><br><span class="line">			o.Smoothness = _Smoothness;</span><br><span class="line">			o.Emission = _Emission;</span><br><span class="line">		&#125;</span><br><span class="line">		ENDCG</span><br><span class="line">	&#125;</span><br><span class="line">	FallBack <span class="string">&quot;Standard&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/022_stencil_buffer/write&quot;</span>&#123;</span><br><span class="line">	<span class="comment">//材质面板</span></span><br><span class="line">	Properties&#123;</span><br><span class="line">		[IntRange] _StencilRef (<span class="string">&quot;Stencil Reference Value&quot;</span>, Range(<span class="number">0</span>,<span class="number">255</span>)) = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	SubShader&#123;</span><br><span class="line">		<span class="comment">//将队列值设在读模板之前</span></span><br><span class="line">		Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry-1&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模板操作</span></span><br><span class="line">		Stencil&#123;</span><br><span class="line">			Ref [_StencilRef]</span><br><span class="line">			Comp Always</span><br><span class="line">			Pass Replace</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Pass&#123;</span><br><span class="line">            <span class="comment">//不写入帧缓存、也不写入深入，只负责写入模板</span></span><br><span class="line">			Blend Zero One</span><br><span class="line">			ZWrite Off</span><br><span class="line"></span><br><span class="line">			CGPROGRAM</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">			<span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">			struct appdata&#123;</span><br><span class="line">				float4 vertex : POSITION;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">				float4 position : SV_POSITION;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			<span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">				v2f o;</span><br><span class="line">				<span class="comment">//计算裁剪坐标</span></span><br><span class="line">				o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">				<span class="keyword">return</span> o;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			ENDCG</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望通过本篇教程让你了解模板的使用。</p>
<p>你可以在以下链接找到源码：<br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/022_Stencil_Buffer/stencil_read.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/022_Stencil_Buffer/stencil_read.shader</a><br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/022_Stencil_Buffer/stencil_write.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/022_Stencil_Buffer/stencil_write.shader</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/07/Ronja_Clipping_a_Model_with_a_Plane/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/07/Ronja_Clipping_a_Model_with_a_Plane/" class="post-title-link" itemprop="url">Clipping a Model with a Plane</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-07 19:01:00" itemprop="dateCreated datePublished" datetime="2021-07-07T19:01:00+08:00">2021-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-30 00:35:25" itemprop="dateModified" datetime="2022-08-30T00:35:25+08:00">2022-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/021-plane-clipping/">Clipping a Model with a Plane</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>另一个比较炫酷的效果是，根据指定区域对模型进行裁剪。</p>
<p>我们这篇教程需要你掌握表面着色器的基本知识，所以建议你先阅读<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Surface_Shader_Basics/">这篇</a>教程。</p>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/021/Result.gif"></p>
<h2 id="Define-Plane"><a href="#Define-Plane" class="headerlink" title="Define Plane"></a>Define Plane</h2><p>首先我们需要新建一个<code>C#</code>脚本，用来设置裁剪平面用的，然后将平面参数传递个着色器，还需要定义一个绑定该着色器的材质变量。我们使用<code>[ExecuteAlways]</code>标签让脚本在编辑模式下一直执行。当然，你可以根据你自身的需求考虑要不要加，毕竟就算不加，当程序运行时，该脚本也会正常执行。</p>
<p>我们在<code>Update</code>函数中新建一个类型为<code>Plane</code>的变量，并向其构造函数中传入平面的法向量，和平面上任意一个点的坐标。这里我们将选择脚本所在的物体的<code>Y</code>轴正方向为平面的法向量，脚本所在的物体的位置为平面上的任意一点。换句话说，我们这个平面就是脚本所在物体的局部坐标系的<code>O-XZ</code>平面。</p>
<p>然后我们创建一个四维向量，将平面的法向量传递给该向量的前三个元素，然后第四个元素存储平面到世界原点的距离。后面我会解释这些值得含义。</p>
<p>然后我们将这个四维变量传递给着色器。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">[<span class="meta">ExecuteAlways</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClippingPlane</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="comment">//用于裁剪的材质球</span></span><br><span class="line">    <span class="keyword">public</span> Material mat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每帧都会执行一次</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个平面</span></span><br><span class="line">        Plane plane = <span class="keyword">new</span> Plane(transform.up, transform.position);</span><br><span class="line">        <span class="comment">//平面参数</span></span><br><span class="line">        Vector4 planeRepresentation = <span class="keyword">new</span> Vector4(plane.normal.x, plane.normal.y, plane.normal.z, plane.distance);</span><br><span class="line">        <span class="comment">//传递给着色器中的_Plane变量</span></span><br><span class="line">        mat.SetVector(<span class="string">&quot;_Plane&quot;</span>, planeRepresentation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们将该脚本绑定到物体上，该物体将被当做我们的裁剪工具。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/021/PlaneInspector.png"></p>
<h2 id="Clip-Plane"><a href="#Clip-Plane" class="headerlink" title="Clip Plane"></a>Clip Plane</h2><p>接下来实现我们的着色器，这里我沿用<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Surface_Shader_Basics/">表面作色器</a>中的着色器。</p>
<p>首先我们需要在着色器中添加<code>_Plane</code>公共变量，因为这个变量是通过脚本赋值的，所以不需要出现在<code>Properties</code>块中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float4 _Plane;</span><br></pre></td></tr></table></figure>

<p>在表面着色器中我们可以计算模型表面上的点，到过原点与我们这个自定义平面平行的平面的距离。这个距离可以通过表面上的点坐标和平面法向量的点乘来计算。如果这个带你在我们的自定义平面上，那么这个距离值将会等于平面参数中的距离值。如果这个距离值大于平面参数中的距离值，那么这个点在平面上方，小于则在其下方。</p>
<p>要实现这个位置判断，我们需要计算模型顶点的世界坐标。在表面着色器中，我们只需要在输入结构体中加入<code>worldPos</code>变量，根据命名规则，表面作色器会自动给我们计算世界坐标。如果是其他着色器，那么我们需要使用模型矩阵自行计算。然后将距离传递给自发光变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表面着色器中的输入数据，由其自动计算</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">    float2 uv_MainTex;</span><br><span class="line">    float3 worldPos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表面作色器函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算点到屏幕的距离</span></span><br><span class="line">    <span class="keyword">float</span> distance = dot(i.worldPos, _Plane.xyz);</span><br><span class="line">    o.Emission = distance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/021/OriginPlaneDistance.gif"></p>
<p>上图中平面的方向会影响亮度，但是位置却不会。这是因为我们还没有应用平面的位置参数。接下来我们将这个距离参数应用上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表面作色器函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算点到屏幕的距离</span></span><br><span class="line">    <span class="keyword">float</span> distance = dot(i.worldPos, _Plane.xyz);</span><br><span class="line">    distance = distance + _Plane.w;<span class="comment">//应用平面距离参数</span></span><br><span class="line">    o.Emission = distance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/021/PlaneDistance.gif"></p>
<p>这里计算出来的距离是一个矢量，具有方向性，在平面上方的大于零，平面下方的小于零，因此上图中显示的平面两侧的亮度不一样。我们可以应用这个特性来将平面某一侧的模型剔除掉。例如这里不渲染平面上方的模型，只渲染平面下方的模型。</p>
<p>在前面的教程中有介绍，可以在片段着色器中使用<code>clip</code>函数来剔除某些像素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表面着色器函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算点到面的距离</span></span><br><span class="line">    <span class="keyword">float</span> distance = dot(i.worldPos, _Plane.xyz);</span><br><span class="line">    distance = distance + _Plane.w;</span><br><span class="line">    clip(-distance);<span class="comment">//剔除平面上方的模型</span></span><br><span class="line">    o.Emission = distance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/021/ClipWithDistance.png"></p>
<p>现在我们可以看到上面的模型已经被剔除了，这时候我们也不用自发光的亮度来表示哪里是平面的上方，可以恢复模型原本的纹理颜色。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表面着色器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//计算点到面的距离</span></span><br><span class="line">    <span class="keyword">float</span> distance = dot(i.worldPos, _Plane.xyz);</span><br><span class="line">    distance = distance + _Plane.w;</span><br><span class="line">    o.Emission = distance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//纹理采样</span></span><br><span class="line">    fixed4 col = tex2D(_MainTex, i.uv_MainTex);</span><br><span class="line">    col *= _Color;</span><br><span class="line">    o.Albedo = col.rgb;</span><br><span class="line">    o.Metallic = _Metallic;</span><br><span class="line">    o.Smoothness = _Smoothness;</span><br><span class="line">    o.Emission = _Emission;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Show-Inside"><a href="#Show-Inside" class="headerlink" title="Show Inside"></a>Show Inside</h2><p>虽然我们的模型成功的被平面裁剪为两半，但是剩下的这一部分看起来很怪异，好像缺了一部分，到处是孔洞。造成这种现象的原因是，默认情况下我们只渲染模型的正面，因为我们可以肯定模型背面，也就是其内部不会被渲染，这样起到一个优化的作用。但是，现在我们的模型被切开了，内部允许被看到，所以应该取消背面剔除功能。</p>
<p>要同时渲染模型的正反面，我们只需将着色器的<code>Cull</code>设置为<code>Off</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SubShader&#123;</span><br><span class="line">    <span class="comment">//不透明物体</span></span><br><span class="line">    Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭剔除功能，这样模型的两个面都可以被渲染</span></span><br><span class="line">    Cull Off</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们可以看到模型的内侧了，但是模型的法向量依然是指向外侧的，同时我们可能也不想看到内侧。这时候我们可以很容易的区分当前渲染的像素是内侧还是外侧。我们需要在表面着色器的输入结构体中加入一个表明像素朝向的变量。这个变量也是有表面着色器自行填充，1表示外侧，-1表示内侧。</p>
<p>这里我们还是用插值函数来实现内外侧的不同显示效果，所以我们需要将朝向变量映射到0-1之间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表面着色器的输入值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">    float2 uv_MainTex;</span><br><span class="line">    float3 worldPos;</span><br><span class="line">    <span class="keyword">float</span> facing : VFACE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> facing = i.facing * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line">o.Emission = facing;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/021/Facing.png"></p>
<p>上图可以看到我们已经可以清楚地区分内外侧了。我们可以给内侧指定一个颜色，然后外侧按照正常显示。我们需要一个内侧颜色，并且将这个颜色应用到自发光变量上。因为我们模型内侧的法向量是错误的，所以在计算光照候的结果也将是错误的，而自发光的颜色不受光照影响。另外，我们也将朝向值应用到其他光照参数上，这样保证内侧不会进行光照计算。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//材质面板</span></span><br><span class="line">Properties&#123;</span><br><span class="line">    _Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    _Smoothness (<span class="string">&quot;Smoothness&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">    _Metallic (<span class="string">&quot;Metalness&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">    [HDR]_Emission (<span class="string">&quot;Emission&quot;</span>, color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    [HDR]_CutoffColor(<span class="string">&quot;Cutoff Color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float4 _CutoffColor;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为0时表示内侧， 1表示外侧</span></span><br><span class="line"><span class="keyword">float</span> facing = i.facing * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//纹理采样</span></span><br><span class="line">fixed4 col = tex2D(_MainTex, i.uv_MainTex);</span><br><span class="line">col *= _Color;</span><br><span class="line">o.Albedo = col.rgb * facing;</span><br><span class="line">o.Metallic = _Metallic * facing;</span><br><span class="line">o.Smoothness = _Smoothness * facing;</span><br><span class="line">o.Emission = lerp(_CutoffColor, _Emission, facing);</span><br></pre></td></tr></table></figure>

<p><img src="https://www.ronja-tutorials.com/assets/images/posts/021/Result.gif"></p>
<p>在裁剪面上的颜色显示还是有些不正常，因为还会受到环境光的影响，但是这需要我们重写全局光才能排除其影响，本文并不打算深入这一块。</p>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/021_Clipping_Plane&quot;</span>&#123;</span><br><span class="line">    <span class="comment">//材质面板</span></span><br><span class="line">    Properties&#123;</span><br><span class="line">        _Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Smoothness (<span class="string">&quot;Smoothness&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">        _Metallic (<span class="string">&quot;Metalness&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">        [HDR]_Emission (<span class="string">&quot;Emission&quot;</span>, color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        [HDR]_CutoffColor(<span class="string">&quot;Cutoff Color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader&#123;</span><br><span class="line">        <span class="comment">//不透明物体</span></span><br><span class="line">        Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双面渲染</span></span><br><span class="line">        Cull Off</span><br><span class="line"></span><br><span class="line">        CGPROGRAM</span><br><span class="line">        <span class="comment">//表面着色器</span></span><br><span class="line">        <span class="comment">//表面着色器函数和光照模型</span></span><br><span class="line">        <span class="comment">//fullforwardshadows 使用所有的阴影Pass</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> surface surf Standard fullforwardshadows</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> target 3.0</span></span><br><span class="line"></span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line">        fixed4 _Color;</span><br><span class="line"></span><br><span class="line">        half _Smoothness;</span><br><span class="line">        half _Metallic;</span><br><span class="line">        half3 _Emission;</span><br><span class="line"></span><br><span class="line">        float4 _Plane;</span><br><span class="line"></span><br><span class="line">        float4 _CutoffColor;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//表面着色器输入数据</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">            float2 uv_MainTex;</span><br><span class="line">            float3 worldPos;</span><br><span class="line">            <span class="keyword">float</span> facing : VFACE;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//表面着色器</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//计算点到面的距离</span></span><br><span class="line">            <span class="keyword">float</span> distance = dot(i.worldPos, _Plane.xyz);</span><br><span class="line">            distance = distance + _Plane.w;</span><br><span class="line">            <span class="comment">//移除平面上的点</span></span><br><span class="line">            clip(-distance);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> facing = i.facing * <span class="number">0.5</span> + <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//纹理采样</span></span><br><span class="line">            fixed4 col = tex2D(_MainTex, i.uv_MainTex);</span><br><span class="line">            col *= _Color;</span><br><span class="line">            o.Albedo = col.rgb * facing;</span><br><span class="line">            o.Metallic = _Metallic * facing;</span><br><span class="line">            o.Smoothness = _Smoothness * facing;</span><br><span class="line">            o.Emission = lerp(_CutoffColor, _Emission, facing);</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Standard&quot;</span> <span class="comment">//后补着色器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本文的裁剪方案可以实现模型消失的效果，也可以实现简单的水在容器中的效果。希望这个教程让你有所收获。</p>
<p>你可以在以下链接找到源码：<br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/021_Clipping_Plane/ClippingPlane.cs">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/021_Clipping_Plane/ClippingPlane.cs</a><br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/021_Clipping_Plane/ClippingPlane.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/021_Clipping_Plane/ClippingPlane.shader</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/07/Ronja_Hull_Outlines/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/07/Ronja_Hull_Outlines/" class="post-title-link" itemprop="url">Hull Outlines</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-07 13:01:00" itemprop="dateCreated datePublished" datetime="2021-07-07T13:01:00+08:00">2021-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-30 00:35:25" itemprop="dateModified" datetime="2022-08-30T00:35:25+08:00">2022-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/020-hull-outline/">Hull Outlines</a></p>
<p>到目前为止，我们基本上是一个着色器只会执行一次将模型绘制到屏幕上。实际上在一个着色器中是允许对一个模型绘制多次。比如说我们接下来的轮廓实现方案就需要对模型绘制多次。首先按往常一样渲染一遍模型，然后将模型顶点沿着法线方向移动一点，然后再次进行绘制，而这第二次绘制的模型会出现在上一次绘制的边缘处，也就是我们想得到的轮廓。</p>
<p>为了能够更好的理解本文，建议你先了解什么是<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Surface_Shader_Basics/">表面着色器</a>，以及<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Basic_Shader/">无光照着色器</a>。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/020/Result.png"></p>
<h2 id="Outlines-for-Unlit-Shaders"><a href="#Outlines-for-Unlit-Shaders" class="headerlink" title="Outlines for Unlit Shaders"></a>Outlines for Unlit Shaders</h2><p>沿用之前无光照着色器脚本，我们只需要将其中的<code>Pass</code>复制一遍就可以。现在有两个完全相同的<code>Pass</code>，所以即便是绘制两遍，最终的结果也是一样的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复制出来的，用于绘制轮廓的Pass</span></span><br><span class="line">Pass&#123;</span><br><span class="line">    CGPROGRAM</span><br><span class="line"></span><br><span class="line">    <span class="comment">//引入内置函数和变量</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明顶点、片段着色器</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//模型表面纹理</span></span><br><span class="line">    sampler2D _MainTex;</span><br><span class="line">    float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模型颜色</span></span><br><span class="line">    fixed4 _Color;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模型网格数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">        float4 vertex : POSITION;</span><br><span class="line">        float2 uv : TEXCOORD0;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中间插值数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">        float4 position : SV_POSITION;</span><br><span class="line">        float2 uv : TEXCOORD0;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//顶点着色器</span></span><br><span class="line">    <span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">        v2f o;</span><br><span class="line">        <span class="comment">//计算裁剪坐标</span></span><br><span class="line">        o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">        o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//片段着色器</span></span><br><span class="line">    <span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">        fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">        col *= _Color;</span><br><span class="line">        <span class="keyword">return</span> col;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ENDCG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们需要对上面这个<code>Pass</code>的变量进行修改，因为轮廓不需要纹理，只需要轮廓颜色、轮廓宽度，所以我们删除纹理变量，然后增加轮廓颜色、和轮廓宽度变量，并且在<code>Properties</code>块中添加这两个属性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//材质面板</span></span><br><span class="line">Properties&#123;</span><br><span class="line">    _OutlineColor (<span class="string">&quot;Outline Color&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    _OutlineThickness (<span class="string">&quot;Outline Thickness&quot;</span>, Range(<span class="number">0</span>,<span class="number">.1</span>)) = <span class="number">0.03</span></span><br><span class="line"></span><br><span class="line">    _Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//轮廓颜色</span></span><br><span class="line">fixed4 _OutlineColor;</span><br><span class="line"><span class="comment">//轮廓宽度</span></span><br><span class="line"><span class="keyword">float</span> _OutlineThickness;</span><br></pre></td></tr></table></figure>

<p>接下来是修改片段着色器，直接返回我们的轮廓颜色。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _OutlineColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们没有使用纹理，所以与纹理相关的UV变量也不需要，所以可以将其从那些结构体中删除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模型网格数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中间插值数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">    float4 position : SV_POSITION;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点着色器</span></span><br><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    <span class="comment">//计算裁剪坐标</span></span><br><span class="line">    o.position = UnityObjectToClipPos(position);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://www.ronja-tutorials.com/assets/images/posts/020/DarkMonkey.png"></p>
<p>上图是修改后的显示效果，我们的物体最终显示为轮廓色，这是因为我们第二个<code>Pass</code>将第一个<code>Pass</code>渲染的图完全覆盖了。我们接下来处理这个问题。</p>
<p>为了保证我们的第二个<code>Pass</code>超出第一个<code>Pass</code>的显示范围，从而形成轮廓。我们需要将模型的顶点沿着其法向量的方向偏移。因此我们需要在模型网格数据中传入法向量，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模型网格数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">    float4 vertex : POSITION;</span><br><span class="line">    float3 normal : NORMAL;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶点着色器</span></span><br><span class="line"><span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">    v2f o;</span><br><span class="line">    <span class="comment">//顶点沿着法向偏移</span></span><br><span class="line">    float3 normal = normalize(v.normal);</span><br><span class="line">    float3 outlineOffset = normal * _OutlineThickness;</span><br><span class="line">    float3 position = v.vertex + outlineOffset;</span><br><span class="line">    <span class="comment">//计算裁剪坐标</span></span><br><span class="line">    o.position = UnityObjectToClipPos(position);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在可以可以通过<code>_OutlineThinckness</code>来控制边缘的宽度，但是我们第一个<code>Pass</code>渲染的画面还是被遮挡了。为了修复这个问题，我们将第二个<code>Pass</code>改为正面剔除。这样可以保证第二个<code>Pass</code>渲染的画面永远在第一个<code>Pass</code>之后。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二个Pass， 用来绘制轮廓</span></span><br><span class="line">Pass&#123;</span><br><span class="line">    Cull Front</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/020/SimpleOutlines.png"></p>
<p>上图就是我们得到的轮廓了。</p>
<h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/19_InvertedHull/Unlit&quot;</span>&#123;</span><br><span class="line">    <span class="comment">//材质面板</span></span><br><span class="line">    Properties&#123;</span><br><span class="line">        _OutlineColor (<span class="string">&quot;Outline Color&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        _OutlineThickness (<span class="string">&quot;Outline Thickness&quot;</span>, Range(<span class="number">0</span>,<span class="number">.1</span>)) = <span class="number">0.03</span></span><br><span class="line"></span><br><span class="line">        _Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader&#123;</span><br><span class="line">        <span class="comment">//不透明物体</span></span><br><span class="line">        Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个Pass， 用来渲染模型本身</span></span><br><span class="line">        Pass&#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="comment">//引入内置函数和变量</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//声明顶点和片段着色器</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//模型纹理</span></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//模型颜色</span></span><br><span class="line">            fixed4 _Color;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//模型网格数据</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//中间插值数据</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">                float4 position : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//顶点着色器</span></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">//计算裁剪坐标</span></span><br><span class="line">                o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//片段着色器</span></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">                fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">                col *= _Color;</span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二个Pass，用来绘制轮廓</span></span><br><span class="line">        Pass&#123;</span><br><span class="line">            Cull front</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="comment">//引入内置函数和变量</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//声明顶点和片段着色器</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//轮廓颜色</span></span><br><span class="line">            fixed4 _OutlineColor;</span><br><span class="line">            <span class="comment">//轮廓宽度</span></span><br><span class="line">            <span class="keyword">float</span> _OutlineThickness;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//模型网格数据</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float3 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//中间插值数据</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">                float4 position : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//顶点着色器</span></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">//沿着法向移动顶点</span></span><br><span class="line">                float3 normal = normalize(v.normal);</span><br><span class="line">                float3 outlineOffset = normal * _OutlineThickness;</span><br><span class="line">                float3 position = v.vertex + outlineOffset;</span><br><span class="line">                <span class="comment">//计算裁剪坐标</span></span><br><span class="line">                o.position = UnityObjectToClipPos(position);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//片段着色器</span></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> _OutlineColor;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后补着色器</span></span><br><span class="line">    FallBack <span class="string">&quot;Standard&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Outlines-with-Surface-Shaders"><a href="#Outlines-with-Surface-Shaders" class="headerlink" title="Outlines with Surface Shaders"></a>Outlines with Surface Shaders</h2><p>前面是在普通的顶点、片段着色其中应用轮廓效果，在表面着色器中其实也一样。对于表面着色器，Unity会自动生成部分代码，但是不会改动我们写入的代码，因此我们可以直接将前面的第二个轮廓<code>Pass</code>直接复制过来，并且可以实现同样的轮廓效果。</p>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/020/Result.png"></p>
<h3 id="Source-1"><a href="#Source-1" class="headerlink" title="Source"></a>Source</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/020_InvertedHull/Surface&quot;</span> &#123;</span><br><span class="line">    Properties &#123;</span><br><span class="line">        _Color (<span class="string">&quot;Tint&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        _MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _Smoothness (<span class="string">&quot;Smoothness&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">        _Metallic (<span class="string">&quot;Metalness&quot;</span>, Range(<span class="number">0</span>, <span class="number">1</span>)) = <span class="number">0</span></span><br><span class="line">        [HDR] _Emission (<span class="string">&quot;Emission&quot;</span>, color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        _OutlineColor (<span class="string">&quot;Outline Color&quot;</span>, Color) = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        _OutlineThickness (<span class="string">&quot;Outline Thickness&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.1</span></span><br><span class="line">    &#125;</span><br><span class="line">    SubShader &#123;</span><br><span class="line">        <span class="comment">//不透明物体</span></span><br><span class="line">        Tags&#123; <span class="string">&quot;RenderType&quot;</span>=<span class="string">&quot;Opaque&quot;</span> <span class="string">&quot;Queue&quot;</span>=<span class="string">&quot;Geometry&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">        CGPROGRAM</span><br><span class="line">        <span class="comment">//表面着色器</span></span><br><span class="line">        <span class="comment">//表面着色器函数和光照模型</span></span><br><span class="line">        <span class="comment">//fullforwardshadows 使用所有的阴影Pass</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> surface surf Standard fullforwardshadows</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">pragma</span> target 3.0</span></span><br><span class="line"></span><br><span class="line">        sampler2D _MainTex;</span><br><span class="line">        fixed4 _Color;</span><br><span class="line"></span><br><span class="line">        half _Smoothness;</span><br><span class="line">        half _Metallic;</span><br><span class="line">        half3 _Emission;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//表面着色器的输入数据</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Input</span> &#123;</span></span><br><span class="line">            float2 uv_MainTex;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//表面着色函数，主要计算光照模型所需的参数</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">surf</span> <span class="params">(Input i, inout SurfaceOutputStandard o)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//纹理采样</span></span><br><span class="line">            fixed4 col = tex2D(_MainTex, i.uv_MainTex);</span><br><span class="line">            col *= _Color;</span><br><span class="line">            o.Albedo = col.rgb;</span><br><span class="line">            <span class="comment">//光照模型相关参数</span></span><br><span class="line">            o.Metallic = _Metallic;</span><br><span class="line">            o.Smoothness = _Smoothness;</span><br><span class="line">            o.Emission = _Emission;</span><br><span class="line">        &#125;</span><br><span class="line">        ENDCG</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二个轮廓Pass</span></span><br><span class="line">        Pass&#123;</span><br><span class="line">            Cull Front</span><br><span class="line"></span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">            <span class="comment">//引入内置函数和变量</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//声明顶点、片段着色器</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//轮廓颜色、粗细</span></span><br><span class="line">            fixed4 _OutlineColor;</span><br><span class="line">            <span class="keyword">float</span> _OutlineThickness;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//模型网格数据</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float4 normal : NORMAL;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//中间插值数据</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">                float4 position : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//顶点着色器</span></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">//计算裁剪坐标</span></span><br><span class="line">                o.position = UnityObjectToClipPos(v.vertex + normalize(v.normal) * _OutlineThickness);</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//片段着色器</span></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> _OutlineColor;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FallBack <span class="string">&quot;Standard&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本篇轮廓实现方案和上一篇后处理轮廓方案的区别在于，本文所有的作色器是应用到个体模型上，所以可以根据需要选择哪些模型显示轮廓，并且还可以调节轮廓的宽度，整体的表现效果也有很大的差异。如果说哪个方案好，我觉得我们应该掌握这两种轮廓方案，然后根据实际情况进行选择。</p>
<p>希望你能通过本篇，了解如何在一个着色器中使用多个<code>Pass</code>，并且知道如何利用它们来实现轮廓效果。</p>
<p>你可以在以下链接找到源码：<br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/020_Inverted_Hull/UnlitOutlines.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/020_Inverted_Hull/UnlitOutlines.shader</a><br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/020_Inverted_Hull/SurfaceOutlines.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/020_Inverted_Hull/SurfaceOutlines.shader</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/07/Ronja_Outlines_via_Postprocessing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/07/Ronja_Outlines_via_Postprocessing/" class="post-title-link" itemprop="url">Postprocessing with Normal Texture</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-07 12:01:00" itemprop="dateCreated datePublished" datetime="2021-07-07T12:01:00+08:00">2021-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-30 00:35:25" itemprop="dateModified" datetime="2022-08-30T00:35:25+08:00">2022-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/018-postprocessing-normal/">Postprocessing with Normal Texture</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>边界后处理算是我最喜欢的后处理了。通过后处理的方式实现边缘绘制有很多优势，不需要修改模型原本的材质着色器，边缘检测的效果相比也更好。</p>
<p>阅读本文前，需要掌握深度法向纹理相关的知识，如果你不曾了解，建议你阅读我之前的<a href="https://tyson-wu.github.io/blogs/2021/07/06/Ronja_Postprocessing_with_Normal_Texture/">教程</a>。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/019/Result.gif"></p>
<h2 id="Depth-Outlines"><a href="#Depth-Outlines" class="headerlink" title="Depth Outlines"></a>Depth Outlines</h2><p>这里我们还是沿续上一篇关于深度法向贴图的<a href="https://tyson-wu.github.io/blogs/2021/07/06/Ronja_Postprocessing_with_Normal_Texture/">教程</a>，并且使用之前的脚本。</p>
<p>首先我们将上一个教程中关于顶部着色的部分删掉，与之相关的变量也可以删掉，还有后处理脚本中的变换矩阵。然后我们将片段着色器中计算深度和法向之后的所有代码删除掉。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//材质面板</span></span><br><span class="line">Properties&#123;</span><br><span class="line">    [HideInInspector]_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//深度法向采样</span></span><br><span class="line">    float4 depthnormal = tex2D(_CameraDepthNormalsTexture, i.uv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//深度法向解码</span></span><br><span class="line">    float3 normal;</span><br><span class="line">    <span class="keyword">float</span> depth;</span><br><span class="line">    DecodeDepthNormal(depthnormal, depth, normal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//还原深度值</span></span><br><span class="line">    depth = depth * _ProjectionParams.z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后删除后处理脚本中的向着色器传递矩阵的命令。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//场景渲染完后，会调用该函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnRenderImage</span><span class="params">(RenderTexture source, RenderTexture destination)</span></span>&#123;</span><br><span class="line">    <span class="comment">//执行后处理</span></span><br><span class="line">    Graphics.Blit(source, destination, postprocessMaterial);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算轮廓的方法是对判断定点周围进行采样，然后对比其与周围点之间的深度、法向差，差别越大，是轮廓点的概率就越大。</p>
<p>对周围点进行准确采样，首先我们需要知道纹理的大小，因为采样时使用的UV坐标，其范围是0-1，需要根据纹理大小计算单个像素的uv步长。而这个纹理大小的参数和之前提到的纹理缩放偏移参数类似，都是和纹理相关的，所以有一定的命名规则。这个规则就是纹理变量的名称加上<code>_TexelSize</code>后缀。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深度纹理图变量</span></span><br><span class="line">sampler2D _CameraDepthNormalsTexture;</span><br><span class="line"><span class="comment">//深度纹理图的尺寸，前两个是长宽的倒数，后两个是长宽</span></span><br><span class="line">float4 _CameraDepthNormalsTexture_TexelSize;</span><br></pre></td></tr></table></figure>
<p>然后我们针对当前采样点偏移几个像素，计算其周围采样点的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//偏移offset个像素点，对周围进行采样</span></span><br><span class="line">float4 neighborDepthnormal = tex2D(_CameraDepthNormalsTexture, </span><br><span class="line">        uv + _CameraDepthNormalsTexture_TexelSize.xy * offset);</span><br><span class="line">float3 neighborNormal;</span><br><span class="line"><span class="keyword">float</span> neighborDepth;</span><br><span class="line">DecodeDepthNormal(neighborDepthnormal, neighborDepth, neighborNormal);</span><br><span class="line">neighborDepth = neighborDepth * _ProjectionParams.z;</span><br></pre></td></tr></table></figure>

<p>然后我们求这两个采样点之间的差，并显示到屏幕上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> difference = depth - neightborDepth;</span><br><span class="line"><span class="keyword">return</span> difference;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/019/LeftWhite.png"></p>
<p>在上图中我们提取了图片左侧的轮廓。在处理剩下的采样点之前，我们先把采样部分的代码封装成一个函数，这样我们就不需要重复写这一段共同的代码了。这个函数需要中心点的深度值、uv、以及像素偏移值。</p>
<p>然后我们将片段着色其中的代码拷贝到我们新创建的函数中，并且把相应部分的变量调整一下。然后在片段着色器中调用这个函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Compare</span><span class="params">(<span class="keyword">float</span> baseDepth, float2 uv, float2 offset)</span></span>&#123;</span><br><span class="line">    <span class="comment">//偏移offset个像素点，对周围进行采样</span></span><br><span class="line">    float4 neighborDepthnormal = tex2D(_CameraDepthNormalsTexture, </span><br><span class="line">            uv + _CameraDepthNormalsTexture_TexelSize.xy * offset);</span><br><span class="line">    float3 neighborNormal;</span><br><span class="line">    <span class="keyword">float</span> neighborDepth;</span><br><span class="line">    DecodeDepthNormal(neighborDepthnormal, neighborDepth, neighborNormal);</span><br><span class="line">    neighborDepth = neighborDepth * _ProjectionParams.z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> baseDepth - neighborDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> depthDifference = Compare(depth, i.uv, float2(<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> depthDifference;</span><br></pre></td></tr></table></figure>

<p>修改完后运行程序，会发现效果和原来的一样，但是我们可以使用<code>Compare</code>快速的选择其他采样点。例如这里的上下左右四个方向，然后将所有结果求和。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//中心点的深度法向采样</span></span><br><span class="line">    float4 depthnormal = tex2D(_CameraDepthNormalsTexture, i.uv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//法向深度解码</span></span><br><span class="line">    float3 normal;</span><br><span class="line">    <span class="keyword">float</span> depth;</span><br><span class="line">    DecodeDepthNormal(depthnormal, depth, normal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//还原深度值</span></span><br><span class="line">    depth = depth * _ProjectionParams.z;</span><br><span class="line">    <span class="comment">//计算在上下左右四个方向的差值</span></span><br><span class="line">    <span class="keyword">float</span> depthDifference = Compare(depth, i.uv, float2(<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    depthDifference = depthDifference + Compare(depth, i.uv, float2(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    depthDifference = depthDifference + Compare(depth, i.uv, float2(<span class="number">0</span>, <span class="number">-1</span>));</span><br><span class="line">    depthDifference = depthDifference + Compare(depth, i.uv, float2(<span class="number">-1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> depthDifference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/019/DepthOutlines.png"></p>
<h2 id="Normal-Outlines"><a href="#Normal-Outlines" class="headerlink" title="Normal Outlines"></a>Normal Outlines</h2><p>使用深度图得到的轮廓已经蛮清晰了，但是我们还可以进一步使用法向数据来计算轮廓。我们同样是在<code>Compare</code>函数中实现法向采样，因为函数只能返回一个值，所以我们这里使用<code>inout</code>来返回结果。另外我们还需要向函数中传递中心点的法向，来求解其与周边的差值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Compare</span><span class="params">(inout <span class="keyword">float</span> depthOutline, inout <span class="keyword">float</span> normalOutline,  <span class="keyword">float</span> baseDepth, float3 baseNormal, float2 uv, float2 offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们的<code>Compare</code>函数已经可以处理深度和法向两种计算轮廓的数据，那么我们也需要在片段着色器中做相应的改动。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Compare</span><span class="params">(inout <span class="keyword">float</span> depthOutline, inout <span class="keyword">float</span> normalOutline, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">float</span> baseDepth, float3 baseNormal, float2 uv, float2 offset)</span></span>&#123;</span><br><span class="line">    <span class="comment">//附近点采样</span></span><br><span class="line">    float4 neighborDepthnormal = tex2D(_CameraDepthNormalsTexture, </span><br><span class="line">            uv + _CameraDepthNormalsTexture_TexelSize.xy * offset);</span><br><span class="line">    float3 neighborNormal;</span><br><span class="line">    <span class="keyword">float</span> neighborDepth;</span><br><span class="line">    DecodeDepthNormal(neighborDepthnormal, neighborDepth, neighborNormal);</span><br><span class="line">    neighborDepth = neighborDepth * _ProjectionParams.z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> depthDifference = baseDepth - neighborDepth;</span><br><span class="line">    depthOutline = depthOutline + depthDifference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> depthDifference = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span> normalDifference = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Compare(depthDifference, normalDifference, depth, normal, i.uv, float2(<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">Compare(depthDifference, normalDifference, depth, normal, i.uv, float2(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">Compare(depthDifference, normalDifference, depth, normal, i.uv, float2(<span class="number">0</span>, <span class="number">-1</span>));</span><br><span class="line">Compare(depthDifference, normalDifference, depth, normal, i.uv, float2(<span class="number">-1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> depthDifference;</span><br></pre></td></tr></table></figure>

<p>上面对代码结构进行扩展，但是并没有改变实际的功能，因此输出的结果没有什么变化。现在我们继续处理临近点法向的差，求法向的差最简单且方便的做法是计算两个法向之间的点乘。法向越接近点乘越大，完全逆向时点乘为-1。这里我们希望差异越大越接近1，差异越小越接近0，所以需要做一个数值映射。ps:不过下面的法向差并不是通过点乘来实现的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float3 normalDifference = baseNormal - neighborNormal;</span><br><span class="line">normalDifference = normalDifference.r + normalDifference.g + normalDifference.b;</span><br><span class="line">normalOutline = normalOutline + normalDifference;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> normalDifference;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/019/NormalOutlines.png"></p>
<p>上面得到的基于法向纹理的边缘检测结果和基于深度的有所不同，我们可以将两者结合得到一个更加清晰的轮廓。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> depthDifference + normalDifference;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/019/CombinedOutlines.png"></p>
<h2 id="Customizable-Outlines"><a href="#Customizable-Outlines" class="headerlink" title="Customizable Outlines"></a>Customizable Outlines</h2><p>我们基本上实现了边缘绘制的效果，但是我们还可以加一些可控参数来对最终的轮廓效果进行微调。这里我们分别针对深度、法向轮廓引入两个因子，来控制两者的强弱，还有两个偏移量，来剔除弱边缘。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//材质面板属性</span></span><br><span class="line">Properties&#123;</span><br><span class="line">    [HideInInspector]_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    _NormalMult (<span class="string">&quot;Normal Outline Multiplier&quot;</span>, Range(<span class="number">0</span>,<span class="number">4</span>)) = <span class="number">1</span></span><br><span class="line">    _NormalBias (<span class="string">&quot;Normal Outline Bias&quot;</span>, Range(<span class="number">1</span>,<span class="number">4</span>)) = <span class="number">1</span></span><br><span class="line">    _DepthMult (<span class="string">&quot;Depth Outline Multiplier&quot;</span>, Range(<span class="number">0</span>,<span class="number">4</span>)) = <span class="number">1</span></span><br><span class="line">    _DepthBias (<span class="string">&quot;Depth Outline Bias&quot;</span>, Range(<span class="number">1</span>,<span class="number">4</span>)) = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hlsl 中对应的公共变量</span></span><br><span class="line"><span class="keyword">float</span> _NormalMult;</span><br><span class="line"><span class="keyword">float</span> _NormalBias;</span><br><span class="line"><span class="keyword">float</span> _DepthMult;</span><br><span class="line"><span class="keyword">float</span> _DepthBias;</span><br></pre></td></tr></table></figure>
<p>这四个变量是在片段着色器中使用的，当计算完中心点与所有方向的临近点的差值后，将其乘以上面的因子，然后将结果限制在0-1之间，最后使用指数函数，来弱化弱边缘。最终将两种边缘求和。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">depthDifference = depthDifference * _DepthMult;</span><br><span class="line">depthDifference = saturate(depthDifference);</span><br><span class="line">depthDifference = <span class="built_in">pow</span>(depthDifference, _DepthBias);</span><br><span class="line"></span><br><span class="line">normalDifference = normalDifference * _NormalMult;</span><br><span class="line">normalDifference = saturate(normalDifference);</span><br><span class="line">normalDifference = <span class="built_in">pow</span>(normalDifference, _NormalBias);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> depthDifference + normalDifference;</span><br></pre></td></tr></table></figure>

<p>现在我们可以在材质面板上控制这些参数，从而对轮廓效果进行微调。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/019/Inspector.png"><br><img src="https://www.ronja-tutorials.com/assets/images/posts/019/TweakedOutlines.png"></p>
<p>最后我们想给轮廓上色，同时将轮廓叠加到原图上。所以我们要定义一个轮廓颜色变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_OutlineColor (<span class="string">&quot;Outline Color&quot;</span>, Color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float4 _OutlineColor;</span><br></pre></td></tr></table></figure>
<p>我们只需要在片段着色其中对原图进行采样，然后根据轮廓值，对原图和轮廓颜色进行插值，轮廓值为1的采用轮廓颜色，为0的采用原图颜色。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> outline = normalDifference + depthDifference;</span><br><span class="line">float4 sourceColor = tex2D(_MainTex, i.uv);</span><br><span class="line">float4 color = lerp(sourceColor, _OutlineColor, outline);</span><br><span class="line"><span class="keyword">return</span> color;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/019/Result.png"></p>
<p>使用后处理来实现轮廓效果有一个弊端，就是整个场景画面会无差别的执行轮廓效果。你无法指定哪些物体使用轮廓线，哪些不使用。而且容易出现锯齿等不自然的表现。</p>
<p>虽然无差别执行轮廓效果的问题不容易解决，但是锯齿类的问题可以使用<code>FXAA</code>或<code>TXAA</code>来避免。</p>
<p>另一个需要牢记的点是，后处理轮廓只适用于哪些表面较为光滑的模型。对于那些表面细节过多的模型，其表面细节轮廓被过度绘制，导致整个画面都是线条，这可能不是你想要的结果。</p>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/019_OutlinesPostprocessed&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//材质面板属性</span></span><br><span class="line">    Properties&#123;</span><br><span class="line">        [HideInInspector]_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _OutlineColor (<span class="string">&quot;Outline Color&quot;</span>, Color) = (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        _NormalMult (<span class="string">&quot;Normal Outline Multiplier&quot;</span>, Range(<span class="number">0</span>,<span class="number">4</span>)) = <span class="number">1</span></span><br><span class="line">        _NormalBias (<span class="string">&quot;Normal Outline Bias&quot;</span>, Range(<span class="number">1</span>,<span class="number">4</span>)) = <span class="number">1</span></span><br><span class="line">        _DepthMult (<span class="string">&quot;Depth Outline Multiplier&quot;</span>, Range(<span class="number">0</span>,<span class="number">4</span>)) = <span class="number">1</span></span><br><span class="line">        _DepthBias (<span class="string">&quot;Depth Outline Bias&quot;</span>, Range(<span class="number">1</span>,<span class="number">4</span>)) = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader&#123;</span><br><span class="line">        <span class="comment">// 关闭背面剔除</span></span><br><span class="line">        <span class="comment">// 禁用深度缓存</span></span><br><span class="line">        Cull Off</span><br><span class="line">        ZWrite Off </span><br><span class="line">        ZTest Always</span><br><span class="line"></span><br><span class="line">        Pass&#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="comment">//引入内置函数和变量</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//声明顶点、片段着色器</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//用于后处理的原图</span></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            <span class="comment">//深度法向纹理</span></span><br><span class="line">            sampler2D _CameraDepthNormalsTexture;</span><br><span class="line">            <span class="comment">//深度法向纹理尺寸</span></span><br><span class="line">            float4 _CameraDepthNormalsTexture_TexelSize;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//轮廓条件参数</span></span><br><span class="line">            float4 _OutlineColor;</span><br><span class="line">            <span class="keyword">float</span> _NormalMult;</span><br><span class="line">            <span class="keyword">float</span> _NormalBias;</span><br><span class="line">            <span class="keyword">float</span> _DepthMult;</span><br><span class="line">            <span class="keyword">float</span> _DepthBias;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//模型网格数据</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//中间插值数据</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">                float4 position : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//顶点着色器</span></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">//变换到裁剪坐标系</span></span><br><span class="line">                o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.uv;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">Compare</span><span class="params">(inout <span class="keyword">float</span> depthOutline, inout <span class="keyword">float</span> normalOutline, </span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">float</span> baseDepth, float3 baseNormal, float2 uv, float2 offset)</span></span>&#123;</span><br><span class="line">                <span class="comment">//临近点采样</span></span><br><span class="line">                float4 neighborDepthnormal = tex2D(_CameraDepthNormalsTexture, </span><br><span class="line">                        uv + _CameraDepthNormalsTexture_TexelSize.xy * offset);</span><br><span class="line">                float3 neighborNormal;</span><br><span class="line">                <span class="keyword">float</span> neighborDepth;</span><br><span class="line">                DecodeDepthNormal(neighborDepthnormal, neighborDepth, neighborNormal);</span><br><span class="line">                neighborDepth = neighborDepth * _ProjectionParams.z;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">float</span> depthDifference = baseDepth - neighborDepth;</span><br><span class="line">                depthOutline = depthOutline + depthDifference;</span><br><span class="line"></span><br><span class="line">                float3 normalDifference = baseNormal - neighborNormal;</span><br><span class="line">                normalDifference = normalDifference.r + normalDifference.g + normalDifference.b;</span><br><span class="line">                normalOutline = normalOutline + normalDifference;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//片段着色器</span></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">                <span class="comment">//深度法向采样</span></span><br><span class="line">                float4 depthnormal = tex2D(_CameraDepthNormalsTexture, i.uv);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//深度法向解码</span></span><br><span class="line">                float3 normal;</span><br><span class="line">                <span class="keyword">float</span> depth;</span><br><span class="line">                DecodeDepthNormal(depthnormal, depth, normal);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//还原深度值</span></span><br><span class="line">                depth = depth * _ProjectionParams.z;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">float</span> depthDifference = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">float</span> normalDifference = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                Compare(depthDifference, normalDifference, depth, normal, i.uv, float2(<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">                Compare(depthDifference, normalDifference, depth, normal, i.uv, float2(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">                Compare(depthDifference, normalDifference, depth, normal, i.uv, float2(<span class="number">0</span>, <span class="number">-1</span>));</span><br><span class="line">                Compare(depthDifference, normalDifference, depth, normal, i.uv, float2(<span class="number">-1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">                depthDifference = depthDifference * _DepthMult;</span><br><span class="line">                depthDifference = saturate(depthDifference);</span><br><span class="line">                depthDifference = <span class="built_in">pow</span>(depthDifference, _DepthBias);</span><br><span class="line"></span><br><span class="line">                normalDifference = normalDifference * _NormalMult;</span><br><span class="line">                normalDifference = saturate(normalDifference);</span><br><span class="line">                normalDifference = <span class="built_in">pow</span>(normalDifference, _NormalBias);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">float</span> outline = normalDifference + depthDifference;</span><br><span class="line">                float4 sourceColor = tex2D(_MainTex, i.uv);</span><br><span class="line">                float4 color = lerp(sourceColor, _OutlineColor, outline);</span><br><span class="line">                <span class="keyword">return</span> color;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="comment">//挂载到后处理摄像机上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OutlinesPostprocessed</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="comment">//后处理材质</span></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> Material postprocessMaterial;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Camera cam;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//设置摄像机</span></span><br><span class="line">        cam = GetComponent&lt;Camera&gt;();</span><br><span class="line">        cam.depthTextureMode = cam.depthTextureMode | DepthTextureMode.DepthNormals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//场景渲染完后，执行该函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture source, RenderTexture destination</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//执行后处理</span></span><br><span class="line">        Graphics.Blit(source, destination, postprocessMaterial);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望我的教程能够对你有所帮助。</p>
<p>你可以在以下链接找到源码：<br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/019_OutlinesPostprocessed/OutlinesPostprocessed.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/019_OutlinesPostprocessed/OutlinesPostprocessed.shader</a><br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/019_OutlinesPostprocessed/OutlinesPostprocessed.cs">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/019_OutlinesPostprocessed/OutlinesPostprocessed.cs</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/06/Ronja_Postprocessing_with_Normal_Texture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/06/Ronja_Postprocessing_with_Normal_Texture/" class="post-title-link" itemprop="url">Postprocessing with Normal Texture</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-06 15:01:00" itemprop="dateCreated datePublished" datetime="2021-07-06T15:01:00+08:00">2021-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-30 00:35:25" itemprop="dateModified" datetime="2022-08-30T00:35:25+08:00">2022-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/018-postprocessing-normal/">Postprocessing with Normal Texture</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>处理深度图外，场景的法向纹理也是后处理中可能会用到的数据，同样也是通过简单的配置摄像机就可以获得。法向纹理记录了屏幕上每个像素点所对应模型表面的法向向量。</p>
<p>法向纹理的操作和深度图类似，所以如果你对深度图还不了解，建议你先从<a href="https://tyson-wu.github.io/blogs/2021/07/06/Ronja_Postprocessing_with_the_Depth_Texture/">上一篇</a>教程看起，有助于你对本篇的理解。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/018/Result.png"></p>
<h2 id="Read-Depth-and-Normals"><a href="#Read-Depth-and-Normals" class="headerlink" title="Read Depth and Normals"></a>Read Depth and Normals</h2><p>本篇教程延续并使用<a href="https://tyson-wu.github.io/blogs/2021/07/06/Ronja_Postprocessing_with_the_Depth_Texture/">上一篇</a>教程的着色器脚本，然后在此基础上进行扩展。</p>
<p>首先我们将后处理脚本中的内容清空，在上一个教程中，这个脚本主要用来刷新波的位置。然后我们将摄像机的深度模式改为深度法向模式。这样摄像机会同时采集场景的深度和法向信息。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//将摄像机的深度模式改为深度法向模式</span></span><br><span class="line">    cam = GetComponent&lt;Camera&gt;();</span><br><span class="line">    cam.depthTextureMode = cam.depthTextureMode | DepthTextureMode.DepthNormals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置完成后，我们就可以在着色器中访问法向图了，那么接下来修改我们的着色器。</p>
<p>在着色器中，我们也将和波有关的代码删除，然后将<code>_CameraDepthTexture</code>改为<code>_CameraDepthNormalsTexture</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编辑器上显示的属性</span></span><br><span class="line">Properties&#123;</span><br><span class="line">    [HideInInspector]_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深度法向纹理</span></span><br><span class="line">sampler2D _CameraDepthNormalsTexture;</span><br></pre></td></tr></table></figure>

<p>设置好这些后，我们可以在片段着色器中使用我们的深度法向图。如果将其显示在屏幕上，你会发现有趣的现象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//深度法向纹理采样</span></span><br><span class="line">    float4 depthnormal = tex2D(_CameraDepthNormalsTexture, i.uv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> depthnormal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/018/EncodedNormals.png"></p>
<p>但是上面的画面并不是真正的法向纹理，我们只看到近处的红绿颜色，和远处的蓝色。这是因为<code>_CameraDepthNormalsTexture</code>是中存储的深度和法向数据是经过编码的，所以使用之前需要对其解码。Unity也为我们提供了相应的解码函数。该解码函数有三个参数，第一个参数是采样值，后两个参数分别是解码后的深度、和法向。</p>
<p>和之前的深度图不同的是，这里解码后的深度值已经是线性的了，所以我们可以直接还原深度值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//深度法向采样</span></span><br><span class="line">    float4 depthnormal = tex2D(_CameraDepthNormalsTexture, i.uv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//深度法向解码</span></span><br><span class="line">    float3 normal;</span><br><span class="line">    <span class="keyword">float</span> depth;</span><br><span class="line">    DecodeDepthNormal(depthnormal, depth, normal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//深度值还原</span></span><br><span class="line">    depth = depth * _ProjectionParams.z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/018/Depth.png"></p>
<p>继续回到我们的主题法向纹理，我们可以将其显示到屏幕上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//深度法向采样</span></span><br><span class="line">    float4 depthnormal = tex2D(_CameraDepthNormalsTexture, i.uv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//深度法向解码</span></span><br><span class="line">    float3 normal;</span><br><span class="line">    <span class="keyword">float</span> depth;</span><br><span class="line">    DecodeDepthNormal(depthnormal, depth, normal);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//还原深度值</span></span><br><span class="line">    depth = depth * _ProjectionParams.z;</span><br><span class="line">    <span class="comment">//显示法向</span></span><br><span class="line">    <span class="keyword">return</span> float4(normal, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/018/DecodedNormals.gif"></p>
<p>但是当我们转动摄像机时，你会发现模型表面的法向一直在变，这是因为我们的法向纹理是基于摄像机空间生成的。所以如果我们需要额外的一步来将其转换到世界坐标系。从摄像机坐标系转换到世界坐标系很简单，但是Unity并没有提供相应的函数。因此我们需要实现，并且将转换矩阵传递给着色器。</p>
<p>回到后处理脚本中，我们获取到用于后处理的摄像机组件，并把它存储为脚本的成员属性，然后在<code>OnRenderImage</code>函数中，将变换矩阵传递给着色器，这样在我们转动摄像机的时候，都能及时刷新着色器中的变换矩阵。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">//挂载到后处理摄像机上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NormalPostprocessing</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">	<span class="comment">//后处理材质球</span></span><br><span class="line">	[<span class="meta">SerializeField</span>]</span><br><span class="line">	<span class="keyword">private</span> Material postprocessMaterial;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Camera cam;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="comment">//设置摄像机</span></span><br><span class="line">		cam = GetComponent&lt;Camera&gt;();</span><br><span class="line">		cam.depthTextureMode = cam.depthTextureMode | DepthTextureMode.DepthNormals;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//场景渲染完后会调用该函数</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture source, RenderTexture destination</span>)</span>&#123;</span><br><span class="line">		<span class="comment">//观察坐标系到世界坐标系的变换矩阵</span></span><br><span class="line">		Matrix4x4 viewToWorld = cam.cameraToWorldMatrix;</span><br><span class="line">		postprocessMaterial.SetMatrix(<span class="string">&quot;_viewToWorld&quot;</span>, viewToWorld);</span><br><span class="line">		<span class="comment">//执行后处理</span></span><br><span class="line">		Graphics.Blit(source, destination, postprocessMaterial);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在着色器中使用观察坐标系到世界坐标系的变换矩阵，将法向量转换到世界坐标系。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//着色器中的变换矩阵</span></span><br><span class="line">float4x4 _viewToWorld;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将法向量转换到世界坐标系</span></span><br><span class="line">normal = normal = mul((float3x3)_viewToWorld, normal);</span><br><span class="line"><span class="keyword">return</span> float4(normal, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/018/WorldspaceNormals.gif"></p>
<h2 id="Color-the-Top"><a href="#Color-the-Top" class="headerlink" title="Color the Top"></a>Color the Top</h2><p>知道了世界坐标系下的法向量，我们可以实现一些简单的效果，使得模型看起来有层次感。这里我们给模型顶部上色，也就是法向朝上的区域。</p>
<p>因此，我们将法向量和向上的向量相比较。通过两者的点乘，可以知道两个向量之间的关系，为1使同向，为0时垂直，为-1时反向。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> up = dot(float3(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>), normal);</span><br><span class="line"><span class="keyword">return</span> up;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/018/Topness.png"></p>
<p>上面的图可能还不是很明显，为了凸出向上的区域，我们可以使用<code>step</code>将表面区域绝对划分为向上和非向上。下面我们将这个划分阈值设置为0.5，阈值越大被认定的顶部区域越小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> up = dot(float3(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>), normal);</span><br><span class="line">up = step(<span class="number">0.5</span>, up);</span><br><span class="line"><span class="keyword">return</span> up;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/018/TopCutoff.png"></p>
<p>接下来我们将原图和我们生成的顶部图融合，其中非顶部区域采用原图颜色，顶部区域采用白色。前面我们讲过很多次了，这种效果可以使用插值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> up = dot(float3(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>), normal);</span><br><span class="line">up = step(<span class="number">0.5</span>, up);</span><br><span class="line">float4 source = tex2D(_MainTex, i.uv);</span><br><span class="line">float4 col = lerp(source, float4(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>), up);</span><br><span class="line"><span class="keyword">return</span> col;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/018/WhiteTop.png"></p>
<p>最后，我们可以将其中的阈值、和顶部颜色放到材质面板上，这样我们可以更灵活的控制我们的后处理效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_upCutoff (<span class="string">&quot;up cutoff&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.7</span></span><br><span class="line">_topColor (<span class="string">&quot;top color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阈值和顶部颜色</span></span><br><span class="line"><span class="keyword">float</span> _upCutoff;</span><br><span class="line">float4 _topColor;</span><br></pre></td></tr></table></figure>

<p>然后我们将片段着色器中的阈值和顶部颜色固定值改为上面定义的变量，同时我们还可以将顶部颜色的透明通道应用上。通过调节其透明通道，可以实现顶部颜色和原图的混合效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">float</span> up = dot(float3(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>), normal);</span><br><span class="line">up = step(_upCutoff, up);</span><br><span class="line">float4 source = tex2D(_MainTex, i.uv);</span><br><span class="line">float4 col = lerp(source, _topColor, up * _topColor.a);</span><br><span class="line"><span class="keyword">return</span> col;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/018/Result.png"></p>
<p>以上展示了深度法向纹理的使用方法。当然如果你想实现雪覆盖在模型上的效果，你可以直接在模型着色器上实现，而不是通过后处理的方式。</p>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">//挂载到后处理摄像机上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NormalPostprocessing</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="comment">//后处理材质球</span></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> Material postprocessMaterial;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Camera cam;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//设置后摄像机</span></span><br><span class="line">        cam = GetComponent&lt;Camera&gt;();</span><br><span class="line">        cam.depthTextureMode = cam.depthTextureMode | DepthTextureMode.DepthNormals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当场景渲染完后，会执行该函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture source, RenderTexture destination</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//观察坐标系到世界坐标系的变换矩阵</span></span><br><span class="line">        Matrix4x4 viewToWorld = cam.cameraToWorldMatrix;</span><br><span class="line">        postprocessMaterial.SetMatrix(<span class="string">&quot;_viewToWorld&quot;</span>, viewToWorld);</span><br><span class="line">        <span class="comment">//执行后处理</span></span><br><span class="line">        Graphics.Blit(source, destination, postprocessMaterial);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/018_Normal_Postprocessing&quot;</span>&#123;</span><br><span class="line">    <span class="comment">//材质面板</span></span><br><span class="line">    Properties&#123;</span><br><span class="line">        [HideInInspector]_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        _upCutoff (<span class="string">&quot;up cutoff&quot;</span>, Range(<span class="number">0</span>,<span class="number">1</span>)) = <span class="number">0.7</span></span><br><span class="line">        _topColor (<span class="string">&quot;top color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader&#123;</span><br><span class="line">        <span class="comment">// 关闭剔除</span></span><br><span class="line">        <span class="comment">// 禁用深度缓存</span></span><br><span class="line">        Cull Off</span><br><span class="line">        ZWrite Off </span><br><span class="line">        ZTest Always</span><br><span class="line"></span><br><span class="line">        Pass&#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="comment">//引入内置函数和变量</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//声明顶点和片段着色器</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//用于后处理的原图</span></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            <span class="comment">//观察坐标系到世界坐标系的变换矩阵</span></span><br><span class="line">            float4x4 _viewToWorld;</span><br><span class="line">            <span class="comment">//深度法向纹理</span></span><br><span class="line">            sampler2D _CameraDepthNormalsTexture;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//自定义的可调节参数</span></span><br><span class="line">            <span class="keyword">float</span> _upCutoff;</span><br><span class="line">            float4 _topColor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//模型网格数据</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//中间插值数据</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">                float4 position : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//顶点着色器</span></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">//变换到裁剪坐标系</span></span><br><span class="line">                o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.uv;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//片段着色器</span></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">                <span class="comment">//深度法向纹理采样</span></span><br><span class="line">                float4 depthnormal = tex2D(_CameraDepthNormalsTexture, i.uv);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//深度法向量解码</span></span><br><span class="line">                float3 normal;</span><br><span class="line">                <span class="keyword">float</span> depth;</span><br><span class="line">                DecodeDepthNormal(depthnormal, depth, normal);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//还原深度值</span></span><br><span class="line">                depth = depth * _ProjectionParams.z;</span><br><span class="line"></span><br><span class="line">                normal = mul((float3x3)_viewToWorld, normal);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">float</span> up = dot(float3(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>), normal);</span><br><span class="line">                up = step(_upCutoff, up);</span><br><span class="line">                float4 source = tex2D(_MainTex, i.uv);</span><br><span class="line">                float4 col = lerp(source, _topColor, up * _topColor.a);</span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望我的教程能够对你有所帮助。</p>
<p>你可以在以下链接找到源码：<br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/018_NormalPostprocessing/NormalPostprocessing.cs">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/018_NormalPostprocessing/NormalPostprocessing.cs</a><br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/018_NormalPostprocessing/NormalPostprocessing.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/018_NormalPostprocessing/NormalPostprocessing.shader</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/06/Ronja_Postprocessing_with_the_Depth_Texture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/06/Ronja_Postprocessing_with_the_Depth_Texture/" class="post-title-link" itemprop="url">Postprocessing with the Depth Texture</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-06 15:01:00" itemprop="dateCreated datePublished" datetime="2021-07-06T15:01:00+08:00">2021-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-30 00:35:25" itemprop="dateModified" datetime="2022-08-30T00:35:25+08:00">2022-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/017-postprocessing-depth/">Postprocessing with the Depth Texture</a></p>
<p>在上一篇教程中，我介绍了简单后处理效果的实现过程。但是在实际应用中，我们经常需要使用深度图来实现一些更高级的后处理效果。深度图是从摄像机视角采集的记录场景深度信息的纹理图。</p>
<p>在理解如何借助深度图来实现复杂的后处理之前，建议你先阅读<a href="https://tyson-wu.github.io/blogs/2021/07/06/Ronja_Postprocessing_Basics/">上一篇</a>关于简单后处理效果的介绍。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/017/Result.gif"></p>
<h2 id="Read-Depth"><a href="#Read-Depth" class="headerlink" title="Read Depth"></a>Read Depth</h2><p>这里我们沿用<a href="https://tyson-wu.github.io/blogs/2021/07/06/Ronja_Postprocessing_Basics/">上一篇</a>中实现的最简单的后处理脚本，然后在此基础上进行修改。</p>
<p>首先我们需要对后处理脚本进行扩展，保证后处理摄像机生成深度图，供这里的后处理使用。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    Camera cam = GetComponent&lt;Camera&gt;();</span><br><span class="line">    cam.depthTextureMode = cam.depthTextureMode | DepthTextureMode.Depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面对后处理脚本修改完成后，接下来我们要对后处理着色器进行修改。</p>
<p>为了在着色器中访问深度图，我们首先需要定义一个名叫<code>_CameraDepthTexture</code>的纹理，这个名字是Unity内置的。深度图的采样和其他纹理一样，我们可以将采样结果渲染到屏幕上，看看深度图到底长啥样。因为深度图只有一个值有效，所以在纹理中深度值是存储在R通道，我们可以直接进行访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深度图</span></span><br><span class="line">sampler2D _CameraDepthTexture;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//深度采样</span></span><br><span class="line">    <span class="keyword">float</span> depth = tex2D(_CameraDepthTexture, i.uv).r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一切都准备好后，启动游戏，不过这时候屏幕上显示的很可能是一片黑。这是因为深度值得存储位数有限，为了扩大深度值得记录范围，同时保证近景的深度精度，所以采用非线性编码，其中距离摄像机越近的区域深度值得精度越高，反之越低。当你将摄像机靠近物体时，你可能观察到更亮的颜色，这表明这个区域理摄像机很近。如果你将摄像机不断靠近，画面依然很黑，这时候你可以尝试将摄像机的近平面调大一点。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/017/Short.png"></p>
<p>前面的深度编码是考虑到存储的限制，而我们使用深度值之前必须对其进行解码。庆幸的是，Unity为我们提供了解码函数，解码后的深度值是线性的，范围在0-1之间，0表示在摄像机位置，1表示在远平面上。如果解码后的深度图显示除了天空盒区域是白色，其他地方基本是黑色，你可以将远平面调小，这样可以观察到更多的模型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//深度采样</span></span><br><span class="line">    <span class="keyword">float</span> depth = tex2D(_CameraDepthTexture, i.uv).r;</span><br><span class="line">    <span class="comment">//深度解码，解码后的深度值是线性的，范围0-1， 0为摄像机位置，1为远平面上</span></span><br><span class="line">    depth = Linear01Depth(depth);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/017/LinearDepth.png"></p>
<p>接下来的一步是基于摄像机参数，还原真实的深度值。这里有个<code>_ProjectionParams</code>是记录摄像机的投影参数，其中z值是远平面的大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//深度采样</span></span><br><span class="line">    <span class="keyword">float</span> depth = tex2D(_CameraDepthTexture, i.uv).r;</span><br><span class="line">    <span class="comment">//深度值解码</span></span><br><span class="line">    depth = Linear01Depth(depth);</span><br><span class="line">    <span class="comment">//还原深度值，得到点到摄像机的真实距离</span></span><br><span class="line">    depth = depth * _ProjectionParams.z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/017/CorrectDepth.png"></p>
<p>因为场景中绝大多数的模型到摄像机的距离都大于一个单位，所以还原后的深度图显示在屏幕上将会是纯白色，但是这个深度值是与远平面无关的真实深度值，是点到摄像机的距离。</p>
<h2 id="Generate-Wave"><a href="#Generate-Wave" class="headerlink" title="Generate Wave"></a>Generate Wave</h2><p>加下来我将基于这些信息来实现一种波效果，一种不断从玩家开始，向远处传播的效果。同时我们可以自定义某个时刻波距玩家的距离、以及波的拖尾长度、波的颜色。所以首先我们需要在着色器脚本中添加这些变量。这里我们使用<code>Header</code>属性标签来加粗标题，当然这只具有显示功能，不会影响着色器的实际使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在编辑器上显示的属性</span></span><br><span class="line">Properties&#123;</span><br><span class="line">    [HideInInspector]_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    [Header(Wave)]</span><br><span class="line">    _WaveDistance (<span class="string">&quot;Distance from player&quot;</span>, <span class="keyword">float</span>) = <span class="number">10</span></span><br><span class="line">    _WaveTrail (<span class="string">&quot;Length of the trail&quot;</span>, Range(<span class="number">0</span>,<span class="number">5</span>)) = <span class="number">1</span></span><br><span class="line">    _WaveColor (<span class="string">&quot;Color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HLSL 内定义的变量</span></span><br><span class="line"><span class="keyword">float</span> _WaveDistance;</span><br><span class="line"><span class="keyword">float</span> _WaveTrail;</span><br><span class="line">float4 _WaveColor;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/017/Inspector.png"></p>
<p>我们这个波的一头是突然截断、另一头是渐变的拖尾效果。我们首先实现这个突然截断的头部效果。在前面的教程中谈到过<code>step</code>这个函数可以实现跳变的效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//计算波的头部</span></span><br><span class="line"><span class="keyword">float</span> waveFront = step(depth, _WaveDistance);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> waveFront;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/017/Cutoff.gif"></p>
<p>然后我们再使用<code>smoothstep</code>函数来实现尾部渐变效果，这个函数和<code>step</code>函数类似，只不过它有三个参数。如果第三个参数小于第一个参，那么返回0，如果大于第二个参数，那么返回1，其他情况返回一个0-1的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> waveTrail = smoothstep(_WaveDistance - _WaveTrail, _WaveDistance, depth);</span><br><span class="line"><span class="keyword">return</span> waveTrail;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/017/Trail.gif"></p>
<p>你可能注意到上面两个波效果刚好相反，这正是我们想要的效果。因为我们将这两个波值相乘后，只有中间很窄的区域会为1，其他位置都将是0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算前后波</span></span><br><span class="line"><span class="keyword">float</span> waveFront = step(depth, _WaveDistance);</span><br><span class="line"><span class="keyword">float</span> waveTrail = smoothstep(_WaveDistance - _WaveTrail, _WaveDistance, depth);</span><br><span class="line"><span class="keyword">float</span> wave = waveFront * waveTrail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wave;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/017/WhiteWave.gif"></p>
<p>现在我们得到了想要的波，打算将其应用到最终的显示画面上。首先需要采集原始画面，然后和我们的波进行线性插值，插值的时候可以把我们的波颜色也应用上。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和原图混合</span></span><br><span class="line">fixed4 col = lerp(source, _WaveColor, wave);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> col;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/017/HitSky.gif"></p>
<p>上面的效果可以发现一些瑕疵，就是当波移动到远平面时，会突然高亮。虽然我们的天空盒就是在远平面处，但是我还是不想出现这种瑕疵。</p>
<p>要解决这个问题，我通过判断深度值是否达到远平面，如果达到，那么直接返回原始图。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//深度采样</span></span><br><span class="line">    <span class="keyword">float</span> depth = tex2D(_CameraDepthTexture, i.uv).r;</span><br><span class="line">    <span class="comment">//深度解码</span></span><br><span class="line">    depth = Linear01Depth(depth);</span><br><span class="line">    <span class="comment">//还原深度值</span></span><br><span class="line">    depth = depth * _ProjectionParams.z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原图采样</span></span><br><span class="line">    fixed4 source = tex2D(_MainTex, i.uv);</span><br><span class="line">    <span class="comment">//当达到远平面时，直接返回原图</span></span><br><span class="line">    <span class="keyword">if</span>(depth &gt;= _ProjectionParams.z)</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算波</span></span><br><span class="line">    <span class="keyword">float</span> waveFront = step(depth, _WaveDistance);</span><br><span class="line">    <span class="keyword">float</span> waveTrail = smoothstep(_WaveDistance - _WaveTrail, _WaveDistance, depth);</span><br><span class="line">    <span class="keyword">float</span> wave = waveFront * waveTrail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//波和原图混合</span></span><br><span class="line">    fixed4 col = lerp(source, _WaveColor, wave);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我想扩展后处理脚本来实现自动设置波位置，并且让它缓慢远离摄像机。我想控制波速以及是否启用波后处理效果。所以我必须记住当前波的位置。下面是我添加的新变量。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="keyword">private</span> Material postprocessMaterial;</span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> waveSpeed;</span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">bool</span> waveActive;</span><br></pre></td></tr></table></figure>

<p>然后我在后处理脚本中的<code>Update</code>函数中不断刷新波的位置。关闭波效将会重置波的位置，开启波效，波都会冲初始位置开始，慢慢的原理摄像机。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//启用时会不断移动波，关闭时会重置波的位置</span></span><br><span class="line">    <span class="keyword">if</span>(waveActive)&#123;</span><br><span class="line">        waveDistance = waveDistance + waveSpeed * Time.deltaTime;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        waveDistance = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我在<code>OnRenderImage</code>函数中的后处理操作执行之前，将波距离参数传递给着色器，保证每次渲染都是在正确的位置。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/017/AutoWave.gif"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/017_Depth_Postprocessing&quot;</span>&#123;</span><br><span class="line">    <span class="comment">//显示在编辑器上</span></span><br><span class="line">    Properties&#123;</span><br><span class="line">        [HideInInspector]_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">        [Header(Wave)]</span><br><span class="line">        _WaveDistance (<span class="string">&quot;Distance from player&quot;</span>, <span class="keyword">float</span>) = <span class="number">10</span></span><br><span class="line">        _WaveTrail (<span class="string">&quot;Length of the trail&quot;</span>, Range(<span class="number">0</span>,<span class="number">5</span>)) = <span class="number">1</span></span><br><span class="line">        _WaveColor (<span class="string">&quot;Color&quot;</span>, Color) = (<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader&#123;</span><br><span class="line">        <span class="comment">// 关闭剔除</span></span><br><span class="line">        <span class="comment">// 禁用深度缓存功能</span></span><br><span class="line">        Cull Off</span><br><span class="line">        ZWrite Off</span><br><span class="line">        ZTest Always</span><br><span class="line"></span><br><span class="line">        Pass&#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="comment">//引入内置函数和变量</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//声明顶点、片段着色器</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//用于后处理的原图</span></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//深度图</span></span><br><span class="line">            sampler2D _CameraDepthTexture;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//波参数</span></span><br><span class="line">            <span class="keyword">float</span> _WaveDistance;</span><br><span class="line">            <span class="keyword">float</span> _WaveTrail;</span><br><span class="line">            float4 _WaveColor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//模型网格数据</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//中间插值数据</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">                float4 position : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//顶点着色器</span></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">//计算裁剪坐标</span></span><br><span class="line">                o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.uv;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//片段着色器，后处理操作主要是在这里执行</span></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">                <span class="comment">//深度采样</span></span><br><span class="line">                <span class="keyword">float</span> depth = tex2D(_CameraDepthTexture, i.uv).r;</span><br><span class="line">                <span class="comment">//深度解码</span></span><br><span class="line">                depth = Linear01Depth(depth);</span><br><span class="line">                <span class="comment">//深度还原</span></span><br><span class="line">                depth = depth * _ProjectionParams.z;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//原图采样</span></span><br><span class="line">                fixed4 source = tex2D(_MainTex, i.uv);</span><br><span class="line">                <span class="comment">//当达到远平面时，直接返回原图</span></span><br><span class="line">                <span class="keyword">if</span>(depth &gt;= _ProjectionParams.z)</span><br><span class="line">                    <span class="keyword">return</span> source;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//计算波</span></span><br><span class="line">                <span class="keyword">float</span> waveFront = step(depth, _WaveDistance);</span><br><span class="line">                <span class="keyword">float</span> waveTrail = smoothstep(_WaveDistance - _WaveTrail, _WaveDistance, depth);</span><br><span class="line">                <span class="keyword">float</span> wave = waveFront * waveTrail;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//原图与波混合</span></span><br><span class="line">                fixed4 col = lerp(source, _WaveColor, wave);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该脚本需要和摄像机绑定在同一物体</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DepthPostprocessing</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="comment">//用于后处理的材质</span></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> Material postprocessMaterial;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> waveSpeed;</span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> waveActive;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> waveDistance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//设置当前摄像机为深度采集模式</span></span><br><span class="line">        Camera cam = GetComponent&lt;Camera&gt;();</span><br><span class="line">        cam.depthTextureMode = cam.depthTextureMode | DepthTextureMode.Depth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//启用时会不断移动波，关闭时会重置波的位置</span></span><br><span class="line">        <span class="keyword">if</span>(waveActive)&#123;</span><br><span class="line">            waveDistance = waveDistance + waveSpeed * Time.deltaTime;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            waveDistance = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当当前绑定的摄像机渲染完一帧画面后，会调用该函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture source, RenderTexture destination</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//同步当前波距到着色器</span></span><br><span class="line">        postprocessMaterial.SetFloat(<span class="string">&quot;_WaveDistance&quot;</span>, waveDistance);</span><br><span class="line">		<span class="comment">//将原图按照材质着色器脚本逻辑，写入到结果图</span></span><br><span class="line">        Graphics.Blit(source, destination, postprocessMaterial);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望我的教程能够对你有所帮助。</p>
<p>你可以在以下链接找到源码：<br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/017_DepthPostprocessing/DepthPostprocessing.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/017_DepthPostprocessing/DepthPostprocessing.shader</a><br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/017_DepthPostprocessing/DepthPostprocessing.cs">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/017_DepthPostprocessing/DepthPostprocessing.cs</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://tyson-wu.github.io/blogs/2021/07/06/Ronja_Postprocessing_Basics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blogs/images/avatar.png">
      <meta itemprop="name" content="Tyson Wu">
      <meta itemprop="description" content="If you want, Just do it!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="TysonWu's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blogs/2021/07/06/Ronja_Postprocessing_Basics/" class="post-title-link" itemprop="url">Postprocessing Basics</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-06 14:01:00" itemprop="dateCreated datePublished" datetime="2021-07-06T14:01:00+08:00">2021-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-30 00:35:25" itemprop="dateModified" datetime="2022-08-30T00:35:25+08:00">2022-08-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/" itemprop="url" rel="index"><span itemprop="name">Unity</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blogs/categories/Unity/Shader/" itemprop="url" rel="index"><span itemprop="name">Shader</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文：<br><a target="_blank" rel="noopener" href="https://www.ronja-tutorials.com/post/016-postprocessing-basics/">Postprocessing Basics</a></p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>目前为止，我将所有我实现的着色器应用到了模型上，并将其渲染到屏幕上。着色器还有一个常用的用途就是处理图片、以及我们刚渲染好的上一帧画面。我们对前面渲染好的画面进行处理的操作就叫做后处理。</p>
<p>后处理所使用的着色器在语法和结构上和之间介绍的着色器一样。所以我建议你先了解前面关于着色器的<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Basic_Shader/">基础教程</a>。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/016/Result.jpg"></p>
<h2 id="Postprocessing-Shader"><a href="#Postprocessing-Shader" class="headerlink" title="Postprocessing Shader"></a>Postprocessing Shader</h2><p>作为后处理的入门教程，这里我将展示如何实现简单的颜色取反效果。</p>
<p>因为整个脚本和其他着色器类似，所以我将直接使用<a href="https://tyson-wu.github.io/blogs/2021/07/01/Ronja_Basic_Shader/">着色器基础</a>教程中的着色器脚本，并在此基础上进行修改。</p>
<p>当然，即便是最基础的着色器也有一些后处理用不到的变量，我们可以将它删除。例如这里的材质颜色、渲染标签<code>Tags</code>、纹理参数。</p>
<p>然后我们还需要添加一些东西，使得我们的着色器更适用于后处理。例如在后处理中所有的属性变量都是通过脚本赋值的，所以在属性块中可以加入属性隐藏标签，另外后处理操作不应该对影响场景深度图，所以应该禁用深度写入等功能。</p>
<p>基于上述修改，最终的着色器如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/016_Postprocessing&quot;</span>&#123;</span><br><span class="line">    <span class="comment">//材质面板，这里所有属性都将隐藏</span></span><br><span class="line">    Properties&#123;</span><br><span class="line">        [HideInInspector]_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader&#123;</span><br><span class="line">        <span class="comment">// 不需要背面剔除</span></span><br><span class="line">        <span class="comment">// 禁用深度缓存</span></span><br><span class="line">        Cull Off</span><br><span class="line">        ZWrite Off</span><br><span class="line">        ZTest Always</span><br><span class="line"></span><br><span class="line">        Pass&#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="comment">//引入内置函数和变量</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//声明顶点、片段着色器</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//将要进行后处理的图片</span></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//模型纹理数据，后处理会自动生成一个矩阵网格</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//中间插值数据</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">                float4 position : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//顶点着色器</span></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">//变换到裁剪空间，后处理的渲染过程和普通着色器类似</span></span><br><span class="line">                o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.uv;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//片段着色器，后处理主要是在这里执行</span></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">                <span class="comment">//原图片采样</span></span><br><span class="line">                fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Postprocessing-C-Script"><a href="#Postprocessing-C-Script" class="headerlink" title="Postprocessing C# Script"></a>Postprocessing C# Script</h2><p>上面我们已经准备好了用于后处理的着色器，接下来我们要实现C#脚本，来控制后处理过程。摄像机在执行后处理的时候会用到这个脚本。</p>
<p>新建的脚本是一个脚本组件，只有一个函数<code>OnRenderImage</code>。这个函数有Unity在特定时间调用的。其中传递两个参数，一是后处理原图，一是后处理结果图。将一张图中的数据复制到另一张图，可以使用<code>Blit</code>函数。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该脚本需要和摄像机绑定在同一物体</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Postprocessing</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当当前绑定的摄像机渲染完一帧画面后，会调用该函数</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture source, RenderTexture destination</span>)</span>&#123;</span><br><span class="line">		<span class="comment">//将原图写入到结果图</span></span><br><span class="line">		Graphics.Blit(source, destination);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到目前为止，整个后处理逻辑并不会产生什么特别的效果，因为从原图到结果图没有执行任何操作。我们可以再传第三个材质参数，那么在结果图写入前会执行该材质中的着色器脚本。所以这里我们给这个后处理脚本增加一个材质属性。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该脚本需要和摄像机绑定在同一物体</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Postprocessing</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="comment">//用于后处理的材质</span></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> Material postprocessMaterial;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当当前绑定的摄像机渲染完一帧画面后，会调用该函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture source, RenderTexture destination</span>)</span>&#123;</span><br><span class="line">		<span class="comment">//将原图按照材质着色器脚本逻辑，写入到结果图</span></span><br><span class="line">        Graphics.Blit(source, destination, postprocessMaterial);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前面准备好后，我们创建需要的材质球，然后将该材质球和我们的后处理着色器绑定。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/016/EmptyMaterial.png"></p>
<p>然后将我们的后处理脚本绑定到我们的摄像机物体上，并且将前面的材质球赋值给这个后处理组件。<br><img src="https://www.ronja-tutorials.com/assets/images/posts/016/PostprocessingComponent.png"></p>
<h2 id="Negative-Colors-Effect"><a href="#Negative-Colors-Effect" class="headerlink" title="Negative Colors Effect"></a>Negative Colors Effect</h2><p>做好这一切后，运行程序发现好像没啥特别的变化。要实现颜色取反的效果，我们还需要重新回到我们的后处理着色器中，在片段着色器函数中执行颜色取反的操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//片段着色器</span></span><br><span class="line"><span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">    <span class="comment">//原图采样</span></span><br><span class="line">    fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">    <span class="comment">//颜色取反</span></span><br><span class="line">    col = <span class="number">1</span> - col;</span><br><span class="line">    <span class="keyword">return</span> col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://www.ronja-tutorials.com/assets/images/posts/016/Result.jpg"></p>
<p>虽然颜色取反并不是我们常用的效果，但是它揭示了后处理的一般流程，为我们打开一个全新的后处理世界。在后面我会陆陆续续介绍其他常用的后处理效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Tutorial/016_Postprocessing&quot;</span>&#123;</span><br><span class="line">    <span class="comment">//材质面板，这里所有属性都将隐藏</span></span><br><span class="line">    Properties&#123;</span><br><span class="line">        [HideInInspector]_MainTex (<span class="string">&quot;Texture&quot;</span>, <span class="number">2</span>D) = <span class="string">&quot;white&quot;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SubShader&#123;</span><br><span class="line">        <span class="comment">// 不需要背面剔除</span></span><br><span class="line">        <span class="comment">// 禁用深度缓存</span></span><br><span class="line">        Cull Off</span><br><span class="line">        ZWrite Off</span><br><span class="line">        ZTest Always</span><br><span class="line"></span><br><span class="line">        Pass&#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            <span class="comment">//引入内置函数和变量</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;UnityCG.cginc&quot;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//声明顶点、片段着色器</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//将要进行后处理的图片</span></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//模型纹理数据，后处理会自动生成一个矩阵网格</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">appdata</span>&#123;</span></span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//中间插值数据</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">v2f</span>&#123;</span></span><br><span class="line">                float4 position : SV_POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//顶点着色器</span></span><br><span class="line">            <span class="function">v2f <span class="title">vert</span><span class="params">(appdata v)</span></span>&#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                <span class="comment">//变换到裁剪空间，后处理的渲染过程和普通着色器类似</span></span><br><span class="line">                o.position = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = v.uv;</span><br><span class="line">                <span class="keyword">return</span> o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//片段着色器，后处理主要是在这里执行</span></span><br><span class="line">            <span class="function">fixed4 <span class="title">frag</span><span class="params">(v2f i)</span> : SV_TARGET</span>&#123;</span><br><span class="line">                <span class="comment">//原图片采样</span></span><br><span class="line">                fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">                <span class="comment">//颜色取反</span></span><br><span class="line">                col = <span class="number">1</span> - col;</span><br><span class="line">                <span class="keyword">return</span> col;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该脚本需要和摄像机绑定在同一物体</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Postprocessing</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line">    <span class="comment">//用于后处理的材质</span></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    <span class="keyword">private</span> Material postprocessMaterial;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当当前绑定的摄像机渲染完一帧画面后，会调用该函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnRenderImage</span>(<span class="params">RenderTexture source, RenderTexture destination</span>)</span>&#123;</span><br><span class="line">		<span class="comment">//将原图按照材质着色器脚本逻辑，写入到结果图</span></span><br><span class="line">        Graphics.Blit(source, destination, postprocessMaterial);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>希望本篇教程能够让你了解如何使用简单的后处理效果、能够独立实现一些后处理效果。</p>
<p>你可以在以下链接找到源码：<br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/016_Postprocessing/Postprocessing.shader">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/016_Postprocessing/Postprocessing.shader</a><br><a target="_blank" rel="noopener" href="https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/016_Postprocessing/Postprocessing.cs">https://github.com/ronja-tutorials/ShaderTutorials/blob/master/Assets/016_Postprocessing/Postprocessing.cs</a></p>
<p>希望你能喜欢这个教程哦！如果你想支持我，可以关注我的<a target="_blank" rel="noopener" href="https://twitter.com/totallyRonja">推特</a>,或者通过<a target="_blank" rel="noopener" href="https://ko-fi.com/ronjatutorials">ko-fi</a>、或<a target="_blank" rel="noopener" href="https://www.patreon.com/RonjaTutorials">patreon</a>给两小钱。总之，各位大爷，走过路过不要错过，有钱的捧个钱场，没钱的捧个人场:-)!!!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blogs/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/blogs/">1</a><a class="page-number" href="/blogs/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/blogs/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/blogs/page/6/">6</a><a class="extend next" rel="next" href="/blogs/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Tyson Wu"
      src="/blogs/images/avatar.png">
  <p class="site-author-name" itemprop="name">Tyson Wu</p>
  <div class="site-description" itemprop="description">If you want, Just do it!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blogs/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blogs/categories/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blogs/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Tyson-Wu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Tyson-Wu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/zhao-wu-zhu-43" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;zhao-wu-zhu-43" rel="noopener" target="_blank"><i class="知乎 fa-fw"></i>知乎</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/Hi-blog/" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;Hi-blog&#x2F;" rel="noopener" target="_blank">starnight_cyber</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tyson Wu</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blogs/lib/anime.min.js"></script>
  <script src="/blogs/lib/velocity/velocity.min.js"></script>
  <script src="/blogs/lib/velocity/velocity.ui.min.js"></script>

<script src="/blogs/js/utils.js"></script>

<script src="/blogs/js/motion.js"></script>


<script src="/blogs/js/schemes/pisces.js"></script>


<script src="/blogs/js/next-boot.js"></script>




  















  

  

</body>
</html>
