---
title: OpenGL Rendering Pipeline
date: 2020-12-20 15:01:00
categories:
- [OpenGL, Render Pipeline]
tags:
- OpenGL
- Render Pipeline
---

OpengGL 渲染管线包含一连串的、有序的处理过程；主要处理两类几何信息：顶点数据和片段数据；最终将处理结果存储到帧缓存中。另外，OpenGL 可以将处理后的数据传递给CPU--也就是我们的应用程序，下图中的灰色线条表示的就是从GPU到CPU的数据传输：
![](http://www.songho.ca/opengl/files/gl_pipeline.gif)
OpenGL Pipeline

## Display List

Display list 中存储的是一组OpenGL渲染命令，这些命令是已经编译好的、以供后续渲染操作。当然与渲染相关的所有数据，包括顶点、片段数据都可以存储在Display list中。如果将命令和数据都存储在一起，可能会提高渲染效率。特别是，如果OpenGL渲染程序是在服务端执行，那么使用Display list可以有效减少网络传输次数。因为Display list是服务端的渲染参数，并且由服务器进行执行，因此客户端只需要将命令和数据一同存储到Display list中，然后一次性发送给服务器。关于Display list更详细的介绍请参考[Display list](http://www.songho.ca/opengl/gl_displaylist.html)

## Vertex Operation

每个顶点坐标以及法向经过GL_MODELVIEW矩阵变换，使得坐标点或者法向从模型坐标系变换到摄像机坐标系。所以，如果这时候有光照参与的话，那么这些基于顶点的光照计算是使用变换后的顶点坐标和法向，也就是在观察坐标系下进行光照计算。然后使用光照计算后的颜色值替换掉原先的顶点颜色。想了解更多关于坐标变换的请参考[Transformation](http://www.songho.ca/opengl/gl_transform.html)。

## Primitive Assembly

在顶点变换后，点、线、多边形这些图元会使用投影矩阵，进一步从摄像机空间变换到裁剪空间，然后基于裁剪空间的裁剪平面进行裁剪，数学上的操作原理是将变换后的坐标的x、y、z这三个分量与[-w,w]进行比较，如果三个分量都在里面的话，说明这个点在裁剪包围盒内。经过裁剪后的图元数量会减少很多，然后也就是后续需要处理的数据量减少了。然后我们再做透视除法，也就是将x、y、z三个分量分别处以w，得到齐次设备空间坐标。齐次设备空间x、y、z三个坐标范围是在[-1,1]。然后再经过ViewPot变换，从三维场景变换到屏幕空间坐标系，也就是具体的像素坐标位置。图元拼装的最后一步是图元剔除，例如当前开启的是背面剔除，那么图元法向与视角方向内积小于零的会被剔除。

## Pixel Transfer Operation

当从内存中读取像素数据，并且对像素值进行解析后，我们会对这些像素数据进行缩放、偏移、映射、裁剪操作。这些操作就叫做像素变换操作。这些变换后的数据可以存储在纹理图片中，也可以直接栅格化到片段中，进入后续的片段着色过程。

## Texture Memory

纹理图像被加载后是存储在纹理存储块中，当我们渲染模型时，可以直接从纹理存储块中读取纹理数据。

## Rasterization

栅格化处理是指，将几何数据(包括顶点、法向、uv等)和像素数据转换到片段中，片段数据是一组矩形数组，包含颜色、深度、线宽、点的大小、以及抗锯齿算法模型(GL_POINT_SMOOTH, GL_LINE_SMOOTH, GL_POLYGON_SMOOTH)。如果渲染模式设置的是填充模式GL_FILL,那么多边形区域内的像素填充将发生在这个阶段。每一个片段对应于帧缓存中的一个像素。这里要提一下，帧缓存的尺寸和屏幕大小没有必然关系。

## Fragment Operation

片段操作是渲染流程的最后一步，从片段数据转换为帧缓存中的像素值。这个阶段的第一步是像素生成；从纹理缓存开中的纹理元素被应用于每一个片段。然后计算雾的颜色。最后，需要进行各种测试，测试顺序为： 剪刀测试 --> 透明通道测试 --> 模板测试 -->  深度测试。

## Feedback

OpenGL 可以通过glGet()、gllsEnabled()两个命令获取当前渲染过程中大部分的状态以及信息。如果需要，我们还可以使用glReadPixels()从帧缓存中截取一块像素数据，也可以使用glRenderMode(GL_FEEDBACK)来获取所有变换后的顶点数据。值得注意的是，glCopyPixels()并不是将像素数据返回到CPU，而实将其复制到其他的帧缓存，例如从前置帧到后置帧。这里前置和后置构成了双帧缓存机制。